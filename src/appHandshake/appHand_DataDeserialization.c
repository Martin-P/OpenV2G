


/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Sebastian.Kaebisch.EXT@siemens.com
 * @version 0.6
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXISeGen</p>
 *
 ********************************************************************/

 
 #include "appHand_service.h"
 #include "appHand_dataTypes.h"
 #include "EXITypes.h"
 #include "appHand_EXIDecoder.h"
 #include "StringTable.h"
 #include <string.h>
 

static int _setUnsignedInt32Value(integer_t* iv, uint32_t* int32) {
	int errn = 0;
	switch(iv->type) {
	/* Unsigned Integer */
	case UNSIGNED_INTEGER_8:
		*int32 = iv->val.uint8;
		break;
	case UNSIGNED_INTEGER_16:
		*int32 = iv->val.uint16;
		break;
	case UNSIGNED_INTEGER_32:
		if (iv->val.uint32 <= 2147483647) {
			*int32 = iv->val.uint32;
		} else {
			errn = EXI_UNSUPPORTED_INTEGER_VALUE;
		}
		break;
	case UNSIGNED_INTEGER_64:
		errn = EXI_UNSUPPORTED_INTEGER_VALUE;
		break;
	/* (Signed) Integer */
	case INTEGER_8:
		*int32 = iv->val.int8;
		break;
	case INTEGER_16:
		*int32 = iv->val.int16;
		break;
	case INTEGER_32:
		*int32 = iv->val.int32;
		break;
	case INTEGER_64:
		errn = EXI_UNSUPPORTED_INTEGER_VALUE;
	}
	return errn;
}
 





 /**
 * Deserialize an element or attribute value of the EXI stream and assign it to the
 * service data structure 
 */
static int deserializeElementAttributeCharacter(struct EXIDatabinder* service)
{

	switch(service->eqn.namespaceURI) {
		case 0:
			switch(service->eqn.localPart) {
				case 2: /*ProtocolNamespace*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].ProtocolNamespace.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].ProtocolNamespace.arraylen.data = service->val.string.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 5: /*VersionNumberMajor*/

				if(service->val.type == UNSIGNED_INTEGER) 
					{
						_setUnsignedInt32Value( &(service->val.integer),&(service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].VersionNumberMajor));

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 6: /*VersionNumberMinor*/

				if(service->val.type == UNSIGNED_INTEGER) 
					{
						_setUnsignedInt32Value( &(service->val.integer),&(service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].VersionNumberMinor));

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 4: /*SchemaID*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						if( service->idPath.id[0] == 7)
						{
							service->exiMsg.supportedAppProtocolRes->SchemaID = service->val.integer.val.uint8;
						service->exiMsg.supportedAppProtocolRes->isused.SchemaID=1;

						} else if(service->idPath.id[0] == 6)
						{
							service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].SchemaID = service->val.integer.val.uint8;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 1: /*Priority*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].Priority = service->val.integer.val.uint8;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 3: /*ResponseCode*/

				if(service->val.type == ENUMERATION) 
					{
						service->exiMsg.supportedAppProtocolRes->ResponseCode = service->val.enumeration;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;	
			} /* close switch(service->eqn.localPart) */	
		break;
	
	} /* close switch(service->eqn.namespaceURI) */
	return 0;
}
 
/**
 * Deserialize an element of the EXI stream
 * @return 0 = 0K; -1 = ERROR
 */
static int deserializeElement(struct EXIDatabinder* service)
{
	switch(service->eqn.namespaceURI) {
		case 0:
			switch(service->eqn.localPart) {
				case 0:/* AppProtocol */	

								service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol++;
		  
				break;	

			}
		break;
		case 4:
			switch(service->eqn.localPart) {
				case 6:/* supportedAppProtocolReq */	

								service->exiMsg.isused.supportedAppProtocolReq=1;
		  
				break;	
				case 7:/* supportedAppProtocolRes */	

								service->exiMsg.isused.supportedAppProtocolRes=1;
		  
				break;	

			}
		break;
		

	}
	return 0;
}


 
 
/**
* Deserialize the EXI stream
* @return 0 = 0K; -1 = ERROR
*/
int deserialize_appHand(struct EXIDatabinder* service, uint8_t* inStream, uint16_t sizeInStream, struct EXIDocumentType_appHand* exiDoc)
{
 	exi_name_table_runtime_t runtimeTableDecode;
 	uint32_t inPos;
 	int noEndOfDocument = 1; /* true */
	int returnCode=0;
	

	/* assign inStream data to service EXI structure */
	inPos = service->transportHeaderOffset;
	service->inStream.data = inStream;
	service->inStream.size = sizeInStream+inPos;
	service->inStream.pos = &inPos;
	service->inStream.buffer=0;
	service->inStream.capacity=0;


	service->exiMsg=*exiDoc;

	exiInitNameTableRuntime(&runtimeTableDecode);
	exiappHandInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	do {
		exiappHandDecodeNextEvent(&(service->inStream), &(service->stateDecode), &(service->event));
			if (returnCode < 0) {
				printf("[ERROR] %d \n", returnCode);
				return returnCode;
			}

			switch (service->event) {
			case START_DOCUMENT:

				returnCode = exiappHandDecodeStartDocument(&(service->inStream), &(service->stateDecode));

				break;
			case END_DOCUMENT:

				returnCode = exiappHandDecodeEndDocument(&(service->inStream), &(service->stateDecode));
				noEndOfDocument = 0; /* false */
				break;
			case START_ELEMENT:
				returnCode = exiappHandDecodeStartElement(&(service->inStream), &(service->stateDecode), &(service->eqn));
				service->idPath.id[service->idPath.pos++]=service->eqn.localPart;
				 
				break;
			case END_ELEMENT:

				returnCode = exiappHandDecodeEndElement(&(service->inStream), &(service->stateDecode), &(service->eqn));
				service->idPath.pos--;
				 
				returnCode = deserializeElement(service);
				break;
			case CHARACTERS:
				/* decode */
				returnCode = exiappHandDecodeCharacters(&(service->inStream), &(service->stateDecode), &(service->val));
				 
				/* assign character data to the v2g message structure */
				returnCode = deserializeElementAttributeCharacter(service);
				break;
			case ATTRIBUTE:
				/* decode */
				returnCode = exiappHandDecodeAttribute(&(service->inStream), &(service->stateDecode), &(service->eqn), &(service->val));
				returnCode = deserializeElementAttributeCharacter(service);
				break;
			default:
				/* ERROR */
				return -1;
			}

		} while (noEndOfDocument);

	return 0;
}
 
 
 
/* Initialize the deserializer */
int init_appHandDeserializer(struct EXIDatabinder* service, bytes_t bytes, string_ucs_t string, uint16_t transportHeaderOffset)
{

	/* init byte array */
	 service->val.binary = bytes;

	/* init string array */
	 service->val.string = string;


	 service->idPath.pos=0;

	 /* init offset for transport protocol */
	service->transportHeaderOffset=transportHeaderOffset;


	return 0;
}


