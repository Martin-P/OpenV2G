/*
 * Copyright (C) 2007-2013 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.8
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer.com</p>
 * <p>Schema: input/appHandshake/V2G_CI_AppProtocol.xsd</p>
 *
 *
 ********************************************************************/



#ifndef EXI_appHand_DECODER_C
#define EXI_appHand_DECODER_C


#include "appHandEXIDecoder.h"

#include "EXIOptions.h"
#include "EXITypes.h"
#include "BitInputStream.h"
#include "DecoderChannel.h"

#include "StringNameTable.h"
#include "appHandNameTableEntries.h"
#include "MethodsBag.h"

#include "appHandEXICoder.h"
#include "EXIHeaderDecoder.h"
#include "ErrorCodes.h"

#include "appHandQNames.h"
#include "appHandQNameDefines.h"



/* local variables */
static uint32_t xsi;
static uint32_t bits;
static int errn;
static exi_event_t currEvent;

#define URI_CODEPOINTS_SIZE 35
#define LOCALNAME_CODEPOINTS_SIZE 25

uint32_t codepointsUri[URI_CODEPOINTS_SIZE];
uint32_t codepointsLocalName[LOCALNAME_CODEPOINTS_SIZE];

static exi_qname_t _qname = {
		{EXI_NAME_ENTRY_TYPE_ID, 0, {URI_CODEPOINTS_SIZE, codepointsUri, 0}},
		{EXI_NAME_ENTRY_TYPE_ID, 0, {LOCALNAME_CODEPOINTS_SIZE, codepointsLocalName, 0}}
};


static int _decodeNBitIntegerValue(bitstream_t* stream, exi_integer_t* iv, uint16_t nbits, int32_t lowerBound) {
	int errn;
	uint32_t val;
	int32_t val2;

	/* at most 8 bits */
	errn = decodeNBitUnsignedInteger(stream, nbits, &val);
	if(errn == 0) {
		val2 = (int32_t)val + lowerBound;
		if(val2 < 0) {
			/* negative */
			/* TODO map integer value more fine-grained */
			iv->type = EXI_INTEGER_32;
			iv->val.int32 = (int32_t)val2;
		} else {
			/* positive */
			if (val2 < 0x100) {
				/* 8 bit */
				iv->type = EXI_UNSIGNED_INTEGER_8;
				iv->val.uint8 = (uint8_t)val2;
			} else if (val2 < 0x10000) {
				/* 16 bit */
				iv->type = EXI_UNSIGNED_INTEGER_16;
				iv->val.uint16 = (uint16_t)val2;
			} else {
				iv->type = EXI_UNSIGNED_INTEGER_32;
				iv->val.uint32 = (uint32_t)val2;
			}
		}
	}

	return (errn);
}



static int exiDecodeNext2Event(bitstream_t* stream, exi_state_t* state,
		exi_event_t* nextEvent) {
	
	uint32_t eventCode2 = 0;
	int16_t ruleID = state->grammarStack[state->stackIndex];
	errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;

	switch (ruleID) {
	case 5:
		/* Element[END_ELEMENT] */
	case 19:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 20:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 21:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 22:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 43:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 1, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			break;
		case 1:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
			break;
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_TYPE;
			break;
		case 1:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_NIL;
			break;
		case 2:
			*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED;
			break;
		case 3:
			*nextEvent = EXI_EVENT_ATTRIBUTE_INVALID_VALUE;
			errn = decodeNBitUnsignedInteger(stream, 0, &state->eventCode);
			state->eventCode -= 1;
			break;
		case 4:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			break;
		case 5:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
			break;
		}
		break;
	case 7:
		/* Element[CHARACTERS[STRING]] */
	case 8:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 10:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 12:
		/* Element[START_ELEMENT(SchemaID)] */
	case 14:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 15:
		/* Element[START_ELEMENT(Priority)] */
	case 17:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 18:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 42:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 44:
		/* Element[START_ELEMENT(ResponseCode)] */
	case 48:
		/* Element[CHARACTERS[LIST]] */
	case 52:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 54:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 56:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 58:
		/* Element[CHARACTERS[DATETIME]] */
	case 60:
		/* Element[CHARACTERS[DATETIME]] */
	case 62:
		/* Element[CHARACTERS[DECIMAL]] */
	case 64:
		/* Element[CHARACTERS[FLOAT]] */
	case 66:
		/* Element[CHARACTERS[DATETIME]] */
	case 68:
		/* Element[CHARACTERS[DATETIME]] */
	case 70:
		/* Element[CHARACTERS[DATETIME]] */
	case 72:
		/* Element[CHARACTERS[DATETIME]] */
	case 74:
		/* Element[CHARACTERS[DATETIME]] */
	case 76:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 78:
		/* Element[CHARACTERS[INTEGER]] */
	case 81:
		/* Element[CHARACTERS[DATETIME]] */
		errn = decodeNBitUnsignedInteger(stream, 2, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_END_ELEMENT_UNDECLARED;
			break;
		case 1:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			break;
		case 2:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
			break;
		}
		break;
	case 2:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 3:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
	case 4:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 9:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 13:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 16:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 40:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 41:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 47:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 51:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 53:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 55:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 57:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 59:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 61:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 63:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 65:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 67:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 69:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 71:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 73:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 75:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 77:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 79:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 80:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_END_ELEMENT_UNDECLARED;
			break;
		case 1:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_TYPE;
			break;
		case 2:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_NIL;
			break;
		case 3:
			*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED;
			break;
		case 4:
			*nextEvent = EXI_EVENT_ATTRIBUTE_INVALID_VALUE;
			errn = decodeNBitUnsignedInteger(stream, 0, &state->eventCode);
			state->eventCode -= 1;
			break;
		case 5:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			break;
		case 6:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
			break;
		}
		break;

	default:
		if (ruleID < 0) {
			/* built-in element grammar */
			if ( exi_appHand_IsStartContent(ruleID) ) {
				/* TODO generate 2nd level productions */

				/* StartTagContent grammar */
				errn = decodeNBitUnsignedInteger(stream, 2, &eventCode2);
				if(errn == 0) {
					switch(eventCode2) {
					case 0:
						/* 0: EE */
						*nextEvent = EXI_EVENT_END_ELEMENT_UNDECLARED;
						break;
					case 1:
						/* 1: AT(*) */
						*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED;
						break;
					case 2:
						/* 2: SE(*) */
						*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
						break;
					case 3:
						/* 3: CH */
						*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
						break;
					default:
						errn = (EXI_ERROR_UNEXPECTED_EVENT_LEVEL2);
						break;
					}
				}
			} else {
				/* TODO generate 2nd level productions */

				/* ElementContent grammar */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode2);
				if(errn == 0) {
					switch(eventCode2) {
					case 0:
						/* 0: SE(*) */
						*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
						break;
					case 1:
						/* 1: CH */
						*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
						break;
					default:
						errn = (EXI_ERROR_UNEXPECTED_EVENT_LEVEL2);
						break;
					}
				}
			}
		} else {
			*nextEvent = EXI_EVENT_ERROR;
			errn = (EXI_ERROR_UNEXPECTED_EVENT_LEVEL2);
		}
		break;
	}

	return (errn);
	
}



static int _exiDecodeNamespaceUri(bitstream_t* stream, exi_state_t* state,
		exi_name_entry_t* uri) {
	uint16_t uriSize, uriCodingLength;
	uint32_t uriID;

	errn = exiGetUriSize(&state->nameTablePrepopulated, &state->nameTableRuntime, &uriSize);
	if (errn == 0) {
		/* URI Entries + 1 */
		errn = exiGetCodingLength((uint16_t)(uriSize + 1u), &uriCodingLength);
		if (errn == 0) {
			errn = decodeNBitUnsignedInteger(stream, uriCodingLength, &uriID);
			if (errn == 0) {
				if (uriID == 0) {
					/* uri string value was not found */
					/* ==> zero (0) as an n-nit unsigned integer */
					/* followed by uri encoded as string */
					
					uri->type = EXI_NAME_ENTRY_TYPE_STRING_AND_ID;
					errn = decodeString(stream, &uri->str);
					if (errn) {
						return (errn);
					}
					/* after encoding string value is added to table */
					errn = exiAddUri(&state->nameTablePrepopulated, &state->nameTableRuntime); /*, namespaceURI->chars); */
					if (errn) {
						return (errn);
					}
					uri->id = uriSize;
					
				} else {
					/* uri string value found */
					/* ==> value(i+1) is encoded as n-bit unsigned integer */
					uri->type = EXI_NAME_ENTRY_TYPE_ID;
					uri->id = (uint16_t)(uriID - 1);
				}
			}
		}
	}

	return (errn);
}

static int _exiDecodeLocalName(bitstream_t* stream, exi_state_t* state,
		uint16_t uriID, exi_name_entry_t* localName) {

	uint32_t localNameID;
	uint16_t slen;
	uint16_t localNameSize;
	uint16_t localNameCodingLength;

	errn = decodeUnsignedInteger16(stream, &slen);
	if (errn == 0) {
		if (slen > 0) {
			/* string value was not found in local partition */
			/* ==> string literal is encoded as a String */
			/* with the length of the string incremented by one */
			
			localName->type = EXI_NAME_ENTRY_TYPE_STRING_AND_ID;
			if (slen-- >= (localName->str.size) ) {
				errn = (EXI_ERROR_OUT_OF_BOUNDS);
			} else {
				localName->str.len = slen;
				errn = decodeCharacters(stream, slen, localName->str.codepoints);
				if (errn == 0) {
					/* After encoding the string value, it is added to the string table */
					/* partition and assigned the next available compact identifier */
					errn = exiAddLocalName(&state->nameTablePrepopulated, &state->nameTableRuntime, uriID, &localName->id);
				}
			}
			
		} else {
			/* string value found in local partition */
			/* ==> string value is represented as zero (0) encoded as an */
			/* Unsigned Integer */
			/* followed by an the compact identifier of the string value as an */
			/* n-bit unsigned integer */
			/* n is log2 m and m is the number of entries in the string table */
			/* partition */
			localName->type = EXI_NAME_ENTRY_TYPE_ID;
			errn = exiGetLocalNameSize(&state->nameTablePrepopulated, &state->nameTableRuntime, uriID, &localNameSize); /* uriID, &localNameSize); */
			if (errn == 0) {
				errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
				if (errn == 0) {
					errn = decodeNBitUnsignedInteger(stream, localNameCodingLength, &localNameID); /*  localNameID);*/
					localName->id = (uint16_t)(localNameID);
				}
			}
		}
	}

	return (errn);
}

static int _exiDecodeQName(bitstream_t* stream, exi_state_t* state,
		uint16_t* qnameID,  exi_qname_t* qname) {

	/* uri */
	errn = _exiDecodeNamespaceUri(stream, state, &qname->uri);
	if (errn == 0) {
		/* localName */
		errn = _exiDecodeLocalName(stream, state, qname->uri.id, &qname->localName);
		if (errn == 0) {
			if (_qname.localName.type == EXI_NAME_ENTRY_TYPE_STRING_AND_ID) {
				errn = exiappHandAddEQName(state, qnameID, qname->uri.id, qname->localName.id);
			} else {
				/* IDs known --> retrieve qnameID */
				errn = exiappHandGetQNameID(state, qname->uri.id, qname->localName.id, qnameID);
			}
		}
	}

	return (errn);
}


static int _exiDecodeStartElement(exi_state_t* state, uint16_t qnameID,
		uint16_t stackId, int16_t newState) {

	/* move on */
	state->grammarStack[state->stackIndex] = (int16_t)stackId;
	/* push element on stack */
	return (exi_appHand_PushStack(state, newState, qnameID));
}


int exiappHandGetLastQName(exi_qname_t** qname) {
	*qname = &_qname;
	return (0);
}


int exiappHandDecodeListValue(bitstream_t* stream, exi_state_t* state, uint16_t qnameID, exi_value_t* val, exi_list_t lt) {
	uint32_t uint32;

	val->type = lt.type;

	switch(lt.type) {
	case EXI_DATATYPE_BINARY_BASE64:
	case EXI_DATATYPE_BINARY_HEX:
		errn = decodeBinary(stream, &val->binary);
		break;
	case EXI_DATATYPE_BOOLEAN:
		errn = decodeBoolean(stream, &val->boolean);
		break;
	case EXI_DATATYPE_BOOLEAN_FACET:
		errn = decodeNBitUnsignedInteger(stream, 2, &uint32);
		val->boolean = uint32 > 1;
		break;
	case EXI_DATATYPE_DECIMAL:
		errn = decodeDecimal(stream, &val->decimal);
		break;
	case EXI_DATATYPE_FLOAT:
		errn = decodeFloat(stream, &val->float_me);
		break;
	case EXI_DATATYPE_NBIT_UNSIGNED_INTEGER:
		errn = EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		break;
	case EXI_DATATYPE_UNSIGNED_INTEGER:
		errn = decodeUnsignedInteger(stream, &val->integer);
		break;
	case EXI_DATATYPE_INTEGER:
		errn = decodeInteger(stream, &val->integer);
		break;
	case EXI_DATATYPE_DATETIME:
		errn = decodeDateTime(stream,lt.datetimeType, &val->datetime);
		break;
	case EXI_DATATYPE_STRING:
		errn = decodeStringValue(stream, state, qnameID, &val->str);
		break;
	default:
		errn = EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		break;
	}

	return (errn);
}




int exiappHandInitDecoder(bitstream_t* stream, exi_state_t* state,
		exi_name_table_runtime_t runtimeTable, exi_value_table_t stringTable) {
#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0
	int i;
#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */
	/* init grammar state */
	state->stackIndex = 0;
	state->grammarStack[0] = DOCUMENT;
	/* name table */
	state->nameTablePrepopulated = exiappHandNameTablePrepopulated;
	state->nameTableRuntime = runtimeTable;
	/* next qname ID */
	state->nextQNameID = EXI_appHandNUMBER_OF_PREPOPULATED_QNAMES;
	/* string table */
	state->stringTable = stringTable;
	state->stringTable.numberOfGlobalStrings = 0;
#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0
	for(i=0; i<(state->stringTable.sizeLocalStrings); i++) {
		state->stringTable.numberOfLocalStrings[i] = 0;
	}
#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */

	/* runtime grammars */
	state->numberOfRuntimeGrammars = 0;

	/* Avoid warning: Unused declaration of variable 'name' */
	xsi = 0;
	bits = 0;

	/* decode header */
	return (readEXIHeader(stream));
}

int exiappHandDecodeNextEvent(bitstream_t* stream, exi_state_t* state,
		exi_event_t* nextEvent) {
	uint16_t codingLength;
	uint16_t numberOfProductions;
	uint32_t eventCode1;
	int16_t ruleID = state->grammarStack[state->stackIndex];
	state->eventCode = 0;
	errn = 0;

	switch (ruleID) {
	case 19:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 20:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 21:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 22:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 43:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 1:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 2:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 2:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 3:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
	case 8:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 12:
		/* Element[START_ELEMENT(SchemaID)] */
	case 15:
		/* Element[START_ELEMENT(Priority)] */
	case 18:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 40:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 44:
		/* Element[START_ELEMENT(ResponseCode)] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 0:
		/* Document[START_DOCUMENT] */
	case 45:
		/* Fragment[START_DOCUMENT] */
		*nextEvent = EXI_EVENT_START_DOCUMENT;
		break;
	case 46:
		/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */
		errn = decodeNBitUnsignedInteger(stream, 4, &state->eventCode);
		switch (state->eventCode) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 9:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		case 10:
			*nextEvent = EXI_EVENT_END_DOCUMENT;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 39:
		/* DocEnd[END_DOCUMENT] */
		*nextEvent = EXI_EVENT_END_DOCUMENT;
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC;
			break;
		case 1:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		case 2:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 3:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC;
			break;
		case 4:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 4:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 7:
		/* Element[CHARACTERS[STRING]] */
	case 9:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 10:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 13:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 14:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 16:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 17:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 41:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 42:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 47:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 48:
		/* Element[CHARACTERS[LIST]] */
	case 51:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 52:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 53:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 54:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 55:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 56:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 57:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 58:
		/* Element[CHARACTERS[DATETIME]] */
	case 59:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 60:
		/* Element[CHARACTERS[DATETIME]] */
	case 61:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 62:
		/* Element[CHARACTERS[DECIMAL]] */
	case 63:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 64:
		/* Element[CHARACTERS[FLOAT]] */
	case 65:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 66:
		/* Element[CHARACTERS[DATETIME]] */
	case 67:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 68:
		/* Element[CHARACTERS[DATETIME]] */
	case 69:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 70:
		/* Element[CHARACTERS[DATETIME]] */
	case 71:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 72:
		/* Element[CHARACTERS[DATETIME]] */
	case 73:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 74:
		/* Element[CHARACTERS[DATETIME]] */
	case 75:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 76:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 77:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 78:
		/* Element[CHARACTERS[INTEGER]] */
	case 79:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 80:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 81:
		/* Element[CHARACTERS[DATETIME]] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_CHARACTERS;
			break;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 5:
		/* Element[END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
		case 1:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 2:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		case 1:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 2:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC;
			break;
		case 3:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;

	default:
		
		if(ruleID < 0)  {
			/* built-in element grammar */
			numberOfProductions = state->runtimeGrammars[(ruleID + 1)*(-1)].numberOfProductions;
			if(numberOfProductions > 0) {
				/* decode 1st level event code */
				errn = exiGetCodingLength((uint16_t)(numberOfProductions + 1u), &codingLength);
				if(errn == 0) {
					errn = decodeNBitUnsignedInteger(stream, codingLength, &eventCode1);
					if(errn == 0) {
						if(eventCode1 == numberOfProductions) {
							/* 2nd level */
							errn = exiDecodeNext2Event(stream, state, nextEvent);
						} else {
							/* 1st level event not supported in profile */
							errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
						}
					}
				}
			} else {
				errn = exiDecodeNext2Event(stream, state, nextEvent);
			}
		} else {
			*nextEvent = EXI_EVENT_ERROR;
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
		}
		
		break;
	}

	currEvent = *nextEvent;
	return (errn);
}

#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandDecodeStartDocument(bitstream_t* stream, exi_state_t* state) {
	errn = 0;
	switch(state->grammarStack[state->stackIndex]) {
	case 0:
		/* move on */
		state->grammarStack[state->stackIndex] = 1;
		break;
	case 45:
		/* move on */
		state->grammarStack[state->stackIndex] = 46;
		break;

	default:
		errn =(EXI_ERROR_UNEXPECTED_START_DOCUMENT);
		break;
	}

	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */

#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandDecodeEndDocument(bitstream_t* stream, exi_state_t* state) {
	errn = 0;
	switch(state->grammarStack[state->stackIndex]) {
	case 39:
		break;
	case 46:
		break;

	default:
		errn =(EXI_ERROR_UNEXPECTED_END_DOCUMENT);
		break;
	}
	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */


int exiappHandDecodeStartElement(bitstream_t* stream, exi_state_t* state,
		uint16_t* qnameID) {
	errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;

	switch(currEvent) {
	case EXI_EVENT_START_ELEMENT:
		switch (state->grammarStack[state->stackIndex]) {
		case 1:
			/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 65, 39, 2);
				break;
			case 1:
				errn = _exiDecodeStartElement(state, *qnameID = 66, 39, 40);
				break;
			}
			break;
		case 2:
			/* FirstStartTag[START_ELEMENT(AppProtocol)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 19, 3);
				break;
			}
			break;
		case 3:
			/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 2, 8, 4);
				break;
			}
			break;
		case 8:
			/* Element[START_ELEMENT(VersionNumberMajor)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 5, 11, 9);
				break;
			}
			break;
		case 11:
			/* Element[START_ELEMENT(VersionNumberMinor)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 6, 12, 9);
				break;
			}
			break;
		case 12:
			/* Element[START_ELEMENT(SchemaID)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 4, 15, 13);
				break;
			}
			break;
		case 15:
			/* Element[START_ELEMENT(Priority)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 1, 5, 16);
				break;
			}
			break;
		case 18:
			/* Element[START_ELEMENT(ProtocolNamespace)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 2, 8, 4);
				break;
			}
			break;
		case 19:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 20, 3);
				break;
			}
			break;
		case 20:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 21, 3);
				break;
			}
			break;
		case 21:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 22, 3);
				break;
			}
			break;
		case 22:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 23, 3);
				break;
			}
			break;
		case 23:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 24, 3);
				break;
			}
			break;
		case 24:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 25, 3);
				break;
			}
			break;
		case 25:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 26, 3);
				break;
			}
			break;
		case 26:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 27, 3);
				break;
			}
			break;
		case 27:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 28, 3);
				break;
			}
			break;
		case 28:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 29, 3);
				break;
			}
			break;
		case 29:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 30, 3);
				break;
			}
			break;
		case 30:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 31, 3);
				break;
			}
			break;
		case 31:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 32, 3);
				break;
			}
			break;
		case 32:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 33, 3);
				break;
			}
			break;
		case 33:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 34, 3);
				break;
			}
			break;
		case 34:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 35, 3);
				break;
			}
			break;
		case 35:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 36, 3);
				break;
			}
			break;
		case 36:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 37, 3);
				break;
			}
			break;
		case 37:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 5, 3);
				break;
			}
			break;
		case 38:
			/* Element[START_ELEMENT(AppProtocol)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 19, 3);
				break;
			}
			break;
		case 40:
			/* FirstStartTag[START_ELEMENT(ResponseCode)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 3, 43, 41);
				break;
			}
			break;
		case 43:
			/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 4, 5, 13);
				break;
			}
			break;
		case 44:
			/* Element[START_ELEMENT(ResponseCode)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 3, 43, 41);
				break;
			}
			break;
		case 46:
			/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 46, 3);
				break;
			case 1:
				errn = _exiDecodeStartElement(state, *qnameID = 1, 46, 16);
				break;
			case 2:
				errn = _exiDecodeStartElement(state, *qnameID = 2, 46, 4);
				break;
			case 3:
				errn = _exiDecodeStartElement(state, *qnameID = 3, 46, 41);
				break;
			case 4:
				errn = _exiDecodeStartElement(state, *qnameID = 4, 46, 13);
				break;
			case 5:
				errn = _exiDecodeStartElement(state, *qnameID = 5, 46, 9);
				break;
			case 6:
				errn = _exiDecodeStartElement(state, *qnameID = 6, 46, 9);
				break;
			case 7:
				errn = _exiDecodeStartElement(state, *qnameID = 65, 46, 2);
				break;
			case 8:
				errn = _exiDecodeStartElement(state, *qnameID = 66, 46, 40);
				break;
			}
			break;

		}
		break;
	case EXI_EVENT_START_ELEMENT_NS:
		errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;
		break;
	case EXI_EVENT_START_ELEMENT_GENERIC:
		errn = _exiDecodeQName(stream, state, qnameID,
				&_qname);
		if (errn == 0) {
			/* update current rule, according next SE(*) grammar */
			switch (state->grammarStack[state->stackIndex]) {
			case 1:
				/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] --> DocEnd[END_DOCUMENT] */
				state->grammarStack[state->stackIndex] = 39;
				break;
			case 46:
				/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] --> FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */
				state->grammarStack[state->stackIndex] = 46;
				break;
			case 49:
				/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] --> Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
				state->grammarStack[state->stackIndex] = 50;
				break;
			case 50:
				/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] --> Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
				state->grammarStack[state->stackIndex] = 50;
				break;

			default:
				errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;
				break;
			}
			if (errn == 0) {
				/* retrieve global grammar(existing OR runtime) and push it stack */
				errn = exi_appHand_RetrieveAndPushGlobalGrammar(state, *qnameID);
			}
		}
		break;
	case EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED:
		errn = _exiDecodeQName(stream, state, qnameID,
				&_qname);
		if (errn == 0) {
			/* update current rule --> element content rule (if not already) */
			errn = exi_appHand_MoveToElementContentRule(state);
			if (errn == 0) {
				/* retrieve global grammar(existing OR runtime) and push it stack */
				errn = exi_appHand_RetrieveAndPushGlobalGrammar(state, *qnameID);
			}
		}
		break;
	default:
		errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;
		break;
	}

	return (errn);
}


#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandDecodeEndElement(bitstream_t* stream, exi_state_t* state, uint16_t* qnameID) {
	int16_t currentID;
	errn = 0;
	switch(currEvent) {
	case EXI_EVENT_END_ELEMENT_UNDECLARED:
		currentID = state->grammarStack[state->stackIndex];
		if (currentID < 0) {
			
			/* runtime grammars do have IDs smaller than 0 */
			/* learn EE event */
			errn = exi_appHand_LearnEndElement(state);
			
		}
		if(errn == 0) {
			/* copy IDs */
			*qnameID = state->elementStack[state->stackIndex];
			errn = (exi_appHand_PopStack(state));
		}
		break;
	default:
		/* copy IDs */
		*qnameID = state->elementStack[state->stackIndex];
		errn = (exi_appHand_PopStack(state));
		break;
	}

	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */


int exiappHandDecodeCharacters(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int16_t moveOnID = 0;
	errn = EXI_ERROR_UNEXPECTED_CHARACTERS;

	switch(currEvent) {
	case EXI_EVENT_CHARACTERS:
	case EXI_EVENT_CHARACTERS_GENERIC:
		switch (state->grammarStack[state->stackIndex]) {
		case 73:
			/* DATETIME */
		case 74:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GYEARMONTH, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 59:
			/* DATETIME */
		case 60:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_DATETIME, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 80:
			/* DATETIME */
		case 81:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_TIME, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 75:
			/* BINARY_HEX */
		case 76:
			/* BINARY_HEX */
			val->type = EXI_DATATYPE_BINARY_HEX;
			errn = decodeBinary(stream, &val->binary);
			moveOnID = 5; /* move on ID */
			break;
		case 53:
			/* BOOLEAN */
		case 54:
			/* BOOLEAN */
			val->type = EXI_DATATYPE_BOOLEAN;
			errn = decodeBoolean(stream, &val->boolean);
			moveOnID = 5; /* move on ID */
			break;
		case 57:
			/* DATETIME */
		case 58:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_DATE, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 65:
			/* DATETIME */
		case 66:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GDAY, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 55:
			/* NBIT_UNSIGNED_INTEGER */
		case 56:
			/* NBIT_UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			errn = _decodeNBitIntegerValue(stream, &val->integer, 8, -128);
			moveOnID = 5; /* move on ID */
			break;
		case 9:
			/* UNSIGNED_INTEGER */
		case 10:
			/* UNSIGNED_INTEGER */
		case 79:
			/* UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_UNSIGNED_INTEGER;
			errn = decodeUnsignedInteger(stream, &val->integer);
			moveOnID = 5; /* move on ID */
			break;
		case 16:
			/* NBIT_UNSIGNED_INTEGER */
		case 17:
			/* NBIT_UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			errn = _decodeNBitIntegerValue(stream, &val->integer, 5, 1);
			moveOnID = 5; /* move on ID */
			break;
		case 51:
			/* BINARY_BASE64 */
		case 52:
			/* BINARY_BASE64 */
			val->type = EXI_DATATYPE_BINARY_BASE64;
			errn = decodeBinary(stream, &val->binary);
			moveOnID = 5; /* move on ID */
			break;
		case 67:
			/* DATETIME */
		case 68:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GMONTH, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 41:
			/* ENUMERATION */
		case 42:
			/* ENUMERATION */
			val->type = EXI_DATATYPE_ENUMERATION;
			errn = decodeNBitUnsignedInteger(stream, 2, &val->enumeration);
			moveOnID = 5; /* move on ID */
			break;
		case 49:
			/* STRING */
		case 50:
			/* STRING */
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			moveOnID = 50; /* move on ID */
			break;
		case 63:
			/* FLOAT */
		case 64:
			/* FLOAT */
			val->type = EXI_DATATYPE_FLOAT;
			errn = decodeFloat(stream, &val->float_me);
			moveOnID = 5; /* move on ID */
			break;
		case 47:
			/* LIST */
		case 48:
			/* LIST */
			val->type = EXI_DATATYPE_LIST;
			val->list.type = EXI_DATATYPE_STRING;
			errn = decodeUnsignedInteger16(stream, &val->list.len);
			moveOnID = 5; /* move on ID */
			break;
		case 69:
			/* DATETIME */
		case 70:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GMONTHDAY, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 61:
			/* DECIMAL */
		case 62:
			/* DECIMAL */
			val->type = EXI_DATATYPE_DECIMAL;
			errn = decodeDecimal(stream, &val->decimal);
			moveOnID = 5; /* move on ID */
			break;
		case 13:
			/* NBIT_UNSIGNED_INTEGER */
		case 14:
			/* NBIT_UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			errn = _decodeNBitIntegerValue(stream, &val->integer, 8, 0);
			moveOnID = 5; /* move on ID */
			break;
		case 77:
			/* INTEGER */
		case 78:
			/* INTEGER */
			val->type = EXI_DATATYPE_INTEGER;
			errn = decodeInteger(stream, &val->integer);
			moveOnID = 5; /* move on ID */
			break;
		case 71:
			/* DATETIME */
		case 72:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GYEAR, &val->datetime);
			moveOnID = 5; /* move on ID */
			break;
		case 4:
			/* STRING */
		case 7:
			/* STRING */
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			moveOnID = 5; /* move on ID */
			break;

		}
		if (errn == 0) {
			/* move on */
			state->grammarStack[state->stackIndex] = moveOnID;
		}
		break;
	case EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED:
		if (state->grammarStack[state->stackIndex] < 0) {
			/* runtime grammars do have IDs smaller than 0 */
			errn = (EXI_UNSUPPORTED_GRAMMAR_LEARNING_CH);
		} else {
			/* update current rule --> element content rule (if not already) */
			errn = exi_appHand_MoveToElementContentRule(state);
			if (errn == 0) {
				/* read content value as STRING */
				val->type = EXI_DATATYPE_STRING;
				errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			}
		}
		break;
	default:
		errn = EXI_ERROR_UNEXPECTED_CHARACTERS;
		break;
	}

	return (errn);
}


int exiappHandDecodeAttributeGenericValue(bitstream_t* stream, exi_state_t* state, uint16_t* qnameID, exi_value_t* val) {
	int16_t currentID;

	if (_qname.uri.id == 2 && _qname.localName.id == 1 ) {
		/* xsi:type --> QName type */
		errn = exiappHandDecodeAttributeXsiType(stream, state, val);
	} else {
		currentID = state->grammarStack[state->stackIndex];
		if (currentID >= 0) {
			/* if schema-informed value type according global attribute */
			switch(*qnameID) {

			default:
				val->type = EXI_DATATYPE_STRING;
				errn = decodeStringValue(stream, state, *qnameID, &val->str);
				break;
			}

		} else {
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, *qnameID, &val->str);
		}
	}

	return (errn);
}

int exiappHandDecodeAttribute(bitstream_t* stream, exi_state_t* state,
		uint16_t* qnameID, exi_value_t* val) {
	int16_t moveOnID = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE;

	switch(currEvent) {
	case EXI_EVENT_ATTRIBUTE:
	case EXI_EVENT_ATTRIBUTE_INVALID_VALUE:
		switch (currentID) {

		}

		if (errn == 0) {
			/* move on */
			state->grammarStack[state->stackIndex] = moveOnID;
		}
		break;
	case EXI_EVENT_ATTRIBUTE_GENERIC:
	case EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED:
		errn = _exiDecodeQName(stream, state, qnameID, &_qname);
		if (errn == 0) {
			/* learn attribute ? */
			errn = exi_appHand_LearnAttribute(state, _qname.uri.id,  _qname.localName.id);
			if (errn == 0) {
				/* decode attribute value */
				errn = exiappHandDecodeAttributeGenericValue(stream, state, qnameID, val);
			}
		}
		break;
	default:
		errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE;
		break;
	}

	return (errn);
}



int exiappHandDecodeAttributeXsiNil(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	errn = decodeBoolean(stream, &val->boolean);
	if (errn == 0 && val->boolean) {
		/* handle xsi:nil == true */
		 errn = exi_appHand_HandleXsiNilTrue(state);
	}
	return (errn);
}


int exiappHandDecodeAttributeXsiType(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {

	/* uri */
	errn =_exiDecodeNamespaceUri(stream, state, &_qname.uri);
	if (errn == 0) {
		/* localName */
		errn = _exiDecodeLocalName(stream, state, _qname.uri.id, &_qname.localName);
		if (errn == 0) {
			val->type = EXI_DATATYPE_QNAME;
			val->eqname.namespaceURI = _qname.uri.id;
			val->eqname.localPart = _qname.localName.id;

			/* handle xsi type cast */
			errn = exi_appHand_HandleXsiType(state, &val->eqname);
		}
	}

	return (errn);
}



#endif

