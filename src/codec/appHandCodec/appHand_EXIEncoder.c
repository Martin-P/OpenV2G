/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.6
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 ********************************************************************/



#ifndef EXI_appHand_ENCODER_C
#define EXI_appHand_ENCODER_C

#include "EXITypes.h"
#include "BitOutputStream.h"
#include "EncoderChannel.h"

#include "StringTable.h"
#include "appHand_NameTableEntries.h"
#include "MethodsBag.h"

#include "EXICoder.h"
#include "EXIHeaderEncoder.h"




/* local variables */
static uint32_t bits;
static int errn;

/* ==================================== */


int exiappHandEncodeListValue(bitstream_t* stream, exi_value_t* val, list_t lt) {

	switch(lt.type) {
	case EXI_DATATYPE_BINARY_BASE64:
	case EXI_DATATYPE_BINARY_HEX:
		errn = encodeBinary(stream, &val->binary);
		break;
	case EXI_DATATYPE_BOOLEAN:
		errn = encodeBoolean(stream, val->boolean);
		break;
	case EXI_DATATYPE_BOOLEAN_FACET:
		errn = encodeNBitUnsignedInteger(stream, 2, val->boolean ? 2 : 0);
		break;
	case EXI_DATATYPE_DECIMAL:
		errn = encodeDecimal(stream, &val->decimal);
		break;
	case EXI_DATATYPE_FLOAT:
		errn = encodeFloat(stream, &val->float_me);
		break;
	case EXI_DATATYPE_NBIT_UNSIGNED_INTEGER:
	case EXI_DATATYPE_UNSIGNED_INTEGER:
	case EXI_DATATYPE_INTEGER:
		switch(lt.intType) {
		/* (Signed) Integer */
		case EXI_UNSIGNED_INTEGER_8:
		case EXI_UNSIGNED_INTEGER_16:
		case EXI_UNSIGNED_INTEGER_32:
		case EXI_UNSIGNED_INTEGER_64:
			errn = encodeUnsignedInteger(stream, &val->integer);
			break;
		/* (Signed) Integer */
		case EXI_INTEGER_8:
		case EXI_INTEGER_16:
		case EXI_INTEGER_32:
		case EXI_INTEGER_64:
			errn = encodeInteger(stream, &val->integer);
			break;
		}
		break;
	case EXI_DATATYPE_DATETIME:
		errn = encodeDateTime(stream, &val->datetime);
		break;
	case EXI_DATATYPE_STRING:
		errn = encodeStringValue(stream, &val->string);
		break;
	default:
		return EXI_UNSUPPORTED_LIST_VALUE_TYPE;
	}

	return errn;
}



/* <0 ... Error, 1 .. Not-Found, 0.. Success */
static int _exiGet1stLevelEventCode(exi_state_t* state, exi_event_t eventType, uint16_t* resGrammarID) {
	/* retrieve current grammar-rule ID */
	uint16_t grammarID = state->grammarStack[ state->stackIndex ];

	switch(grammarID) {
	case DOCUMENT:
		switch(eventType) {
		case EXI_EVENT_START_DOCUMENT:
			*resGrammarID = 0;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case DOC_CONTENT:
		switch(eventType) {
		/* TODO other IDs */
		case EXI_EVENT_START_ELEMENT_GENERIC:
			*resGrammarID = 0;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case DOC_END:
		switch(eventType) {
		case EXI_EVENT_END_DOCUMENT:
			*resGrammarID = 0;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case UR_TYPE_GRAMMAR_0:
		switch(eventType) {
		case EXI_EVENT_ATTRIBUTE_GENERIC:
			*resGrammarID = 0;
			return 0;
		case EXI_EVENT_START_ELEMENT_GENERIC:
			*resGrammarID = 1;
			return 0;
		case EXI_EVENT_END_ELEMENT:
			*resGrammarID = 2;
			return 0;
		case EXI_EVENT_CHARACTERS_GENERIC:
			*resGrammarID = 3;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case UR_TYPE_GRAMMAR_1:
		switch(eventType) {
		case EXI_EVENT_START_ELEMENT_GENERIC:
			*resGrammarID = 0;
			return 0;
		case EXI_EVENT_END_ELEMENT:
			*resGrammarID = 1;
			return 0;
		case EXI_EVENT_CHARACTERS_GENERIC:
			*resGrammarID = 2;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	}

	return 1; /* not found */
}


static int _exiGetEventCodeLength(exi_state_t* state, uint16_t* eventCodeLength) {
	/* retrieve current grammar-rule ID */
	uint16_t grammarID = state->grammarStack[ state->stackIndex ];

	switch(grammarID) {
	/* TODO OTHER IDs */
	case DOCUMENT:
		*eventCodeLength = 0;
		return 0;
	case DOC_CONTENT:
		/* TODO other root elements */
		*eventCodeLength = IS_STRICT ? 0 : 1;
		return 0;
	case DOC_END:
		*eventCodeLength = IS_STRICT ? 0 : 1;
		return 0;
	case UR_TYPE_GRAMMAR_0:
		*eventCodeLength = IS_STRICT ? 4 : 5;
		return 0;
	case UR_TYPE_GRAMMAR_1:
		*eventCodeLength = IS_STRICT ? 3 : 4;
		return 0;
	}

	return EXI_ERROR_UNEXPECTED_GRAMMAR_ID;
}

static int _encodeNBitIntegerValue(bitstream_t* stream, integer_t* iv, uint16_t nbits, int32_t lowerBound) {
	int errn;
	uint32_t val;
	switch(iv->type) {
	/* Unsigned Integer */
	case EXI_UNSIGNED_INTEGER_8:
		val = iv->val.int8 - lowerBound;
		break;
	case EXI_UNSIGNED_INTEGER_16:
		val = iv->val.int16 - lowerBound;
		break;
	case EXI_UNSIGNED_INTEGER_32:
		val = iv->val.int32 - lowerBound;
		break;
	case EXI_UNSIGNED_INTEGER_64:
		val = iv->val.int64 - lowerBound;
		break;
	/* (Signed) Integer */
	case EXI_INTEGER_8:
		val = iv->val.uint8 - lowerBound;
		break;
	case EXI_INTEGER_16:
		val = iv->val.uint16 - lowerBound;
		break;
	case EXI_INTEGER_32:
		val = iv->val.uint32 - lowerBound;
		break;
	case EXI_INTEGER_64:
		val = iv->val.uint64 - lowerBound;
		break;
	}

	errn = encodeNBitUnsignedInteger(stream, nbits, val);
	return errn;
}

#define MAX_NUMBER_CHARACTERS 50
char nameCharacters [MAX_NUMBER_CHARACTERS];

/*
#define MAX_NUMBER_URI 1
#define MAX_NUMBER_LOCALNAMES 0
char * uris [MAX_NUMBER_URI];
exi_name_table_runtime_t nameTableRuntime = {MAX_NUMBER_URI, uris, 0};
*/

int exiappHandInitEncoder(bitstream_t* stream, exi_state_t* state, exi_name_table_runtime_t runtimeTable) {
	/* init grammar state */
	state->stackIndex = 0;
	state->grammarStack[0] = DOCUMENT;
	/* string tables */
	state->nameTablePrepopulated = exiappHandNameTablePrepopulated;
	state->nameTableRuntime = runtimeTable;
	/* encode header */
	return writeEXIHeader(stream);
}

int exiappHandEncodeStartDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 0 ) {
		/* move on */
		state->grammarStack[state->stackIndex] = 1;
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_START_DOCUMENT;
}

int exiappHandEncodeEndDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 2) {
		encodeFinish(stream);
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_END_DOCUMENT;
}

static int _exiEncodeNamespaceUriID(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable, uint16_t uriID) {
	int errn;
	uint16_t uriCodingLength;
	uint16_t uriSize;

	errn = exiGetUriSize(nameTable, runtimeTable, &uriSize);
	if (errn) {
		return errn;
	}
	/* URI Entries + 1 */
	errn = exiGetCodingLength(uriSize + 1, &uriCodingLength);
	if (errn) {
		return errn;
	}

	/* uri string value found */
	/* ==> value(i+1) is encoded as n-bit unsigned integer */
	errn = encodeNBitUnsignedInteger(stream, uriCodingLength, uriID+1);

	return errn;
}


#if EXI_DEBUG == EXI_DEBUG_ON
static int _exiEncodeNamespaceUri(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		char** uri, uint16_t* uriID) {
	int errn;
	uint16_t uriCodingLength;
	uint16_t uriSize;

	errn = exiGetUriSize(nameTable, runtimeTable, &uriSize);
	if (errn) {
		return errn;
	}
	/* URI Entries + 1 */
	errn = exiGetCodingLength(uriSize + 1, &uriCodingLength);
	if (errn) {
		return errn;
	}

	errn = exiGetUriID(nameTable, runtimeTable, *uri, uriID);
	if (errn < 0) {
		return errn;
	} else if (errn == 1) {
		/* uri string value was not found */
		/* ==> zero (0) as an n-nit unsigned integer */
		/* followed by uri encoded as string */
		errn = encodeNBitUnsignedInteger(stream, uriCodingLength, 0);
		if (errn) {
			return errn;
		}
		/* ASCII String */
		errn = encodeASCII(stream, *uri);
		if (errn) {
			return errn;
		}
		/* after encoding string value is added to table */
		/* in UCD Profile NOT */
		*uriID = uriSize;
	} else {
		/* uri string value found */
		/* ==> value(i+1) is encoded as n-bit unsigned integer */
		errn = encodeNBitUnsignedInteger(stream, uriCodingLength, *uriID + 1);
	}

	return errn;
}
#endif /*EXI_DEBUG*/


static int _exiEncodeLocalNameID(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		uint16_t uriID, uint16_t localNameID) {
	int errn;
	uint16_t localNameSize;
	uint16_t localNameCodingLength;

	/* string value found in local partition */
	/* ==> string value is represented as zero (0) encoded as an */
	errn = encodeUnsignedInteger32(stream, 0 );
	if (errn < 0) {
		return errn;
	}
	/* Unsigned Integer followed by an the compact identifier of the */
	/* string value as an n-bit unsigned integer n is log2 m and m is */
	/* the number of entries in the string table partition */
	errn = exiGetLocalNameSize(nameTable, runtimeTable, uriID, &localNameSize);
	if (errn < 0) {
		return errn;
	}
	errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
	if (errn) {
		return errn;
	}
	errn = encodeNBitUnsignedInteger(stream, localNameCodingLength, localNameID);
	return errn;

}


#if EXI_DEBUG == EXI_DEBUG_ON
static int _exiEncodeLocalName(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		char** localName,
		uint16_t uriID) {
	int errn;
	uint16_t localNameID;
	uint16_t localNameSize;
	uint16_t localNameCodingLength;
	uint32_t slen;

	/* look for localNameID */
	errn = exiGetLocalNameID(nameTable, runtimeTable, uriID, *localName, &localNameID);
	if (errn < 0) {
		return errn;
	}

	if (errn == 1) {
		/* string value was not found in local partition */
		/* ==> string literal is encoded as a String */
		/* with the length of the string incremented by one */
		slen = (uint32_t)strlen(*localName);
		errn = encodeUnsignedInteger32(stream, slen + 1 );
		if (errn >= 0) {
			errn = encodeASCIICharacters(stream, *localName, slen);
		}
	} else {
		/* string value found in local partition */
		/* ==> string value is represented as zero (0) encoded as an */
		errn = encodeUnsignedInteger32(stream, 0 );
		if (errn < 0) {
			return errn;
		}
		/* Unsigned Integer followed by an the compact identifier of the */
		/* string value as an n-bit unsigned integer n is log2 m and m is */
		/* the number of entries in the string table partition */
		errn = exiGetLocalNameSize(nameTable, runtimeTable, uriID, &localNameSize);
		if (errn < 0) {
			return errn;
		}
		errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
		if (errn) {
			return errn;
		}
		errn = encodeNBitUnsignedInteger(stream, localNameCodingLength, localNameID);
	}

	return errn;
}
#endif /*EXI_DEBUG*/


#if EXI_DEBUG == EXI_DEBUG_ON
static int _exiEncodeQName(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable,  exi_name_table_runtime_t* runtimeTable,
		char** uri, char** localName) {
	uint16_t uriID;
	/* uri */
	int errn =_exiEncodeNamespaceUri(stream, nameTable, runtimeTable, uri, &uriID);
	if (errn) {
		return errn;
	}
	/* localName */
	errn = _exiEncodeLocalName(stream, nameTable, runtimeTable, localName, uriID);
	if (errn) {
		return errn;
	}

	return 0 ;
}
#endif /*EXI_DEBUG*/


static int _exiEncodeStartElement(bitstream_t* stream, uint16_t nbits,
		uint32_t val, exi_state_t* state, eqname_t* se, uint16_t stackId,
		uint16_t newState) {
	/* event-code */
	int errn = encodeNBitUnsignedInteger(stream, nbits, val);
	if (errn) {
		return errn;
	}
	/* move on */
	state->grammarStack[state->stackIndex] = stackId;
	/* push element on stack */
	return exiPushStack(state, newState, se);
}

#if EXI_DEBUG == EXI_DEBUG_ON

static eqname_t eqnGeneric = {65535, 65535}; /* UNSIGNED_INT16_MAX */

static int _exiEncodeStartElementGeneric(bitstream_t* stream, uint16_t nbits,
		uint32_t val, exi_state_t* state, char** uri, char** localName, uint16_t stackId,
		uint16_t newState) {
	uint16_t uriID;
	/* event-code */
	int errn = encodeNBitUnsignedInteger(stream, nbits, val);
	if (errn) {
		return errn;
	}
	/* qualified name */
	errn = _exiEncodeNamespaceUri(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), uri, &uriID);
	if (errn) {
		return errn;
	}
	errn = _exiEncodeLocalName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), localName, uriID);
	if (errn) {
		return errn;
	}

	/* move on */
	state->grammarStack[state->stackIndex] = stackId;
	/* push element on stack */
	return exiPushStack(state, newState, &eqnGeneric);
}
#endif /*EXI_DEBUG*/

int exiappHandEncodeStartElement(bitstream_t* stream, exi_state_t* state, eqname_t* se) {
	switch (state->grammarStack[state->stackIndex]) {
		case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */ 
		if ( se->localPart == 6 && se->namespaceURI == 4  ) {
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 2, 3);
		}
		else if ( se->localPart == 7 && se->namespaceURI == 4 ) {
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes ) */
			return _exiEncodeStartElement(stream, 2, 1, state, se, 2, 43);
		}
		else {
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 2, 2, state, se, 2, 49);
		}
		break;
	case 3:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 4, 5);
		}
		break;
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 23, 5);
		}
		break;
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */ 
		if ( se->localPart == 2 && se->namespaceURI == 0  ) {
			/* SE( ProtocolNamespace ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 6, 7);
		}
		break;
	case 6:
		/* Element[START_ELEMENT(VersionNumberMajor)] */ 
		if ( se->localPart == 5 && se->namespaceURI == 0  ) {
			/* SE( VersionNumberMajor ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 11, 12);
		}
		break;
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */ 
		if ( se->localPart == 6 && se->namespaceURI == 0  ) {
			/* SE( VersionNumberMinor ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 14, 15);
		}
		break;
	case 14:
		/* Element[START_ELEMENT(SchemaID)] */ 
		if ( se->localPart == 4 && se->namespaceURI == 0  ) {
			/* SE( SchemaID ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 16, 17);
		}
		break;
	case 16:
		/* Element[START_ELEMENT(Priority)] */ 
		if ( se->localPart == 1 && se->namespaceURI == 0  ) {
			/* SE( Priority ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 19, 20);
		}
		break;
	case 22:
		/* Element[START_ELEMENT(ProtocolNamespace)] */ 
		if ( se->localPart == 2 && se->namespaceURI == 0  ) {
			/* SE( ProtocolNamespace ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 6, 7);
		}
		break;
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 24, 5);
		}
		break;
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 25, 5);
		}
		break;
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 26, 5);
		}
		break;
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 27, 5);
		}
		break;
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 28, 5);
		}
		break;
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 29, 5);
		}
		break;
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 30, 5);
		}
		break;
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 31, 5);
		}
		break;
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 32, 5);
		}
		break;
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 33, 5);
		}
		break;
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 34, 5);
		}
		break;
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 35, 5);
		}
		break;
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 36, 5);
		}
		break;
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 37, 5);
		}
		break;
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 38, 5);
		}
		break;
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 39, 5);
		}
		break;
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 40, 5);
		}
		break;
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 41, 5);
		}
		break;
	case 42:
		/* Element[START_ELEMENT(AppProtocol)] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 4, 5);
		}
		break;
	case 43:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */ 
		if ( se->localPart == 3 && se->namespaceURI == 0  ) {
			/* SE( ResponseCode ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 44, 45);
		}
		break;
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */ 
		if ( se->localPart == 4 && se->namespaceURI == 0  ) {
			/* SE( SchemaID ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 47, 17);
		}
		break;
	case 48:
		/* Element[START_ELEMENT(ResponseCode)] */ 
		if ( se->localPart == 3 && se->namespaceURI == 0  ) {
			/* SE( ResponseCode ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 44, 45);
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 3, 1, state, se, 50, 49);
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 50, 49);
		}
		break;
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 3, 1, state, se, 76, 49);
		}
		break;
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 76, 49);
		}
		break;

	default:
		return EXI_ERROR_UNEXPECTED_START_ELEMENT;
	}

	return EXI_ERROR_UNEXPECTED_START_ELEMENT;
}

/* Qualified Name unknown!! */
#if EXI_DEBUG == EXI_DEBUG_ON
static int exiEncodeStartElementGenericUnknown(bitstream_t* stream, exi_state_t* state,
		char** uri, char** localName) {
	uint16_t grammarID;
	uint16_t eventCodeLength;

	int errn = _exiGet1stLevelEventCode(state, EXI_EVENT_START_ELEMENT_GENERIC, &grammarID);
	if (errn < 0) {
		return errn;
	} else if (errn == 1) {
		/* not found --> try undeclared SE */
		errn = _exiGet1stLevelEventCode(state, EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED, &grammarID);
		if (errn < 0) {
			return errn;
		} else if (errn == 1) {
			/* Should never happen except in STRICT mode */
			return EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
		} else {
			/* found START_ELEMENT_GENERIC_UNDECLARED */
			errn = _exiGetEventCodeLength(state, &eventCodeLength);
			if (errn < 0) {
				return errn;
			} else {
				/* encode event code*/
				errn = encodeNBitUnsignedInteger(stream, eventCodeLength, grammarID);
				if (errn) {
					return errn;
				}
			}
		}
	} else {
		/* found START_ELEMENT_GENERIC */
		errn = _exiGetEventCodeLength(state, &eventCodeLength);
		if (errn < 0) {
			return errn;
		} else {
			/* encode event code*/
			errn = encodeNBitUnsignedInteger(stream, eventCodeLength, grammarID);
			if (errn) {
				return errn;
			}
		}
	}

	/* encode qualified name */
	errn = _exiEncodeQName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), uri, localName);
	if (errn) {
		return errn;
	}

	/* learn event, not in UCD Profile */

	/* move on */
	/* push element on stack */

	switch (state->grammarStack[state->stackIndex]) {
	/* $EXI_ENCODE_START_ELEMENT_GENERIC$ */
	case DOC_CONTENT:
		/* move on to DocEnd */
		state->grammarStack[state->stackIndex] = DOC_END;
		/* push new ur-type grammar on stack */
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	case UR_TYPE_GRAMMAR_0:
		/* move on to UR_TYPE_GRAMMAR_1 */
		state->grammarStack[state->stackIndex] = UR_TYPE_GRAMMAR_1;
		/* push new ur-type grammar on stack */
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	case UR_TYPE_GRAMMAR_1:
		/* remain in UR_TYPE_GRAMMAR_1 */
		/* push new ur-type grammar on stack */
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	default:
		return EXI_ERROR_UNEXPECTED_START_ELEMENT_GENERIC;
	}



	return 0;
}
#endif /*EXI_DEBUG*/


/* Look first for qualified name */
int exiappHandEncodeStartElementGeneric(bitstream_t* stream, exi_state_t* state,
		string_ascii_t* namespaceURI , string_ascii_t* localName) {
	int errn = -1;

#if EXI_DEBUG == EXI_DEBUG_ON
	eqname_t se;
	/* uri */
	errn = exiGetUriID(&(state->nameTablePrepopulated), &(state->nameTableRuntime), namespaceURI->chars, &se.namespaceURI);
	if (errn == -1) {
		return errn;
	} else if (errn == 1) {
		/* No URI (and localNameID) found  */
		exiEncodeStartElementGenericUnknown(stream, state, &(namespaceURI->chars), &(localName->chars));
	} else {
		/* localName */
		errn = exiGetLocalNameID(&(state->nameTablePrepopulated), &(state->nameTableRuntime), se.namespaceURI, localName->chars, &se.localPart);
		if (errn == -1) {
			return errn;
		} else if (errn == 1) {
			/* No localName found, use generic StartElement(*) method */
			exiEncodeStartElementGenericUnknown(stream, state, &(namespaceURI->chars), &(localName->chars));
		} else {
			/* Uri&LocalName found, use "efficient" StartElement method */
			return exiappHandEncodeStartElement(stream, state, &se);
		}
	}
#endif /*EXI_DEBUG*/

	return errn;
}

static int _exiEncodeEndElementUndeclared(bitstream_t* stream, exi_state_t* state) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
	case 9:
		/* Element[] */
		/* 1st level and 2nd level event code */
		encodeNBitUnsignedInteger(stream, 0, 0);
		encodeNBitUnsignedInteger(stream, 2, 0);
		return 0;
	case 70:
		/* Element[CHARACTERS[STRING]] */
	case 124:
		/* Element[CHARACTERS[STRING]] */
	case 139:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 46:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 22:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 86:
		/* Element[CHARACTERS[DATETIME]] */
	case 120:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 100:
		/* Element[CHARACTERS[DATETIME]] */
	case 54:
		/* Element[CHARACTERS[STRING]] */
	case 68:
		/* Element[CHARACTERS[STRING]] */
	case 72:
		/* Element[CHARACTERS[STRING]] */
	case 94:
		/* Element[CHARACTERS[STRING]] */
	case 21:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 78:
		/* Element[CHARACTERS[STRING]] */
	case 134:
		/* Element[CHARACTERS[STRING]] */
	case 141:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 52:
		/* Element[CHARACTERS[LIST]] */
	case 102:
		/* Element[CHARACTERS[DATETIME]] */
	case 96:
		/* Element[CHARACTERS[FLOAT]] */
	case 60:
		/* Element[CHARACTERS[LIST]] */
	case 82:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 88:
		/* Element[CHARACTERS[DATETIME]] */
	case 116:
		/* Element[CHARACTERS[INTEGER]] */
	case 98:
		/* Element[CHARACTERS[DATETIME]] */
	case 128:
		/* Element[CHARACTERS[INTEGER]] */
	case 13:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 90:
		/* Element[CHARACTERS[DECIMAL]] */
	case 92:
		/* Element[CHARACTERS[FLOAT]] */
	case 42:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 143:
		/* Element[CHARACTERS[STRING]] */
	case 110:
		/* Element[CHARACTERS[INTEGER]] */
	case 66:
		/* Element[CHARACTERS[LIST]] */
	case 112:
		/* Element[CHARACTERS[INTEGER]] */
	case 58:
		/* Element[CHARACTERS[STRING]] */
	case 14:
		/* Element[START_ELEMENT(SchemaID)] */
	case 122:
		/* Element[CHARACTERS[INTEGER]] */
	case 16:
		/* Element[START_ELEMENT(Priority)] */
	case 104:
		/* Element[CHARACTERS[DATETIME]] */
	case 132:
		/* Element[CHARACTERS[DATETIME]] */
	case 114:
		/* Element[CHARACTERS[STRING]] */
	case 108:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 84:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 106:
		/* Element[CHARACTERS[DATETIME]] */
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 74:
		/* Element[CHARACTERS[STRING]] */
	case 6:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 64:
		/* Element[CHARACTERS[STRING]] */
	case 62:
		/* Element[CHARACTERS[STRING]] */
	case 136:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 130:
		/* Element[CHARACTERS[STRING]] */
	case 126:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 118:
		/* Element[CHARACTERS[INTEGER]] */
	case 48:
		/* Element[START_ELEMENT(ResponseCode)] */
	case 10:
		/* Element[CHARACTERS[STRING]] */
	case 80:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 56:
		/* Element[CHARACTERS[STRING]] */
	case 18:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		/* 1st level and 2nd level event code */
		encodeNBitUnsignedInteger(stream, 1, 1);
		encodeNBitUnsignedInteger(stream, 2, 0);
		return 0;
	case 109:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 113:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 12:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 140:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 57:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 97:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 135:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
	case 91:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 111:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 103:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 7:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 133:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 123:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 61:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 99:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 107:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 73:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 59:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 63:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 115:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 101:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 71:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 77:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 121:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 17:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 83:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 117:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 3:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 87:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 67:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 93:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 53:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 137:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 81:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 79:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 119:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 51:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 105:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 69:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 45:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 65:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 129:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 55:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 43:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 20:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 85:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 125:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 138:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 15:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 131:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 89:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 127:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 95:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
		/* 1st level and 2nd level event code */
		encodeNBitUnsignedInteger(stream, 1, 1);
		encodeNBitUnsignedInteger(stream, 3, 0);
		return 0;

	}
	return EXI_ERROR_UNEXPECTED_END_ELEMENT;
}

int exiappHandEncodeEndElement(bitstream_t* stream, exi_state_t* state) {
	int errn = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = encodeNBitUnsignedInteger(stream, 3, 2);
		break;
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = encodeNBitUnsignedInteger(stream, 2, 1);
		break;
	case 8:
		/* Element[END_ELEMENT] */
	case 19:
		/* Element[END_ELEMENT] */
	case 41:
		/* Element[END_ELEMENT] */
	case 47:
		/* Element[END_ELEMENT] */
		errn = encodeNBitUnsignedInteger(stream, 1, 0);
		break;

	default:
		if (currentID < 0) {
			/* runtime grammars */
			return -1;
		} else {
			errn = _exiEncodeEndElementUndeclared(stream, state);
			if (errn < 0) {
				return errn;
			}
		}
		/* return EXI_ERROR_UNEXPECTED_END_ELEMENT; */
	}

	if (errn < 0) {
		return errn;
	}

	/* pop item */
	return exiPopStack(state);
}

static int _exiValueToString(exi_value_t* val) {
	if (val->type == EXI_DATATYPE_STRING) {
		return 0;
	} else {
		/* TODO convert typed value to string */
		return EXI_ERROR_CONVERSION_TYPE_TO_STRING;
	}
}

int exiappHandEncodeCharacters(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int errn;
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
		case 91:
	case 95:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
		if (val->type == EXI_DATATYPE_FLOAT) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeFloat(stream, &val->float_me);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			encodeNBitUnsignedInteger(stream, 3, 3);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 50;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 3, 4);
			encodeNBitUnsignedInteger(stream, 3, 5);
		}
		break;
	case 109:
	case 111:
	case 115:
	case 117:
	case 121:
	case 127:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
		if (val->type == EXI_DATATYPE_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 89:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
		if (val->type == EXI_DATATYPE_DECIMAL) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDecimal(stream, &val->decimal);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 107:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
		if (val->type == EXI_DATATYPE_BINARY_HEX) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 82:
		/* Element[CHARACTERS[BOOLEAN]] */
		if (val->type == EXI_DATATYPE_BOOLEAN) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBoolean(stream, val->boolean);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 13:
	case 120:
	case 126:
	case 139:
	case 141:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 12:
	case 15:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 10:
	case 54:
	case 56:
	case 58:
	case 62:
	case 64:
	case 68:
	case 70:
	case 72:
	case 74:
	case 78:
	case 94:
	case 114:
	case 124:
	case 130:
	case 134:
	case 143:
		/* Element[CHARACTERS[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 110:
	case 112:
	case 116:
	case 118:
	case 122:
	case 128:
		/* Element[CHARACTERS[INTEGER]] */
		if (val->type == EXI_DATATYPE_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 45:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
		if (val->type == EXI_DATATYPE_ENUMERATION) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeNBitUnsignedInteger(stream, 2, val->enumeration);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 108:
		/* Element[CHARACTERS[BINARY_HEX]] */
		if (val->type == EXI_DATATYPE_BINARY_HEX) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 86:
	case 88:
	case 98:
	case 100:
	case 102:
	case 104:
	case 106:
	case 132:
		/* Element[CHARACTERS[DATETIME]] */
		if (val->type == EXI_DATATYPE_DATETIME) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDateTime(stream, &val->datetime);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 92:
	case 96:
		/* Element[CHARACTERS[FLOAT]] */
		if (val->type == EXI_DATATYPE_FLOAT) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeFloat(stream, &val->float_me);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 90:
		/* Element[CHARACTERS[DECIMAL]] */
		if (val->type == EXI_DATATYPE_DECIMAL) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDecimal(stream, &val->decimal);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 20:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 5, 1);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 85:
	case 87:
	case 97:
	case 99:
	case 101:
	case 103:
	case 105:
	case 131:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
		if (val->type == EXI_DATATYPE_DATETIME) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDateTime(stream, &val->datetime);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			encodeNBitUnsignedInteger(stream, 3, 3);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 76;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 3, 4);
			encodeNBitUnsignedInteger(stream, 3, 5);
		}
		break;
	case 21:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 5, 1);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			encodeNBitUnsignedInteger(stream, 2, 2);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 76;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 2, 3);
			encodeNBitUnsignedInteger(stream, 1, 1);
		}
		break;
	case 46:
		/* Element[CHARACTERS[ENUMERATION]] */
		if (val->type == EXI_DATATYPE_ENUMERATION) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeNBitUnsignedInteger(stream, 2, val->enumeration);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 81:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
		if (val->type == EXI_DATATYPE_BOOLEAN) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBoolean(stream, val->boolean);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 79:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
		if (val->type == EXI_DATATYPE_BINARY_BASE64) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 18:
	case 136:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, 0);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 7:
	case 53:
	case 55:
	case 57:
	case 61:
	case 63:
	case 67:
	case 69:
	case 71:
	case 73:
	case 77:
	case 93:
	case 113:
	case 123:
	case 129:
	case 133:
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 80:
		/* Element[CHARACTERS[BINARY_BASE64]] */
		if (val->type == EXI_DATATYPE_BINARY_BASE64) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 84:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, -128);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			encodeNBitUnsignedInteger(stream, 2, 2);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 50;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 2, 3);
			encodeNBitUnsignedInteger(stream, 1, 1);
		}
		break;
	case 17:
	case 135:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, 0);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 119:
	case 125:
	case 137:
	case 138:
	case 140:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 52:
	case 60:
	case 66:
		/* Element[CHARACTERS[LIST]] */
		if (val->type == EXI_DATATYPE_LIST) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger32(stream, val->list.len);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 51:
	case 59:
	case 65:
		/* FirstStartTag[CHARACTERS[LIST]] */
		if (val->type == EXI_DATATYPE_LIST) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger32(stream, val->list.len);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 83:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, -128);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;

	default:
		return EXI_ERROR_UNEXPECTED_CHARACTERS;
	}

	if (currentID < 0) {
		/* runtime rules */
		return -1;
	} else {
		/* convert typed value to string for EXI encoding */
		errn = _exiValueToString(val);
		if (errn) {
			return errn;
		}
		/* undeclared CH event code already written */
		/* encode deviant value */
		errn = encodeStringValue(stream, &val->string);
		if (errn) {
			return errn;
		}

		/* move to element content rule if not already */
		errn = exiMoveToElementContentRule( state);
	}

	return errn;
}


int exiappHandEncodeAttribute(bitstream_t* stream, exi_state_t* state, eqname_t* at,
		exi_value_t* val) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
	
	}

	/* no expected attribute */
	if (currentID < 0) {
		/* runtime element */
		return -1;
	} else {
		return +1;
	}

	/* return EXI_ERROR_UNEXPECTED_ATTRIBUTE; */
}

#if EXI_DEBUG == EXI_DEBUG_ON
static int exiEncodeAttribute2(bitstream_t* stream, exi_state_t* state, qname_t* at,
		exi_value_t* val) {
	int errn;
	eqname_t eat;

	/* attribute generic undeclared */
	uint16_t codeLength1, codeLength2;
	uint32_t ec1, ec2;

	errn = exiGetUriID(&state->nameTablePrepopulated,  &state->nameTableRuntime, at->namespaceURI.chars, &eat.namespaceURI);
	if (errn < 0) {
		return errn;
	} else if (errn > 0) {
		/* uri not found*/
	} else {
		/* uri found, try to find localname id */
		errn = exiGetLocalNameID(&state->nameTablePrepopulated,  &state->nameTableRuntime, eat.namespaceURI,
				at->localName.chars, &eat.localPart);
		if (errn < 0) {
			return errn;
		} else if (errn > 0) {
			/* local-name not found*/
		} else {
			/* found uri and local-name */
			errn = exiappHandEncodeAttribute(stream, state, &eat, val);
			if (errn < 0) {
				return errn;
			}
			if (errn == 0) {
				return errn;
			}

		}
	}


	/* event codes */
	encodeNBitUnsignedInteger(stream, codeLength1, ec1);
	encodeNBitUnsignedInteger(stream, codeLength2, ec2);

	/* qname */
	/*
	errn = _exiEncodeQName(stream, state->nameTablePrepopulated,  state->nameTableRuntime,
			char** uri, char** localName);
	QName qname = qnameDatatype.encodeQName(uri, localName, null, channel);
	*/
	/* content as string */
	/*
	typeEncoder.isValid(BuiltIn.DEFAULT_DATATYPE, value);
	typeEncoder.writeValue(qname, channel);
	*/
	return -1;

}
#endif /*EXI_DEBUG*/

int exiappHandEncodeAttributeXsiNil(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {

	switch (state->grammarStack[state->stackIndex]) {

	}

	if (errn < 0) {
		return errn;
	}

	errn = encodeBoolean(stream, val->boolean);
	if (errn >= 0 && val->boolean) {
		/* handle xsi:nil == true */
		 errn = exiHandleXsiNilTrue(state);
	}
	return errn;
}

int exiappHandEncodeAttributeXsiType(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	/* encode xsi:type event code */
	switch (state->grammarStack[state->stackIndex]) {
	case 12:
		errn = encodeNBitUnsignedInteger(stream, 1, 1);
		errn = encodeNBitUnsignedInteger(stream, 3, 1);
		break;
	case 15:
		errn = encodeNBitUnsignedInteger(stream, 1, 1);
		errn = encodeNBitUnsignedInteger(stream, 3, 1);
		break;

	default:
		return EXI_ERROR_UNEXPECTED_ATTRIBUTE_XSI_TYPE;
	}
	if (errn < 0) {
		return errn;
	}

	/* encode qname */
	errn = _exiEncodeNamespaceUriID(stream, &state->nameTablePrepopulated, &state->nameTableRuntime, val->eqname.namespaceURI);
	if (errn < 0) {
		return errn;
	}
	errn = _exiEncodeLocalNameID(stream, &state->nameTablePrepopulated, &state->nameTableRuntime, val->eqname.namespaceURI, val->eqname.localPart);
	if (errn < 0) {
		return errn;
	}

	/* handle xsi type cast */
	errn = exiHandleXsiType(state, &val->eqname);

	return errn;
}

#endif

