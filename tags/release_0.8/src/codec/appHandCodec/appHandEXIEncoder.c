/*
 * Copyright (C) 2007-2013 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.8
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer.com</p>
 * <p>Schema: input/appHandshake/V2G_CI_AppProtocol.xsd</p>
 *
 *
 ********************************************************************/



#ifndef EXI_appHand_ENCODER_C
#define EXI_appHand_ENCODER_C

#include "EXITypes.h"
#include "EXIOptions.h"
#include "BitOutputStream.h"
#include "EncoderChannel.h"

#include "StringNameTable.h"
#include "appHandNameTableEntries.h"
#include "MethodsBag.h"

#include "EXIOptions.h"

#include "appHandEXICoder.h"
#include "EXIHeaderEncoder.h"
#include "ErrorCodes.h"
#include "appHandQNames.h"
#include "appHandQNameDefines.h"




/* local variables */
static uint32_t bits;
static int errn;

/* ==================================== */

static int _encodeNBitIntegerValue(bitstream_t* stream, exi_integer_t* iv, uint16_t nbits, int32_t lowerBound) {
	uint32_t val;
	errn = 0;
	switch(iv->type) {
	/* Unsigned Integer */
	case EXI_UNSIGNED_INTEGER_8:
		val = (uint32_t)(iv->val.int8 - lowerBound);
		break;
	case EXI_UNSIGNED_INTEGER_16:
		val = (uint32_t)(iv->val.int16 - lowerBound);
		break;
	case EXI_UNSIGNED_INTEGER_32:
		val = (uint32_t)(iv->val.int32 - lowerBound);
		break;
	case EXI_UNSIGNED_INTEGER_64:
		val = (uint32_t)(iv->val.int64 - lowerBound);
		break;
	/* (Signed) Integer */
	case EXI_INTEGER_8:
		val = (uint32_t)(iv->val.uint8 - lowerBound);
		break;
	case EXI_INTEGER_16:
		val = (uint32_t)(iv->val.uint16 - lowerBound);
		break;
	case EXI_INTEGER_32:
		val = (uint32_t)(iv->val.uint32 - (int64_t)lowerBound);
		break;
	case EXI_INTEGER_64:
		val = (uint32_t)((int64_t)iv->val.uint64 - (int64_t)lowerBound);
		break;
	default:
		errn = (EXI_UNSUPPORTED_INTEGER_VALUE_TYPE);
		break;
	}

	if(errn == 0) {
		errn = encodeNBitUnsignedInteger(stream, nbits, val);
	}

	return (errn);
}


static int _exiEncodeNamespaceUriHit(bitstream_t* stream, exi_state_t* state, uint16_t uriID) {
	uint16_t uriCodingLength;
	uint16_t uriSize;

	errn = exiGetUriSize(&state->nameTablePrepopulated, &state->nameTableRuntime, &uriSize);
	if (errn == 0) {
		/* URI Entries + 1 */
		errn = exiGetCodingLength( (uint16_t)(uriSize + 1), &uriCodingLength);
		if (errn == 0) {
			/* uri string value found */
			/* ==> value(i+1) is encoded as n-bit unsigned integer */
			errn = encodeNBitUnsignedInteger(stream, uriCodingLength, (uint32_t)(uriID+1));
		}
	}

	return errn;
}


static int _exiEncodeLocalNameHit(bitstream_t* stream, exi_state_t* state,
		uint16_t uriID, uint16_t localNameID) {
	uint16_t localNameSize;
	uint16_t localNameCodingLength;

	/* string value found in local partition */
	/* ==> string value is represented as zero (0) encoded as an */
	errn = encodeUnsignedInteger32(stream, 0 );
	if (errn == 0) {
		/* Unsigned Integer followed by an the compact identifier of the */
		/* string value as an n-bit unsigned integer n is log2 m and m is */
		/* the number of entries in the string table partition */
		errn = exiGetLocalNameSize(&state->nameTablePrepopulated, &state->nameTableRuntime, uriID, &localNameSize);
		if (errn == 0) {
			errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
			if (errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, localNameCodingLength, localNameID);
			}
		}
	}

	return (errn);
}


static int _encodeAttributeXsiTypeContent(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {

	/* encode qname */
	errn = _exiEncodeNamespaceUriHit(stream, state, val->eqname.namespaceURI);
	if (errn == 0) {
		errn = _exiEncodeLocalNameHit(stream, state, val->eqname.namespaceURI, val->eqname.localPart);
		if (errn == 0) {
			/* handle xsi type cast */
			errn = exi_appHand_HandleXsiType(state, &val->eqname);
		}
	}

	return (errn);
}


static int _exiEncodeStartElement(bitstream_t* stream, uint16_t nbits,
		uint32_t val, exi_state_t* state, uint16_t qnameID, int16_t stackId,
		int16_t newState) {
	/* event-code */
	errn = encodeNBitUnsignedInteger(stream, nbits, val);
	if (errn == 0) {
		/* move on */
		state->grammarStack[state->stackIndex] = stackId;
		/* push element on stack */
		errn = (exi_appHand_PushStack(state, newState, qnameID));
	}

	return (errn);
}


static int _encode2ndLevelAttribute(bitstream_t* stream, exi_state_t* state, uint16_t qnameID,
		exi_value_t* val) {
	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;
}


int exiappHandEncodeListValue(bitstream_t* stream, exi_state_t* state, uint16_t qnameID, exi_value_t* val, exi_list_t lt) {

	switch(lt.type) {
	case EXI_DATATYPE_BINARY_BASE64:
	case EXI_DATATYPE_BINARY_HEX:
		errn = encodeBinary(stream, &val->binary);
		break;
	case EXI_DATATYPE_BOOLEAN:
		errn = encodeBoolean(stream, val->boolean);
		break;
	case EXI_DATATYPE_BOOLEAN_FACET:
		errn = encodeNBitUnsignedInteger(stream, 2, val->boolean ? 2 : 0);
		break;
	case EXI_DATATYPE_DECIMAL:
		errn = encodeDecimal(stream, &val->decimal);
		break;
	case EXI_DATATYPE_FLOAT:
		errn = encodeFloat(stream, &val->float_me);
		break;
	case EXI_DATATYPE_NBIT_UNSIGNED_INTEGER:
		errn = EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		break;
	case EXI_DATATYPE_UNSIGNED_INTEGER:
		errn = encodeUnsignedInteger(stream, &val->integer);
		break;
	case EXI_DATATYPE_INTEGER:
		errn = encodeInteger(stream, &val->integer);
		break;
	case EXI_DATATYPE_DATETIME:
		errn = encodeDateTime(stream, &val->datetime);
		break;
	case EXI_DATATYPE_STRING:
		errn = encodeStringValue(stream, state, qnameID, &val->str);
		break;
	default:
		errn = EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		break;
	}

	return (errn);
}


#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandEncodeStartDocument(bitstream_t* stream, exi_state_t* state) {
	errn = 0;
	switch(state->grammarStack[state->stackIndex]) {
	case 0:
		/* move on */
		state->grammarStack[state->stackIndex] = 1;
		break;
	case 45:
		/* move on */
		state->grammarStack[state->stackIndex] = 46;
		break;

	default:
		errn =(EXI_ERROR_UNEXPECTED_START_DOCUMENT);
		break;
	}
	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */


#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandEncodeEndDocument(bitstream_t* stream, exi_state_t* state) {
	switch(state->grammarStack[state->stackIndex]) {
	case 39:
		errn = encodeFinish(stream);
		break;
	case 46:
		errn = encodeFinish(stream);
		break;

	default:
		errn =(EXI_ERROR_UNEXPECTED_END_DOCUMENT);
		break;
	}
	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */


int exiappHandInitEncoder(bitstream_t* stream, exi_state_t* state,
		exi_name_table_runtime_t runtimeTable, exi_value_table_t stringTable) {
#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0
	int i;
#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */
	/* init grammar state */
	state->stackIndex = 0;
	state->grammarStack[0] = DOCUMENT;
	/* name tables */
	state->nameTablePrepopulated = exiappHandNameTablePrepopulated;
	state->nameTableRuntime = runtimeTable;
	/* next qname ID */
	state->nextQNameID = EXI_appHandNUMBER_OF_PREPOPULATED_QNAMES;
	/* string tables */
	state->stringTable = stringTable;
	state->stringTable.numberOfGlobalStrings = 0;
#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0
	for(i=0; i<(state->stringTable.sizeLocalStrings); i++) {
		state->stringTable.numberOfLocalStrings[i] = 0;
	}
#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */

	/* runtime grammars */
	state->numberOfRuntimeGrammars = 0;

	/* Avoid warning: Unused declaration of variable 'name' */
	bits = 0;

	/* encode header */
	return (writeEXIHeader(stream));
}



int exiappHandEncodeStartElement(bitstream_t* stream, exi_state_t* state, uint16_t qnameID) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;

	switch (currentID) {
	case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */ 
		switch(qnameID) {
		case 65:
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 39, 2);
			break;
		case 66:
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes ) */
			errn = _exiEncodeStartElement(stream, 2, 1, state, qnameID, 39, 40);
			break;
		}
		break;
	case 2:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 19, 3);
			break;
		}
		break;
	case 3:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */ 
		switch(qnameID) {
		case 2:
			/* SE( ProtocolNamespace ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 8, 4);
			break;
		}
		break;
	case 8:
		/* Element[START_ELEMENT(VersionNumberMajor)] */ 
		switch(qnameID) {
		case 5:
			/* SE( VersionNumberMajor ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 11, 9);
			break;
		}
		break;
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */ 
		switch(qnameID) {
		case 6:
			/* SE( VersionNumberMinor ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 12, 9);
			break;
		}
		break;
	case 12:
		/* Element[START_ELEMENT(SchemaID)] */ 
		switch(qnameID) {
		case 4:
			/* SE( SchemaID ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 15, 13);
			break;
		}
		break;
	case 15:
		/* Element[START_ELEMENT(Priority)] */ 
		switch(qnameID) {
		case 1:
			/* SE( Priority ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 5, 16);
			break;
		}
		break;
	case 18:
		/* Element[START_ELEMENT(ProtocolNamespace)] */ 
		switch(qnameID) {
		case 2:
			/* SE( ProtocolNamespace ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 8, 4);
			break;
		}
		break;
	case 19:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 20, 3);
			break;
		}
		break;
	case 20:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 21, 3);
			break;
		}
		break;
	case 21:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 22, 3);
			break;
		}
		break;
	case 22:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 23, 3);
			break;
		}
		break;
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 24, 3);
			break;
		}
		break;
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 25, 3);
			break;
		}
		break;
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 26, 3);
			break;
		}
		break;
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 27, 3);
			break;
		}
		break;
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 28, 3);
			break;
		}
		break;
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 29, 3);
			break;
		}
		break;
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 30, 3);
			break;
		}
		break;
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 31, 3);
			break;
		}
		break;
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 32, 3);
			break;
		}
		break;
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 33, 3);
			break;
		}
		break;
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 34, 3);
			break;
		}
		break;
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 35, 3);
			break;
		}
		break;
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 36, 3);
			break;
		}
		break;
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 37, 3);
			break;
		}
		break;
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 5, 3);
			break;
		}
		break;
	case 38:
		/* Element[START_ELEMENT(AppProtocol)] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 19, 3);
			break;
		}
		break;
	case 40:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */ 
		switch(qnameID) {
		case 3:
			/* SE( ResponseCode ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 43, 41);
			break;
		}
		break;
	case 43:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */ 
		switch(qnameID) {
		case 4:
			/* SE( SchemaID ) */
			errn = _exiEncodeStartElement(stream, 2, 0, state, qnameID, 5, 13);
			break;
		}
		break;
	case 44:
		/* Element[START_ELEMENT(ResponseCode)] */ 
		switch(qnameID) {
		case 3:
			/* SE( ResponseCode ) */
			errn = _exiEncodeStartElement(stream, 1, 0, state, qnameID, 43, 41);
			break;
		}
		break;
	case 46:
		/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */ 
		switch(qnameID) {
		case 0:
			/* SE( AppProtocol ) */
			errn = _exiEncodeStartElement(stream, 4, 0, state, qnameID, 46, 3);
			break;
		case 1:
			/* SE( Priority ) */
			errn = _exiEncodeStartElement(stream, 4, 1, state, qnameID, 46, 16);
			break;
		case 2:
			/* SE( ProtocolNamespace ) */
			errn = _exiEncodeStartElement(stream, 4, 2, state, qnameID, 46, 4);
			break;
		case 3:
			/* SE( ResponseCode ) */
			errn = _exiEncodeStartElement(stream, 4, 3, state, qnameID, 46, 41);
			break;
		case 4:
			/* SE( SchemaID ) */
			errn = _exiEncodeStartElement(stream, 4, 4, state, qnameID, 46, 13);
			break;
		case 5:
			/* SE( VersionNumberMajor ) */
			errn = _exiEncodeStartElement(stream, 4, 5, state, qnameID, 46, 9);
			break;
		case 6:
			/* SE( VersionNumberMinor ) */
			errn = _exiEncodeStartElement(stream, 4, 6, state, qnameID, 46, 9);
			break;
		case 65:
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq ) */
			errn = _exiEncodeStartElement(stream, 4, 7, state, qnameID, 46, 2);
			break;
		case 66:
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes ) */
			errn = _exiEncodeStartElement(stream, 4, 8, state, qnameID, 46, 40);
			break;
		}
		break;

	default:
		/* element qname not expected */
		return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;
	}

	return (errn);
}



int exiappHandEncodeStartElementNS(bitstream_t* stream,
		exi_state_t* state, uint16_t namespaceUriID,
		exi_string_ucs_t* localName) {
	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;
}


int exiappHandEncodeStartElementGeneric(bitstream_t* stream,
		exi_state_t* state, exi_string_ucs_t* namespaceUri,
		exi_string_ucs_t* localName) {

	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;

	errn = EXI_ERROR_UNEXPECTED_START_ELEMENT_GENERIC;

	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;
	return (errn);
}



int exiappHandEncodeEndElement(bitstream_t* stream, exi_state_t* state) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = encodeNBitUnsignedInteger(stream, 3, 2);
		break;
	case 19:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 20:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 21:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 22:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 43:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = encodeNBitUnsignedInteger(stream, 2, 1);
		break;
	case 5:
		/* Element[END_ELEMENT] */
		errn = encodeNBitUnsignedInteger(stream, 1, 0);
		break;

	default:
		return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;
	}

	if (errn == 0) {
		/* pop item */
		errn = exi_appHand_PopStack(state);
	}

	return (errn);
}



int exiappHandEncodeCharacters(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int16_t moveOnID = 0;
	int deviantChars = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];

	errn = EXI_ERROR_UNEXPECTED_CHARACTERS;

	switch (currentID) {
	case 48:
		/* Element[CHARACTERS[LIST]] */
		if (val->type == EXI_DATATYPE_LIST) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeUnsignedInteger32(stream, val->list.len);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 17:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = _encodeNBitIntegerValue(stream, &val->integer, 5, 1);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 63:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
		if (val->type == EXI_DATATYPE_FLOAT) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeFloat(stream, &val->float_me);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 56:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = _encodeNBitIntegerValue(stream, &val->integer, 8, -128);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 57:
	case 59:
	case 65:
	case 67:
	case 69:
	case 71:
	case 73:
	case 80:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
		if (val->type == EXI_DATATYPE_DATETIME) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeDateTime(stream, &val->datetime);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 75:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
		if (val->type == EXI_DATATYPE_BINARY_HEX) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeBinary(stream, &val->binary);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 41:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
		if (val->type == EXI_DATATYPE_ENUMERATION) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, val->enumeration);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 55:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = _encodeNBitIntegerValue(stream, &val->integer, 8, -128);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 78:
		/* Element[CHARACTERS[INTEGER]] */
		if (val->type == EXI_DATATYPE_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeInteger(stream, &val->integer);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 61:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
		if (val->type == EXI_DATATYPE_DECIMAL) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeDecimal(stream, &val->decimal);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 9:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeUnsignedInteger(stream, &val->integer);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 62:
		/* Element[CHARACTERS[DECIMAL]] */
		if (val->type == EXI_DATATYPE_DECIMAL) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeDecimal(stream, &val->decimal);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 77:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
		if (val->type == EXI_DATATYPE_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeInteger(stream, &val->integer);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			errn = encodeNBitUnsignedInteger(stream, 3, 3);
			if(errn == 0) {
				errn = encodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			}
			moveOnID = 50;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 3, 4);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 5);
				deviantChars = 1;
			}
		}
		break;
	case 76:
		/* Element[CHARACTERS[BINARY_HEX]] */
		if (val->type == EXI_DATATYPE_BINARY_HEX) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeBinary(stream, &val->binary);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 52:
		/* Element[CHARACTERS[BINARY_BASE64]] */
		if (val->type == EXI_DATATYPE_BINARY_BASE64) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeBinary(stream, &val->binary);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 14:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = _encodeNBitIntegerValue(stream, &val->integer, 8, 0);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 16:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = _encodeNBitIntegerValue(stream, &val->integer, 5, 1);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 7:
		/* Element[CHARACTERS[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 58:
	case 60:
	case 66:
	case 68:
	case 70:
	case 72:
	case 74:
	case 81:
		/* Element[CHARACTERS[DATETIME]] */
		if (val->type == EXI_DATATYPE_DATETIME) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeDateTime(stream, &val->datetime);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 53:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
		if (val->type == EXI_DATATYPE_BOOLEAN) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeBoolean(stream, val->boolean);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 10:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeUnsignedInteger(stream, &val->integer);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 54:
		/* Element[CHARACTERS[BOOLEAN]] */
		if (val->type == EXI_DATATYPE_BOOLEAN) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeBoolean(stream, val->boolean);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 79:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeUnsignedInteger(stream, &val->integer);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			errn = encodeNBitUnsignedInteger(stream, 2, 2);
			if(errn == 0) {
				errn = encodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			}
			moveOnID = 50;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 2, 3);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 1, 1);
				deviantChars = 1;
			}
		}
		break;
	case 13:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = _encodeNBitIntegerValue(stream, &val->integer, 8, 0);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 51:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
		if (val->type == EXI_DATATYPE_BINARY_BASE64) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeBinary(stream, &val->binary);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 47:
		/* FirstStartTag[CHARACTERS[LIST]] */
		if (val->type == EXI_DATATYPE_LIST) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeUnsignedInteger32(stream, val->list.len);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 42:
		/* Element[CHARACTERS[ENUMERATION]] */
		if (val->type == EXI_DATATYPE_ENUMERATION) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, val->enumeration);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;
	case 4:
		/* FirstStartTag[CHARACTERS[STRING]] */
		if (val->type == EXI_DATATYPE_STRING) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 3, 6);
				deviantChars = 1;
			}
		}
		break;
	case 64:
		/* Element[CHARACTERS[FLOAT]] */
		if (val->type == EXI_DATATYPE_FLOAT) {
			errn = encodeNBitUnsignedInteger(stream, 1, 0);
			if(errn == 0) {
				errn = encodeFloat(stream, &val->float_me);
			}
			moveOnID = 5;
		} else { 
			/* deviant characters */ 
			errn = encodeNBitUnsignedInteger(stream, 1, 1);
			if(errn == 0) {
				errn = encodeNBitUnsignedInteger(stream, 2, 2);
				deviantChars = 1;
			}
		}
		break;

	default:
		errn = (EXI_ERROR_UNEXPECTED_CHARACTERS);
		break;
	}

	if(errn == 0) {
		if (currentID < 0) {
			/* TODO runtime rules */
			errn = EXI_ERROR_UNEXPECTED_CHARACTERS;
		} else if (deviantChars) {
			return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;
		} else {
			/* move on */
			state->grammarStack[state->stackIndex] = moveOnID;
		}
	}

	return (errn);
}


int exiappHandEncodeAttribute(bitstream_t* stream, exi_state_t* state, uint16_t qnameID,
		exi_value_t* val) {
	int16_t moveOnID = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE;

	switch (currentID) {

	}

	/* no expected attribute */
	if (currentID < 0) {
		/* runtime element */
		errn = _encode2ndLevelAttribute(stream, state, qnameID, val);
	} else {
		if(moveOnID == 0) {
			/* no action yet */
#if EXI_OPTION_STRICT != 0
			/* no 2nd level events in strict mode for schema-informed grammars */
			errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE;
#else /* EXI_appHandSTRICT != 0 */
			errn = _encode2ndLevelAttribute(stream, state, qnameID, val);
#endif /* EXI_appHandSTRICT != 0 */
		} else {
			state->grammarStack[state->stackIndex] = moveOnID;
		}
	}

	return (errn);
}


int exiappHandEncodeAttributeNS(bitstream_t* stream,
		exi_state_t* state, uint16_t namespaceUriID,
		exi_string_ucs_t* localName, exi_value_t* val) {
	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;

	errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE_NS;

	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;

	return (errn);
}

int exiappHandEncodeAttributeGeneric(bitstream_t* stream,
		exi_state_t* state, exi_string_ucs_t* namespaceUri,
		exi_string_ucs_t* localName, exi_value_t* val) {
	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;

	errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE_GENERIC_UNDECLARED;

	return EXI_DEVIANT_SUPPORT_NOT_DEPLOYED;

	return (errn);
}


int exiappHandEncodeAttributeXsiNil(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {

	switch (state->grammarStack[state->stackIndex]) {

	}

	if (errn == 0) {
		errn = encodeBoolean(stream, val->boolean);
		if (errn == 0 && val->boolean) {
			/* handle xsi:nil == true */
			 errn = exi_appHand_HandleXsiNilTrue(state);
		}
	}

	return (errn);
}



int exiappHandEncodeAttributeXsiType(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	/* encode xsi:type event code */
	switch (state->grammarStack[state->stackIndex]) {
	case 9:
		errn = encodeNBitUnsignedInteger(stream, 1, 1);
		if(errn == 0) {
			errn = encodeNBitUnsignedInteger(stream, 3, 1);
		}
		break;

	default:
		errn = (EXI_ERROR_UNEXPECTED_ATTRIBUTE_XSI_TYPE);
		break;
	}
	if (errn == 0) {
		/* encode qname */
		errn = _encodeAttributeXsiTypeContent(stream, state, val);
	}

	return (errn);
}




#endif

