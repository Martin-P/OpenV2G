/*
 * Copyright (C) 2007-2013 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Sebastian.Kaebisch@siemens.com
 * @version 0.8
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXISeGen</p>
 *
 ********************************************************************/

 
 #include "appHand_service.h"
 #include "appHand_dataTypes.h"
 #include "EXITypes.h"
 #include "appHandEXIDecoder.h"
 #include "appHandQNameDefines.h"
 #include "StringValueTable.h"
 #include "StringNameTable.h"
 #include <string.h>
 
uint16_t numberOfLocalStringsDecode[EXI_appHandMAX_NUMBER_OF_QNAMES];
 



 static int _setUnsignedInt32Value(exi_integer_t* iv, uint32_t* int32) {
	int errn = 0;
	switch(iv->type) {
	/* Unsigned Integer */
	case EXI_UNSIGNED_INTEGER_8:
		*int32 = iv->val.uint8;
		break;
	case EXI_UNSIGNED_INTEGER_16:
		*int32 = iv->val.uint16;
		break;
	case EXI_UNSIGNED_INTEGER_32:
		if (iv->val.uint32 <= 2147483647) {
			*int32 = iv->val.uint32;
		} else {
			errn = -1;
		}
		break;
	case EXI_UNSIGNED_INTEGER_64:
		errn = -1;
		break;
	/* (Signed) Integer */
	case EXI_INTEGER_8:
		*int32 = iv->val.int8;
		break;
	case EXI_INTEGER_16:
		*int32 = iv->val.int16;
		break;
	case EXI_INTEGER_32:
		*int32 = iv->val.int32;
		break;
	case EXI_INTEGER_64:
		errn = -1;
		break;
	}
	return errn;
}
 
 

 /**
 * Deserialize an element or attribute value of the EXI stream and assign it to the
 * service data structure 
 */
static int deserializeElementAttributeCharacter(struct EXIDatabinder* service)
{

	switch(service->qnameID) {
		case 2: /* ProtocolNamespace */ 

				if(service->val.type == EXI_DATATYPE_STRING) 
					{
						memcpy(service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].ProtocolNamespace.data, service->val.str.miss.codepoints,service->val.str.miss.len*sizeof(uint32_t));
						service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].ProtocolNamespace.arraylen.data = service->val.str.miss.len;

					} 
					else
					{
						service->errorCode=EXI_DATATYPE_FAILED;
						return -1; /* wrong data type */
					}
		

				break;

		case 5: /* VersionNumberMajor */ 

				if(service->val.type == EXI_DATATYPE_UNSIGNED_INTEGER) 
					{
						if(_setUnsignedInt32Value(&(service->val.integer),&(service->val.integer.val.uint32)))
						{
							service->errorCode=EXI_VALUE_RANGE_FAILED;
							return -1;
						}
						service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].VersionNumberMajor=service->val.integer.val.uint32;
					} 
					else
					{
						service->errorCode=EXI_DATATYPE_FAILED;
						return -1; /* wrong data type */
					}
		

				break;

		case 6: /* VersionNumberMinor */ 

				if(service->val.type == EXI_DATATYPE_UNSIGNED_INTEGER) 
					{
						if(_setUnsignedInt32Value(&(service->val.integer),&(service->val.integer.val.uint32)))
						{
							service->errorCode=EXI_VALUE_RANGE_FAILED;
							return -1;
						}
						service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].VersionNumberMinor=service->val.integer.val.uint32;
					} 
					else
					{
						service->errorCode=EXI_DATATYPE_FAILED;
						return -1; /* wrong data type */
					}
		

				break;

		case 4: /* SchemaID */ 

				if(service->val.type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) 
					{
						if( service->idPath.id[0] == 66)
						{
							service->exiMsg.supportedAppProtocolRes->SchemaID=service->val.integer.val.uint8;
							service->exiMsg.supportedAppProtocolRes->isused.SchemaID=1;

						} else if(service->idPath.id[0] == 65)
						{
							service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].SchemaID=service->val.integer.val.uint8;						}

					} 
					else
					{
						service->errorCode=EXI_DATATYPE_FAILED;
						return -1; /* wrong data type */
					}
		

				break;

		case 1: /* Priority */ 

				if(service->val.type == EXI_DATATYPE_NBIT_UNSIGNED_INTEGER) 
					{
						service->exiMsg.supportedAppProtocolReq->AppProtocol[service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol].Priority=service->val.integer.val.uint8;
					} 
					else
					{
						service->errorCode=EXI_DATATYPE_FAILED;
						return -1; /* wrong data type */
					}
		

				break;

		case 3: /* ResponseCode */ 

				if(service->val.type == EXI_DATATYPE_ENUMERATION) 
					{
						service->exiMsg.supportedAppProtocolRes->ResponseCode=service->val.enumeration;
					} 
					else
					{
						service->errorCode=EXI_DATATYPE_FAILED;
						return -1; /* wrong data type */
					}
		

				break;

	
	} 
	return 0;
}
 
/**
 * Deserialize an element of the EXI stream
 * @return 0 = 0K; -1 = ERROR
 */
static int deserializeElement(struct EXIDatabinder* service)
{
	switch(service->qnameID) {
			case 0: /* AppProtocol */ 
						service->exiMsg.supportedAppProtocolReq->arraylen.AppProtocol++;
	
			break;
		case 65: /* supportedAppProtocolReq */ 
						service->exiMsg.isused.supportedAppProtocolReq=1;
	
			break;
		case 66: /* supportedAppProtocolRes */ 
						service->exiMsg.isused.supportedAppProtocolRes=1;
	
			break;
	
	}
	return 0;
}


 
 
/**
* Deserialize the appHand EXI stream
* @return 0 = 0K; -1 = ERROR
*/
int deserialize_appHand(struct EXIDatabinder* service, uint8_t* inStream, uint16_t sizeInStream, struct EXIDocumentType_appHand* exiDoc)
{
 	exi_name_table_runtime_t runtimeTableDecode;
 	uint32_t inPos;
	exi_value_table_t stringTableDecode = { 0, EXI_appHandMAX_NUMBER_OF_QNAMES, numberOfLocalStringsDecode};
 	int noEndOfDocument = 1; /* true */
	int returnCode=0;
	

	/* assign inStream data to service EXI structure */
	inPos = service->transportHeaderOffset;
	service->inStream.data = inStream;
	service->inStream.size = sizeInStream+inPos;
	service->inStream.pos = &inPos;
	service->inStream.buffer=0;
	service->inStream.capacity=0;

	init_EXIDocumentType_appHand(exiDoc);

	service->exiMsg=*exiDoc;

	exiInitNameTableRuntime(&runtimeTableDecode);
	exiappHandInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode,stringTableDecode);

	do {
		exiappHandDecodeNextEvent(&(service->inStream), &(service->stateDecode), &(service->event));
			if (returnCode < 0) {
				return returnCode;
			}

			switch (service->event) {
			case EXI_EVENT_START_DOCUMENT:

				returnCode = exiappHandDecodeStartDocument(&(service->inStream), &(service->stateDecode));

				break;
			case EXI_EVENT_END_DOCUMENT:

				returnCode = exiappHandDecodeEndDocument(&(service->inStream), &(service->stateDecode));
				noEndOfDocument = 0; /* false */
				break;
			case EXI_EVENT_START_ELEMENT:
				returnCode = exiappHandDecodeStartElement(&(service->inStream), &(service->stateDecode), &(service->qnameID));
				service->idPath.id[service->idPath.pos++]=service->qnameID;
				 
				break;
			case EXI_EVENT_END_ELEMENT:

				returnCode = exiappHandDecodeEndElement(&(service->inStream), &(service->stateDecode), &(service->qnameID));
				service->idPath.pos--;
				 
				returnCode = deserializeElement(service);
				break;
			case EXI_EVENT_CHARACTERS:
				/* decode */
				returnCode = exiappHandDecodeCharacters(&(service->inStream), &(service->stateDecode), &(service->val));
				 
				/* assign character data to the v2g message structure */
				returnCode = deserializeElementAttributeCharacter(service);
				break;
			case EXI_EVENT_ATTRIBUTE:
				/* decode */
				returnCode = exiappHandDecodeAttribute(&(service->inStream), &(service->stateDecode), &(service->qnameID), &(service->val));
				returnCode = deserializeElementAttributeCharacter(service);
				break;
			default:
				/* ERROR */
				return -1;
			}

		} while (noEndOfDocument);
		
		*exiDoc = service->exiMsg;

	return 0;
}
 
  
 
/** 
 * \brief   Initialize the appHand deserializer
 * \param	service  struct EXIDatabinder* Basic databinder structure
 * \param	service_bytes   bytes_t Reserved byte structure buffer 
 * \param	service_string   string_ucs_t* Reserved string structure buffer 
 * \return  0 = 0K; -1 = ERROR */
int init_appHandDeserializer(struct EXIDatabinder* service, exi_bytes_t service_bytes, exi_string_ucs_t service_string, uint16_t transportHeaderOffset)
{

	/* init byte array */
	 service->val.binary = service_bytes;

	/* init string array */
	 service->val.str.miss = service_string;


	 service->idPath.pos=0;

	 /* init offset for transport protocol */
	service->transportHeaderOffset=transportHeaderOffset;


	return 0;
}

  
