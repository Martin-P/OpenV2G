/*
 * Copyright (C) 2007-2013 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Sebastian.Kaebisch@siemens.com
 * @version 0.8
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXISeGen</p>
 *
 ********************************************************************/


#include "appHand_service.h"
#include "appHand_dataTypes.h"
#include "EXITypes.h"
#include "StringNameTable.h"
#include "appHandEXIEncoder.h"
#include "appHandQNameDefines.h"
#include <string.h>

 uint16_t numberOfLocalStringsEncode[EXI_appHandMAX_NUMBER_OF_QNAMES];
 
 
 
 
 
 

static int serialize_AppProtocolType(struct AppProtocolType* type, struct EXIDatabinder* service)
{
		


			/* encode start element ProtocolNamespace */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 2)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_STRING;
			service->val.str.type = EXI_STRING_VALUE_MISS;
			service->val.str.miss.len = type->ProtocolNamespace.arraylen.data;
			memcpy(service->val.str.miss.codepoints, type->ProtocolNamespace.data,type->ProtocolNamespace.arraylen.data*sizeof(uint32_t));
		   
				
		
			/* encode character  ProtocolNamespace */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
					return -1;
			}
			
			 
			/* encode end element of ProtocolNamespace */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element VersionNumberMajor */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 5)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_UNSIGNED_INTEGER;
		    service->val.integer.val.uint32=type->VersionNumberMajor;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_32;
			
			/* encode character  VersionNumberMajor */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of VersionNumberMajor */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element VersionNumberMinor */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 6)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_UNSIGNED_INTEGER;
		    service->val.integer.val.uint32=type->VersionNumberMinor;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_32;
			
			/* encode character  VersionNumberMinor */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of VersionNumberMinor */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element SchemaID */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 4)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
		    service->val.integer.val.uint8=type->SchemaID;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  SchemaID */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of SchemaID */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element Priority */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 1)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
		    service->val.integer.val.uint8=type->Priority;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  Priority */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of Priority */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		

	return 0;			
}


static int serialize_SupportedAppProtocolReq(struct SupportedAppProtocolReq* type, struct EXIDatabinder* service)
{

			size_t i_loop;
	
	for(i_loop=0;i_loop < type->arraylen.AppProtocol;i_loop++)
		{
				


			/* encode start element AppProtocol */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 0)) 
			{
					return -1;
			}
			
			/* encode children of AppProtocol */
			if(serialize_AppProtocolType(&(type->AppProtocol[i_loop]),service))
			{
				return -1;
			}
			
			 
			/* encode end element of AppProtocol */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}


static int serialize_SupportedAppProtocolRes(struct SupportedAppProtocolRes* type, struct EXIDatabinder* service)
{
		


			/* encode start element ResponseCode */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 3)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_ENUMERATION;
		    service->val.enumeration=type->ResponseCode;
		   
			
			/* encode character  ResponseCode */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of ResponseCode */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		
	if(type->isused.SchemaID)
		{		
						


			/* encode start element SchemaID */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 4)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
		    service->val.integer.val.uint8=type->SchemaID;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  SchemaID */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of SchemaID */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}


static int serialize_EXIDocumentType_appHand(struct EXIDocumentType_appHand* type, struct EXIDatabinder* service)
{

	if(type->isused.supportedAppProtocolReq)
		{		
						


			/* encode start element supportedAppProtocolReq */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 65)) 
			{
					return -1;
			}
						
			/* encode children of supportedAppProtocolReq */
			if(serialize_SupportedAppProtocolReq( type->supportedAppProtocolReq,service))
			{
				return -1;
			}

			
			 
			/* encode end element of supportedAppProtocolReq */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				
	if(type->isused.supportedAppProtocolRes)
		{		
						


			/* encode start element supportedAppProtocolRes */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 66)) 
			{
					return -1;
			}
						
			/* encode children of supportedAppProtocolRes */
			if(serialize_SupportedAppProtocolRes( type->supportedAppProtocolRes,service))
			{
				return -1;
			}

			
			 
			/* encode end element of supportedAppProtocolRes */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}

 
 
 
 
 /* serialize data to EXI stream */
static int serialize_message(struct EXIDatabinder* service)
 { 

	/* encode start document */ 	
	if (exiappHandEncodeStartDocument(&(service->outStream), &(service->stateEncode)) ) 
	{
	 
		return -1;
	}

 	
	if (serialize_EXIDocumentType_appHand(&(service->exiMsg), service))	 
	 
	 
	{
			 
		return -1;
	}


	/* encode end document */
	if (exiappHandEncodeEndDocument(&(service->outStream), &(service->stateEncode))) {
	 
	return -1;
	}	
 	
 	return 0;
 	
 }

 
 
int serialize_appHand(struct EXIDatabinder* service, uint8_t* outStream, uint16_t* payloadLength, struct EXIDocumentType_appHand* exiDoc)
{
 	exi_name_table_runtime_t runtimeTableEncode;

 	int16_t lerr = 0; /* local error */
 	exi_value_table_t stringTableEncode = { 0, EXI_appHandMAX_NUMBER_OF_QNAMES, numberOfLocalStringsEncode};

 	uint32_t outPos =service->transportHeaderOffset;
 
 	/* assign outStream data to service EXI structure */
	service->outStream.data = outStream;
	service->outStream.pos = &outPos;
	service->outStream.buffer=0;
	service->outStream.capacity=8;
 
  	service->exiMsg = *exiDoc;
 
		/* init encoder (write header, set initial state) */
		exiInitNameTableRuntime(&runtimeTableEncode);

		if(exiappHandInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode,stringTableEncode))
		{
			lerr = -1;
		}
 
 		/* serialze message*/
 		if(serialize_message(service))
 		{
	 		lerr = -1;
 		}

 		outPos -= service->transportHeaderOffset;
 		*payloadLength = outPos;


 	return lerr;
 }
 
/* Initialize serializer */
int init_appHandSerializer(struct EXIDatabinder* service, exi_bytes_t service_bytes, exi_string_ucs_t service_string, size_t max_outStream_size, uint16_t transportHeaderOffset)
{

	/* init byte array */
	 service->val.binary = service_bytes;

	/* init string array */
	 service->val.str.miss = service_string;

	 /* init output stream */

	 service->outStream.size=max_outStream_size;

	 service->transportHeaderOffset=transportHeaderOffset;

	return 0;
}
 
 
