/*
 * Copyright (C) 2007-2015 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.9.3 
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 * <p>Schema: xmldsig-core-schema.xsd</p>
 *
 *
 ********************************************************************/




#include "xmldsigEXIDatatypesDecoder.h"

#include "DecoderChannel.h"
#include "EXIHeaderDecoder.h"

#include "xmldsigEXIDatatypes.h"
#include "ErrorCodes.h"

#ifndef EXI_xmldsig_DATATYPES_DECODER_C
#define EXI_xmldsig_DATATYPES_DECODER_C

#if DEPLOY_XMLDSIG_CODEC == SUPPORT_YES

/** event-code */
static uint32_t eventCode;
static int errn;
static uint32_t uint32;


/* Forward Declarations */
static int decode_xmldsigKeyValueType(bitstream_t* stream, struct xmldsigKeyValueType* xmldsigKeyValueType);
static int decode_xmldsigDSAKeyValueType(bitstream_t* stream, struct xmldsigDSAKeyValueType* xmldsigDSAKeyValueType);
static int decode_xmldsigRSAKeyValueType(bitstream_t* stream, struct xmldsigRSAKeyValueType* xmldsigRSAKeyValueType);
static int decode_xmldsigSignaturePropertiesType(bitstream_t* stream, struct xmldsigSignaturePropertiesType* xmldsigSignaturePropertiesType);
static int decode_xmldsigCanonicalizationMethodType(bitstream_t* stream, struct xmldsigCanonicalizationMethodType* xmldsigCanonicalizationMethodType);
static int decode_xmldsigObjectType(bitstream_t* stream, struct xmldsigObjectType* xmldsigObjectType);
static int decode_xmldsigTransformsType(bitstream_t* stream, struct xmldsigTransformsType* xmldsigTransformsType);
static int decode_xmldsigTransformType(bitstream_t* stream, struct xmldsigTransformType* xmldsigTransformType);
static int decode_xmldsigDigestMethodType(bitstream_t* stream, struct xmldsigDigestMethodType* xmldsigDigestMethodType);
static int decode_xmldsigSignatureType(bitstream_t* stream, struct xmldsigSignatureType* xmldsigSignatureType);
static int decode_xmldsigReferenceType(bitstream_t* stream, struct xmldsigReferenceType* xmldsigReferenceType);
static int decode_xmldsigSPKIDataType(bitstream_t* stream, struct xmldsigSPKIDataType* xmldsigSPKIDataType);
static int decode_xmldsigPGPDataType(bitstream_t* stream, struct xmldsigPGPDataType* xmldsigPGPDataType);
static int decode_xmldsigX509IssuerSerialType(bitstream_t* stream, struct xmldsigX509IssuerSerialType* xmldsigX509IssuerSerialType);
static int decode_xmldsigSignatureMethodType(bitstream_t* stream, struct xmldsigSignatureMethodType* xmldsigSignatureMethodType);
static int decode_xmldsigRetrievalMethodType(bitstream_t* stream, struct xmldsigRetrievalMethodType* xmldsigRetrievalMethodType);
static int decode_xmldsigSignaturePropertyType(bitstream_t* stream, struct xmldsigSignaturePropertyType* xmldsigSignaturePropertyType);
static int decode_xmldsigSignedInfoType(bitstream_t* stream, struct xmldsigSignedInfoType* xmldsigSignedInfoType);
static int decode_xmldsigKeyInfoType(bitstream_t* stream, struct xmldsigKeyInfoType* xmldsigKeyInfoType);
static int decode_xmldsigManifestType(bitstream_t* stream, struct xmldsigManifestType* xmldsigManifestType);
static int decode_xmldsigSignatureValueType(bitstream_t* stream, struct xmldsigSignatureValueType* xmldsigSignatureValueType);
static int decode_xmldsigX509DataType(bitstream_t* stream, struct xmldsigX509DataType* xmldsigX509DataType);

/* Deviant data decoding (skip functions) */
static int decodeDeviationsCH(bitstream_t* stream) {
	int i=0;
	uint16_t uint16;
	errn = 0;
	
	errn = decodeUnsignedInteger16(stream, &uint16);
	if (errn == 0) {
		for(i=0; i<uint16 && errn == 0; i++) {
			errn = decodeUnsignedInteger32(stream, &uint32);
		}
	}
	return errn;
}


/* Complex type name='http://www.w3.org/2000/09/xmldsig#,KeyValueType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":DSAKeyValue|"http://www.w3.org/2000/09/xmldsig#":RSAKeyValue|(WC[##other:"http://www.w3.org/2000/09/xmldsig#"]))',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigKeyValueType(bitstream_t* stream, struct xmldsigKeyValueType* xmldsigKeyValueType) {
	int grammarID = 0;
	int done = 0;
	
	init_xmldsigKeyValueType(xmldsigKeyValueType);
	
	while(!done) {
		switch(grammarID) {
		case 0:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DSAKeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RSAKeyValue), START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigDSAKeyValueType(stream, &xmldsigKeyValueType->DSAKeyValue);
					xmldsigKeyValueType->DSAKeyValue_isUsed = 1u;
					grammarID = 1;
					break;
				case 1:
					errn = decode_xmldsigRSAKeyValueType(stream, &xmldsigKeyValueType->RSAKeyValue);
					xmldsigKeyValueType->RSAKeyValue_isUsed = 1u;
					grammarID = 1;
					break;
				case 2:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 1;
					break;
				case 3:
					errn = decodeDeviationsCH(stream);
					grammarID = 2;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 1:
			/* Element[END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				case 1:
					grammarID = 1;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 2:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DSAKeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RSAKeyValue), START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigDSAKeyValueType(stream, &xmldsigKeyValueType->DSAKeyValue);
					xmldsigKeyValueType->DSAKeyValue_isUsed = 1u;
					grammarID = 1;
					break;
				case 1:
					errn = decode_xmldsigRSAKeyValueType(stream, &xmldsigKeyValueType->RSAKeyValue);
					xmldsigKeyValueType->RSAKeyValue_isUsed = 1u;
					grammarID = 1;
					break;
				case 2:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 1;
					break;
				case 3:
					grammarID = 2;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,DSAKeyValueType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='(("http://www.w3.org/2000/09/xmldsig#":P,"http://www.w3.org/2000/09/xmldsig#":Q){0-1},"http://www.w3.org/2000/09/xmldsig#":G{0-1},"http://www.w3.org/2000/09/xmldsig#":Y,"http://www.w3.org/2000/09/xmldsig#":J{0-1},("http://www.w3.org/2000/09/xmldsig#":Seed,"http://www.w3.org/2000/09/xmldsig#":PgenCounter){0-1})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigDSAKeyValueType(bitstream_t* stream, struct xmldsigDSAKeyValueType* xmldsigDSAKeyValueType) {
	int grammarID = 4;
	int done = 0;
	
	init_xmldsigDSAKeyValueType(xmldsigDSAKeyValueType);
	
	while(!done) {
		switch(grammarID) {
		case 4:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}P), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}G), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->P.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->P.bytesLen) <= xmldsigDSAKeyValueType_P_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->P.bytesLen, xmldsigDSAKeyValueType->P.bytes);
							}
							xmldsigDSAKeyValueType->P_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}P) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 5;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->G.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->G.bytesLen) <= xmldsigDSAKeyValueType_G_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->G.bytesLen, xmldsigDSAKeyValueType->G.bytes);
							}
							xmldsigDSAKeyValueType->G_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}G) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 6;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 2:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->Y.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->Y.bytesLen) <= xmldsigDSAKeyValueType_Y_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->Y.bytesLen, xmldsigDSAKeyValueType->Y.bytes);
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 7;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 5:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Q)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->Q.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->Q.bytesLen) <= xmldsigDSAKeyValueType_Q_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->Q.bytesLen, xmldsigDSAKeyValueType->Q.bytes);
							}
							xmldsigDSAKeyValueType->Q_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Q) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 8;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 8:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}G), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->G.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->G.bytesLen) <= xmldsigDSAKeyValueType_G_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->G.bytesLen, xmldsigDSAKeyValueType->G.bytes);
							}
							xmldsigDSAKeyValueType->G_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}G) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 6;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->Y.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->Y.bytesLen) <= xmldsigDSAKeyValueType_Y_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->Y.bytesLen, xmldsigDSAKeyValueType->Y.bytes);
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 7;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 6:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->Y.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->Y.bytesLen) <= xmldsigDSAKeyValueType_Y_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->Y.bytesLen, xmldsigDSAKeyValueType->Y.bytes);
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 7;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 7:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}J), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Seed), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->J.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->J.bytesLen) <= xmldsigDSAKeyValueType_J_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->J.bytesLen, xmldsigDSAKeyValueType->J.bytes);
							}
							xmldsigDSAKeyValueType->J_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}J) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 9;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->Seed.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->Seed.bytesLen) <= xmldsigDSAKeyValueType_Seed_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->Seed.bytesLen, xmldsigDSAKeyValueType->Seed.bytes);
							}
							xmldsigDSAKeyValueType->Seed_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Seed) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 10;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 9:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Seed), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->Seed.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->Seed.bytesLen) <= xmldsigDSAKeyValueType_Seed_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->Seed.bytesLen, xmldsigDSAKeyValueType->Seed.bytes);
							}
							xmldsigDSAKeyValueType->Seed_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Seed) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 10;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 10:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PgenCounter)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigDSAKeyValueType->PgenCounter.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigDSAKeyValueType->PgenCounter.bytesLen) <= xmldsigDSAKeyValueType_PgenCounter_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigDSAKeyValueType->PgenCounter.bytesLen, xmldsigDSAKeyValueType->PgenCounter.bytes);
							}
							xmldsigDSAKeyValueType->PgenCounter_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PgenCounter) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 11;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 11:
			/* Element[END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,RSAKeyValueType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":Modulus,"http://www.w3.org/2000/09/xmldsig#":Exponent)',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigRSAKeyValueType(bitstream_t* stream, struct xmldsigRSAKeyValueType* xmldsigRSAKeyValueType) {
	int grammarID = 12;
	int done = 0;
	
	init_xmldsigRSAKeyValueType(xmldsigRSAKeyValueType);
	
	while(!done) {
		switch(grammarID) {
		case 12:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Modulus)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigRSAKeyValueType->Modulus.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigRSAKeyValueType->Modulus.bytesLen) <= xmldsigRSAKeyValueType_Modulus_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigRSAKeyValueType->Modulus.bytesLen, xmldsigRSAKeyValueType->Modulus.bytes);
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Modulus) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 13;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 13:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Exponent)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigRSAKeyValueType->Exponent.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigRSAKeyValueType->Exponent.bytesLen) <= xmldsigRSAKeyValueType_Exponent_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigRSAKeyValueType->Exponent.bytesLen, xmldsigRSAKeyValueType->Exponent.bytes);
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Exponent) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 11;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 11:
			/* Element[END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SignaturePropertiesType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":SignatureProperty{1-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigSignaturePropertiesType(bitstream_t* stream, struct xmldsigSignaturePropertiesType* xmldsigSignaturePropertiesType) {
	int grammarID = 14;
	int done = 0;
	
	init_xmldsigSignaturePropertiesType(xmldsigSignaturePropertiesType);
	
	while(!done) {
		switch(grammarID) {
		case 14:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignaturePropertiesType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignaturePropertiesType->Id.charactersLen - 2) <= xmldsigSignaturePropertiesType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignaturePropertiesType->Id.charactersLen >= 2) {
							xmldsigSignaturePropertiesType->Id.charactersLen = (uint16_t)(xmldsigSignaturePropertiesType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignaturePropertiesType->Id.charactersLen, xmldsigSignaturePropertiesType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigSignaturePropertiesType->Id_isUsed = 1u;
					grammarID = 15;
					break;
				case 1:
					if (xmldsigSignaturePropertiesType->SignatureProperty.arrayLen < xmldsigSignaturePropertiesType_SignatureProperty_ARRAY_SIZE) {
						errn = decode_xmldsigSignaturePropertyType(stream, &xmldsigSignaturePropertiesType->SignatureProperty.array[xmldsigSignaturePropertiesType->SignatureProperty.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 16;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 15:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSignaturePropertiesType->SignatureProperty.arrayLen < xmldsigSignaturePropertiesType_SignatureProperty_ARRAY_SIZE) {
						errn = decode_xmldsigSignaturePropertyType(stream, &xmldsigSignaturePropertiesType->SignatureProperty.array[xmldsigSignaturePropertiesType->SignatureProperty.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 16;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 16:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSignaturePropertiesType->SignatureProperty.arrayLen < xmldsigSignaturePropertiesType_SignatureProperty_ARRAY_SIZE) {
						errn = decode_xmldsigSignaturePropertyType(stream, &xmldsigSignaturePropertiesType->SignatureProperty.array[xmldsigSignaturePropertiesType->SignatureProperty.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 16;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,CanonicalizationMethodType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='((WC[##any]){0-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigCanonicalizationMethodType(bitstream_t* stream, struct xmldsigCanonicalizationMethodType* xmldsigCanonicalizationMethodType) {
	int grammarID = 17;
	int done = 0;
	
	init_xmldsigCanonicalizationMethodType(xmldsigCanonicalizationMethodType);
	
	while(!done) {
		switch(grammarID) {
		case 17:
			/* FirstStartTag[ATTRIBUTE[STRING](Algorithm)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigCanonicalizationMethodType->Algorithm.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigCanonicalizationMethodType->Algorithm.charactersLen - 2) <= xmldsigCanonicalizationMethodType_Algorithm_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigCanonicalizationMethodType->Algorithm.charactersLen >= 2) {
							xmldsigCanonicalizationMethodType->Algorithm.charactersLen = (uint16_t)(xmldsigCanonicalizationMethodType->Algorithm.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigCanonicalizationMethodType->Algorithm.charactersLen, xmldsigCanonicalizationMethodType->Algorithm.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					grammarID = 18;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 18:
			/* StartTag[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 19:
			/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,ObjectType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='((WC[##any])){0-UNBOUNDED}',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigObjectType(bitstream_t* stream, struct xmldsigObjectType* xmldsigObjectType) {
	int grammarID = 20;
	int done = 0;
	
	init_xmldsigObjectType(xmldsigObjectType);
	
	while(!done) {
		switch(grammarID) {
		case 20:
			/* FirstStartTag[ATTRIBUTE[STRING](Encoding), ATTRIBUTE[STRING](Id), ATTRIBUTE[STRING](MimeType), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigObjectType->Encoding.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigObjectType->Encoding.charactersLen - 2) <= xmldsigObjectType_Encoding_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigObjectType->Encoding.charactersLen >= 2) {
							xmldsigObjectType->Encoding.charactersLen = (uint16_t)(xmldsigObjectType->Encoding.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigObjectType->Encoding.charactersLen, xmldsigObjectType->Encoding.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigObjectType->Encoding_isUsed = 1u;
					grammarID = 21;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigObjectType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigObjectType->Id.charactersLen - 2) <= xmldsigObjectType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigObjectType->Id.charactersLen >= 2) {
							xmldsigObjectType->Id.charactersLen = (uint16_t)(xmldsigObjectType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigObjectType->Id.charactersLen, xmldsigObjectType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigObjectType->Id_isUsed = 1u;
					grammarID = 22;
					break;
				case 2:
					errn = decodeUnsignedInteger16(stream, &xmldsigObjectType->MimeType.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigObjectType->MimeType.charactersLen - 2) <= xmldsigObjectType_MimeType_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigObjectType->MimeType.charactersLen >= 2) {
							xmldsigObjectType->MimeType.charactersLen = (uint16_t)(xmldsigObjectType->MimeType.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigObjectType->MimeType.charactersLen, xmldsigObjectType->MimeType.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigObjectType->MimeType_isUsed = 1u;
					grammarID = 18;
					break;
				case 3:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 4:
					done = 1;
					grammarID = 3;
					break;
				case 5:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 21:
			/* StartTag[ATTRIBUTE[STRING](Id), ATTRIBUTE[STRING](MimeType), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigObjectType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigObjectType->Id.charactersLen - 2) <= xmldsigObjectType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigObjectType->Id.charactersLen >= 2) {
							xmldsigObjectType->Id.charactersLen = (uint16_t)(xmldsigObjectType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigObjectType->Id.charactersLen, xmldsigObjectType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigObjectType->Id_isUsed = 1u;
					grammarID = 22;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigObjectType->MimeType.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigObjectType->MimeType.charactersLen - 2) <= xmldsigObjectType_MimeType_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigObjectType->MimeType.charactersLen >= 2) {
							xmldsigObjectType->MimeType.charactersLen = (uint16_t)(xmldsigObjectType->MimeType.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigObjectType->MimeType.charactersLen, xmldsigObjectType->MimeType.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigObjectType->MimeType_isUsed = 1u;
					grammarID = 18;
					break;
				case 2:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 3:
					done = 1;
					grammarID = 3;
					break;
				case 4:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 22:
			/* StartTag[ATTRIBUTE[STRING](MimeType), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigObjectType->MimeType.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigObjectType->MimeType.charactersLen - 2) <= xmldsigObjectType_MimeType_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigObjectType->MimeType.charactersLen >= 2) {
							xmldsigObjectType->MimeType.charactersLen = (uint16_t)(xmldsigObjectType->MimeType.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigObjectType->MimeType.charactersLen, xmldsigObjectType->MimeType.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigObjectType->MimeType_isUsed = 1u;
					grammarID = 18;
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				case 3:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 18:
			/* StartTag[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 19:
			/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,TransformsType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":Transform{1-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigTransformsType(bitstream_t* stream, struct xmldsigTransformsType* xmldsigTransformsType) {
	int grammarID = 23;
	int done = 0;
	
	init_xmldsigTransformsType(xmldsigTransformsType);
	
	while(!done) {
		switch(grammarID) {
		case 23:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transform)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigTransformsType->Transform.arrayLen < xmldsigTransformsType_Transform_ARRAY_SIZE) {
						errn = decode_xmldsigTransformType(stream, &xmldsigTransformsType->Transform.array[xmldsigTransformsType->Transform.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 24;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 24:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transform), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigTransformsType->Transform.arrayLen < xmldsigTransformsType_Transform_ARRAY_SIZE) {
						errn = decode_xmldsigTransformType(stream, &xmldsigTransformsType->Transform.array[xmldsigTransformsType->Transform.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 24;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,TransformType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='((WC[##other:"http://www.w3.org/2000/09/xmldsig#"])|"http://www.w3.org/2000/09/xmldsig#":XPath){0-UNBOUNDED}',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigTransformType(bitstream_t* stream, struct xmldsigTransformType* xmldsigTransformType) {
	int grammarID = 25;
	int done = 0;
	
	init_xmldsigTransformType(xmldsigTransformType);
	
	while(!done) {
		switch(grammarID) {
		case 25:
			/* FirstStartTag[ATTRIBUTE[STRING](Algorithm)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigTransformType->Algorithm.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigTransformType->Algorithm.charactersLen - 2) <= xmldsigTransformType_Algorithm_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigTransformType->Algorithm.charactersLen >= 2) {
							xmldsigTransformType->Algorithm.charactersLen = (uint16_t)(xmldsigTransformType->Algorithm.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigTransformType->Algorithm.charactersLen, xmldsigTransformType->Algorithm.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					grammarID = 26;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 26:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}XPath), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigTransformType->XPath.arrayLen < xmldsigTransformType_XPath_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen - 2) <= xmldsigTransformType_XPath_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen >= 2) {
										xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen = (uint16_t)(xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen, xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigTransformType->XPath.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}XPath) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 27;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 27;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				case 3:
					grammarID = 27;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 27:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}XPath), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigTransformType->XPath.arrayLen < xmldsigTransformType_XPath_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen - 2) <= xmldsigTransformType_XPath_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen >= 2) {
										xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen = (uint16_t)(xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].charactersLen, xmldsigTransformType->XPath.array[xmldsigTransformType->XPath.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigTransformType->XPath.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}XPath) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 27;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 27;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				case 3:
					grammarID = 27;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,DigestMethodType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='((WC[##other:"http://www.w3.org/2000/09/xmldsig#"]){0-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigDigestMethodType(bitstream_t* stream, struct xmldsigDigestMethodType* xmldsigDigestMethodType) {
	int grammarID = 17;
	int done = 0;
	
	init_xmldsigDigestMethodType(xmldsigDigestMethodType);
	
	while(!done) {
		switch(grammarID) {
		case 17:
			/* FirstStartTag[ATTRIBUTE[STRING](Algorithm)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigDigestMethodType->Algorithm.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigDigestMethodType->Algorithm.charactersLen - 2) <= xmldsigDigestMethodType_Algorithm_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigDigestMethodType->Algorithm.charactersLen >= 2) {
							xmldsigDigestMethodType->Algorithm.charactersLen = (uint16_t)(xmldsigDigestMethodType->Algorithm.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigDigestMethodType->Algorithm.charactersLen, xmldsigDigestMethodType->Algorithm.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					grammarID = 18;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 18:
			/* StartTag[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 19:
			/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SignatureType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":SignedInfo,"http://www.w3.org/2000/09/xmldsig#":SignatureValue,"http://www.w3.org/2000/09/xmldsig#":KeyInfo{0-1},"http://www.w3.org/2000/09/xmldsig#":Object{0-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigSignatureType(bitstream_t* stream, struct xmldsigSignatureType* xmldsigSignatureType) {
	int grammarID = 28;
	int done = 0;
	
	init_xmldsigSignatureType(xmldsigSignatureType);
	
	while(!done) {
		switch(grammarID) {
		case 28:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignedInfo)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignatureType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignatureType->Id.charactersLen - 2) <= xmldsigSignatureType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignatureType->Id.charactersLen >= 2) {
							xmldsigSignatureType->Id.charactersLen = (uint16_t)(xmldsigSignatureType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignatureType->Id.charactersLen, xmldsigSignatureType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigSignatureType->Id_isUsed = 1u;
					grammarID = 29;
					break;
				case 1:
					errn = decode_xmldsigSignedInfoType(stream, &xmldsigSignatureType->SignedInfo);
					grammarID = 30;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 29:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignedInfo)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigSignedInfoType(stream, &xmldsigSignatureType->SignedInfo);
					grammarID = 30;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 30:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureValue)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigSignatureValueType(stream, &xmldsigSignatureType->SignatureValue);
					grammarID = 31;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 31:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyInfo), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Object), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigKeyInfoType(stream, &xmldsigSignatureType->KeyInfo);
					xmldsigSignatureType->KeyInfo_isUsed = 1u;
					grammarID = 32;
					break;
				case 1:
					if (xmldsigSignatureType->Object.arrayLen < xmldsigSignatureType_Object_ARRAY_SIZE) {
						errn = decode_xmldsigObjectType(stream, &xmldsigSignatureType->Object.array[xmldsigSignatureType->Object.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 32;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 32:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Object), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSignatureType->Object.arrayLen < xmldsigSignatureType_Object_ARRAY_SIZE) {
						errn = decode_xmldsigObjectType(stream, &xmldsigSignatureType->Object.array[xmldsigSignatureType->Object.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 32;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,ReferenceType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":Transforms{0-1},"http://www.w3.org/2000/09/xmldsig#":DigestMethod,"http://www.w3.org/2000/09/xmldsig#":DigestValue)',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigReferenceType(bitstream_t* stream, struct xmldsigReferenceType* xmldsigReferenceType) {
	int grammarID = 33;
	int done = 0;
	
	init_xmldsigReferenceType(xmldsigReferenceType);
	
	while(!done) {
		switch(grammarID) {
		case 33:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), ATTRIBUTE[STRING](Type), ATTRIBUTE[STRING](URI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigReferenceType->Id.charactersLen - 2) <= xmldsigReferenceType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigReferenceType->Id.charactersLen >= 2) {
							xmldsigReferenceType->Id.charactersLen = (uint16_t)(xmldsigReferenceType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigReferenceType->Id.charactersLen, xmldsigReferenceType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigReferenceType->Id_isUsed = 1u;
					grammarID = 34;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->Type.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigReferenceType->Type.charactersLen - 2) <= xmldsigReferenceType_Type_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigReferenceType->Type.charactersLen >= 2) {
							xmldsigReferenceType->Type.charactersLen = (uint16_t)(xmldsigReferenceType->Type.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigReferenceType->Type.charactersLen, xmldsigReferenceType->Type.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigReferenceType->Type_isUsed = 1u;
					grammarID = 35;
					break;
				case 2:
					errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->URI.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigReferenceType->URI.charactersLen - 2) <= xmldsigReferenceType_URI_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigReferenceType->URI.charactersLen >= 2) {
							xmldsigReferenceType->URI.charactersLen = (uint16_t)(xmldsigReferenceType->URI.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigReferenceType->URI.charactersLen, xmldsigReferenceType->URI.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigReferenceType->URI_isUsed = 1u;
					grammarID = 36;
					break;
				case 3:
					errn = decode_xmldsigTransformsType(stream, &xmldsigReferenceType->Transforms);
					xmldsigReferenceType->Transforms_isUsed = 1u;
					grammarID = 37;
					break;
				case 4:
					errn = decode_xmldsigDigestMethodType(stream, &xmldsigReferenceType->DigestMethod);
					grammarID = 38;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 34:
			/* StartTag[ATTRIBUTE[STRING](Type), ATTRIBUTE[STRING](URI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->Type.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigReferenceType->Type.charactersLen - 2) <= xmldsigReferenceType_Type_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigReferenceType->Type.charactersLen >= 2) {
							xmldsigReferenceType->Type.charactersLen = (uint16_t)(xmldsigReferenceType->Type.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigReferenceType->Type.charactersLen, xmldsigReferenceType->Type.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigReferenceType->Type_isUsed = 1u;
					grammarID = 35;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->URI.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigReferenceType->URI.charactersLen - 2) <= xmldsigReferenceType_URI_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigReferenceType->URI.charactersLen >= 2) {
							xmldsigReferenceType->URI.charactersLen = (uint16_t)(xmldsigReferenceType->URI.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigReferenceType->URI.charactersLen, xmldsigReferenceType->URI.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigReferenceType->URI_isUsed = 1u;
					grammarID = 36;
					break;
				case 2:
					errn = decode_xmldsigTransformsType(stream, &xmldsigReferenceType->Transforms);
					xmldsigReferenceType->Transforms_isUsed = 1u;
					grammarID = 37;
					break;
				case 3:
					errn = decode_xmldsigDigestMethodType(stream, &xmldsigReferenceType->DigestMethod);
					grammarID = 38;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 35:
			/* StartTag[ATTRIBUTE[STRING](URI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->URI.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigReferenceType->URI.charactersLen - 2) <= xmldsigReferenceType_URI_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigReferenceType->URI.charactersLen >= 2) {
							xmldsigReferenceType->URI.charactersLen = (uint16_t)(xmldsigReferenceType->URI.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigReferenceType->URI.charactersLen, xmldsigReferenceType->URI.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigReferenceType->URI_isUsed = 1u;
					grammarID = 36;
					break;
				case 1:
					errn = decode_xmldsigTransformsType(stream, &xmldsigReferenceType->Transforms);
					xmldsigReferenceType->Transforms_isUsed = 1u;
					grammarID = 37;
					break;
				case 2:
					errn = decode_xmldsigDigestMethodType(stream, &xmldsigReferenceType->DigestMethod);
					grammarID = 38;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 36:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigTransformsType(stream, &xmldsigReferenceType->Transforms);
					xmldsigReferenceType->Transforms_isUsed = 1u;
					grammarID = 37;
					break;
				case 1:
					errn = decode_xmldsigDigestMethodType(stream, &xmldsigReferenceType->DigestMethod);
					grammarID = 38;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 37:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigDigestMethodType(stream, &xmldsigReferenceType->DigestMethod);
					grammarID = 38;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 38:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestValue)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigReferenceType->DigestValue.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigReferenceType->DigestValue.bytesLen) <= xmldsigReferenceType_DigestValue_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigReferenceType->DigestValue.bytesLen, xmldsigReferenceType->DigestValue.bytes);
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestValue) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 11;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 11:
			/* Element[END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SPKIDataType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":SPKISexp,(WC[##other:"http://www.w3.org/2000/09/xmldsig#"]){0-1}){1-UNBOUNDED}',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigSPKIDataType(bitstream_t* stream, struct xmldsigSPKIDataType* xmldsigSPKIDataType) {
	int grammarID = 39;
	int done = 0;
	
	init_xmldsigSPKIDataType(xmldsigSPKIDataType);
	
	while(!done) {
		switch(grammarID) {
		case 39:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSPKIDataType->SPKISexp.arrayLen < xmldsigSPKIDataType_SPKISexp_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen) <= xmldsigSPKIDataType_SPKISexp_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen, xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytes);
								}
								xmldsigSPKIDataType->SPKISexp.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 40;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 40:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp), START_ELEMENT_GENERIC, END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSPKIDataType->SPKISexp.arrayLen < xmldsigSPKIDataType_SPKISexp_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen) <= xmldsigSPKIDataType_SPKISexp_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen, xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytes);
								}
								xmldsigSPKIDataType->SPKISexp.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 40;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 41;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 41:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSPKIDataType->SPKISexp.arrayLen < xmldsigSPKIDataType_SPKISexp_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen) <= xmldsigSPKIDataType_SPKISexp_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytesLen, xmldsigSPKIDataType->SPKISexp.array[xmldsigSPKIDataType->SPKISexp.arrayLen].bytes);
								}
								xmldsigSPKIDataType->SPKISexp.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 40;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,PGPDataType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='(("http://www.w3.org/2000/09/xmldsig#":PGPKeyID,"http://www.w3.org/2000/09/xmldsig#":PGPKeyPacket{0-1},(WC[##other:"http://www.w3.org/2000/09/xmldsig#"]){0-UNBOUNDED})|("http://www.w3.org/2000/09/xmldsig#":PGPKeyPacket,(WC[##other:"http://www.w3.org/2000/09/xmldsig#"]){0-UNBOUNDED}))',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigPGPDataType(bitstream_t* stream, struct xmldsigPGPDataType* xmldsigPGPDataType) {
	int grammarID = 42;
	int done = 0;
	
	init_xmldsigPGPDataType(xmldsigPGPDataType);
	
	while(!done) {
		switch(grammarID) {
		case 42:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyID), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigPGPDataType->PGPKeyID.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigPGPDataType->PGPKeyID.bytesLen) <= xmldsigPGPDataType_PGPKeyID_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigPGPDataType->PGPKeyID.bytesLen, xmldsigPGPDataType->PGPKeyID.bytes);
							}
							xmldsigPGPDataType->PGPKeyID_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyID) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 43;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigPGPDataType->PGPKeyPacket.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigPGPDataType->PGPKeyPacket.bytesLen) <= xmldsigPGPDataType_PGPKeyPacket_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigPGPDataType->PGPKeyPacket.bytesLen, xmldsigPGPDataType->PGPKeyPacket.bytes);
							}
							xmldsigPGPDataType->PGPKeyPacket_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 44;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 43:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket), START_ELEMENT_GENERIC, END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigPGPDataType->PGPKeyPacket.bytesLen);
							if (errn == 0) {
								errn =  (xmldsigPGPDataType->PGPKeyPacket.bytesLen) <= xmldsigPGPDataType_PGPKeyPacket_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
							}
							if (errn == 0) {
								errn = decodeBytes(stream, xmldsigPGPDataType->PGPKeyPacket.bytesLen, xmldsigPGPDataType->PGPKeyPacket.bytes);
							}
							xmldsigPGPDataType->PGPKeyPacket_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 44;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 44;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 44:
			/* Element[START_ELEMENT_GENERIC, END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 44;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,X509IssuerSerialType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":X509IssuerName,"http://www.w3.org/2000/09/xmldsig#":X509SerialNumber)',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigX509IssuerSerialType(bitstream_t* stream, struct xmldsigX509IssuerSerialType* xmldsigX509IssuerSerialType) {
	int grammarID = 45;
	int done = 0;
	
	init_xmldsigX509IssuerSerialType(xmldsigX509IssuerSerialType);
	
	while(!done) {
		switch(grammarID) {
		case 45:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerName)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeUnsignedInteger16(stream, &xmldsigX509IssuerSerialType->X509IssuerName.charactersLen);
							if (errn == 0) {
								errn =  (xmldsigX509IssuerSerialType->X509IssuerName.charactersLen - 2) <= xmldsigX509IssuerSerialType_X509IssuerName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
							}
							if (errn == 0) {
								if (xmldsigX509IssuerSerialType->X509IssuerName.charactersLen >= 2) {
									xmldsigX509IssuerSerialType->X509IssuerName.charactersLen = (uint16_t)(xmldsigX509IssuerSerialType->X509IssuerName.charactersLen - 2); /* string table miss */
									errn = decodeCharacters(stream, xmldsigX509IssuerSerialType->X509IssuerName.charactersLen, xmldsigX509IssuerSerialType->X509IssuerName.characters);
								} else {
									/* string table hit */
									errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
								}
							}
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 46;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 46:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SerialNumber)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* First(xsi:type)StartTag[CHARACTERS[INTEGER]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeInteger64(stream, &xmldsigX509IssuerSerialType->X509SerialNumber);
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SerialNumber) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 11;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 11:
			/* Element[END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SignatureMethodType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":HMACOutputLength{0-1},(WC[##other:"http://www.w3.org/2000/09/xmldsig#"]){0-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigSignatureMethodType(bitstream_t* stream, struct xmldsigSignatureMethodType* xmldsigSignatureMethodType) {
	int grammarID = 47;
	int done = 0;
	
	init_xmldsigSignatureMethodType(xmldsigSignatureMethodType);
	
	while(!done) {
		switch(grammarID) {
		case 47:
			/* FirstStartTag[ATTRIBUTE[STRING](Algorithm)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignatureMethodType->Algorithm.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignatureMethodType->Algorithm.charactersLen - 2) <= xmldsigSignatureMethodType_Algorithm_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignatureMethodType->Algorithm.charactersLen >= 2) {
							xmldsigSignatureMethodType->Algorithm.charactersLen = (uint16_t)(xmldsigSignatureMethodType->Algorithm.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignatureMethodType->Algorithm.charactersLen, xmldsigSignatureMethodType->Algorithm.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					grammarID = 48;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 48:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}HMACOutputLength), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[INTEGER]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeInteger64(stream, &xmldsigSignatureMethodType->HMACOutputLength);
							xmldsigSignatureMethodType->HMACOutputLength_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}HMACOutputLength) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 19;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				case 3:
					grammarID = 49;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 19:
			/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 49:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}HMACOutputLength), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					/* FirstStartTag[CHARACTERS[INTEGER]] */
					errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
					if(errn == 0) {
						if(eventCode == 0) {
							errn = decodeInteger64(stream, &xmldsigSignatureMethodType->HMACOutputLength);
							xmldsigSignatureMethodType->HMACOutputLength_isUsed = 1u;
						} else {
							/* Second level event (e.g., xsi:type, xsi:nil, ...) */
							errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
						}
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}HMACOutputLength) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 19;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				case 3:
					grammarID = 49;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,RetrievalMethodType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":Transforms{0-1})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigRetrievalMethodType(bitstream_t* stream, struct xmldsigRetrievalMethodType* xmldsigRetrievalMethodType) {
	int grammarID = 50;
	int done = 0;
	
	init_xmldsigRetrievalMethodType(xmldsigRetrievalMethodType);
	
	while(!done) {
		switch(grammarID) {
		case 50:
			/* FirstStartTag[ATTRIBUTE[STRING](Type), ATTRIBUTE[STRING](URI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigRetrievalMethodType->Type.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigRetrievalMethodType->Type.charactersLen - 2) <= xmldsigRetrievalMethodType_Type_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigRetrievalMethodType->Type.charactersLen >= 2) {
							xmldsigRetrievalMethodType->Type.charactersLen = (uint16_t)(xmldsigRetrievalMethodType->Type.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigRetrievalMethodType->Type.charactersLen, xmldsigRetrievalMethodType->Type.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigRetrievalMethodType->Type_isUsed = 1u;
					grammarID = 51;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigRetrievalMethodType->URI.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigRetrievalMethodType->URI.charactersLen - 2) <= xmldsigRetrievalMethodType_URI_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigRetrievalMethodType->URI.charactersLen >= 2) {
							xmldsigRetrievalMethodType->URI.charactersLen = (uint16_t)(xmldsigRetrievalMethodType->URI.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigRetrievalMethodType->URI.charactersLen, xmldsigRetrievalMethodType->URI.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigRetrievalMethodType->URI_isUsed = 1u;
					grammarID = 52;
					break;
				case 2:
					errn = decode_xmldsigTransformsType(stream, &xmldsigRetrievalMethodType->Transforms);
					xmldsigRetrievalMethodType->Transforms_isUsed = 1u;
					grammarID = 11;
					break;
				case 3:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 51:
			/* StartTag[ATTRIBUTE[STRING](URI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigRetrievalMethodType->URI.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigRetrievalMethodType->URI.charactersLen - 2) <= xmldsigRetrievalMethodType_URI_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigRetrievalMethodType->URI.charactersLen >= 2) {
							xmldsigRetrievalMethodType->URI.charactersLen = (uint16_t)(xmldsigRetrievalMethodType->URI.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigRetrievalMethodType->URI.charactersLen, xmldsigRetrievalMethodType->URI.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigRetrievalMethodType->URI_isUsed = 1u;
					grammarID = 52;
					break;
				case 1:
					errn = decode_xmldsigTransformsType(stream, &xmldsigRetrievalMethodType->Transforms);
					xmldsigRetrievalMethodType->Transforms_isUsed = 1u;
					grammarID = 11;
					break;
				case 2:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 52:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigTransformsType(stream, &xmldsigRetrievalMethodType->Transforms);
					xmldsigRetrievalMethodType->Transforms_isUsed = 1u;
					grammarID = 11;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 11:
			/* Element[END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SignaturePropertyType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='((WC[##other:"http://www.w3.org/2000/09/xmldsig#"])){1-UNBOUNDED}',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigSignaturePropertyType(bitstream_t* stream, struct xmldsigSignaturePropertyType* xmldsigSignaturePropertyType) {
	int grammarID = 53;
	int done = 0;
	
	init_xmldsigSignaturePropertyType(xmldsigSignaturePropertyType);
	
	while(!done) {
		switch(grammarID) {
		case 53:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), ATTRIBUTE[STRING](Target)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignaturePropertyType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignaturePropertyType->Id.charactersLen - 2) <= xmldsigSignaturePropertyType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignaturePropertyType->Id.charactersLen >= 2) {
							xmldsigSignaturePropertyType->Id.charactersLen = (uint16_t)(xmldsigSignaturePropertyType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignaturePropertyType->Id.charactersLen, xmldsigSignaturePropertyType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigSignaturePropertyType->Id_isUsed = 1u;
					grammarID = 54;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignaturePropertyType->Target.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignaturePropertyType->Target.charactersLen - 2) <= xmldsigSignaturePropertyType_Target_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignaturePropertyType->Target.charactersLen >= 2) {
							xmldsigSignaturePropertyType->Target.charactersLen = (uint16_t)(xmldsigSignaturePropertyType->Target.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignaturePropertyType->Target.charactersLen, xmldsigSignaturePropertyType->Target.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					grammarID = 55;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 54:
			/* StartTag[ATTRIBUTE[STRING](Target)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignaturePropertyType->Target.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignaturePropertyType->Target.charactersLen - 2) <= xmldsigSignaturePropertyType_Target_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignaturePropertyType->Target.charactersLen >= 2) {
							xmldsigSignaturePropertyType->Target.charactersLen = (uint16_t)(xmldsigSignaturePropertyType->Target.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignaturePropertyType->Target.charactersLen, xmldsigSignaturePropertyType->Target.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					grammarID = 55;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 55:
			/* StartTag[START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					grammarID = 56;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 19:
			/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				case 2:
					grammarID = 19;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 56:
			/* Element[START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 19;
					break;
				case 1:
					grammarID = 56;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SignedInfoType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":CanonicalizationMethod,"http://www.w3.org/2000/09/xmldsig#":SignatureMethod,"http://www.w3.org/2000/09/xmldsig#":Reference{1-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigSignedInfoType(bitstream_t* stream, struct xmldsigSignedInfoType* xmldsigSignedInfoType) {
	int grammarID = 57;
	int done = 0;
	
	init_xmldsigSignedInfoType(xmldsigSignedInfoType);
	
	while(!done) {
		switch(grammarID) {
		case 57:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignedInfoType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignedInfoType->Id.charactersLen - 2) <= xmldsigSignedInfoType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignedInfoType->Id.charactersLen >= 2) {
							xmldsigSignedInfoType->Id.charactersLen = (uint16_t)(xmldsigSignedInfoType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignedInfoType->Id.charactersLen, xmldsigSignedInfoType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigSignedInfoType->Id_isUsed = 1u;
					grammarID = 58;
					break;
				case 1:
					errn = decode_xmldsigCanonicalizationMethodType(stream, &xmldsigSignedInfoType->CanonicalizationMethod);
					grammarID = 59;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 58:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigCanonicalizationMethodType(stream, &xmldsigSignedInfoType->CanonicalizationMethod);
					grammarID = 59;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 59:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureMethod)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decode_xmldsigSignatureMethodType(stream, &xmldsigSignedInfoType->SignatureMethod);
					grammarID = 60;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 60:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSignedInfoType->Reference.arrayLen < xmldsigSignedInfoType_Reference_ARRAY_SIZE) {
						errn = decode_xmldsigReferenceType(stream, &xmldsigSignedInfoType->Reference.array[xmldsigSignedInfoType->Reference.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 61;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 61:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigSignedInfoType->Reference.arrayLen < xmldsigSignedInfoType_Reference_ARRAY_SIZE) {
						errn = decode_xmldsigReferenceType(stream, &xmldsigSignedInfoType->Reference.array[xmldsigSignedInfoType->Reference.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 61;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,KeyInfoType',  base type name='anyType',  content type='MIXED',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":KeyName|"http://www.w3.org/2000/09/xmldsig#":KeyValue|"http://www.w3.org/2000/09/xmldsig#":RetrievalMethod|"http://www.w3.org/2000/09/xmldsig#":X509Data|"http://www.w3.org/2000/09/xmldsig#":PGPData|"http://www.w3.org/2000/09/xmldsig#":SPKIData|"http://www.w3.org/2000/09/xmldsig#":MgmtData|(WC[##other:"http://www.w3.org/2000/09/xmldsig#"])){1-UNBOUNDED}',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigKeyInfoType(bitstream_t* stream, struct xmldsigKeyInfoType* xmldsigKeyInfoType) {
	int grammarID = 62;
	int done = 0;
	
	init_xmldsigKeyInfoType(xmldsigKeyInfoType);
	
	while(!done) {
		switch(grammarID) {
		case 62:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData), START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 4, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigKeyInfoType->Id.charactersLen - 2) <= xmldsigKeyInfoType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigKeyInfoType->Id.charactersLen >= 2) {
							xmldsigKeyInfoType->Id.charactersLen = (uint16_t)(xmldsigKeyInfoType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigKeyInfoType->Id.charactersLen, xmldsigKeyInfoType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigKeyInfoType->Id_isUsed = 1u;
					grammarID = 63;
					break;
				case 1:
					if (xmldsigKeyInfoType->KeyName.arrayLen < xmldsigKeyInfoType_KeyName_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_KeyName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->KeyName.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 2:
					if (xmldsigKeyInfoType->KeyValue.arrayLen < xmldsigKeyInfoType_KeyValue_ARRAY_SIZE) {
						errn = decode_xmldsigKeyValueType(stream, &xmldsigKeyInfoType->KeyValue.array[xmldsigKeyInfoType->KeyValue.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 3:
					if (xmldsigKeyInfoType->RetrievalMethod.arrayLen < xmldsigKeyInfoType_RetrievalMethod_ARRAY_SIZE) {
						errn = decode_xmldsigRetrievalMethodType(stream, &xmldsigKeyInfoType->RetrievalMethod.array[xmldsigKeyInfoType->RetrievalMethod.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 4:
					if (xmldsigKeyInfoType->X509Data.arrayLen < xmldsigKeyInfoType_X509Data_ARRAY_SIZE) {
						errn = decode_xmldsigX509DataType(stream, &xmldsigKeyInfoType->X509Data.array[xmldsigKeyInfoType->X509Data.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 5:
					if (xmldsigKeyInfoType->PGPData.arrayLen < xmldsigKeyInfoType_PGPData_ARRAY_SIZE) {
						errn = decode_xmldsigPGPDataType(stream, &xmldsigKeyInfoType->PGPData.array[xmldsigKeyInfoType->PGPData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 6:
					if (xmldsigKeyInfoType->SPKIData.arrayLen < xmldsigKeyInfoType_SPKIData_ARRAY_SIZE) {
						errn = decode_xmldsigSPKIDataType(stream, &xmldsigKeyInfoType->SPKIData.array[xmldsigKeyInfoType->SPKIData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 7:
					if (xmldsigKeyInfoType->MgmtData.arrayLen < xmldsigKeyInfoType_MgmtData_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_MgmtData_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->MgmtData.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 8:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 64;
					break;
				case 9:
					grammarID = 65;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 63:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData), START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 4, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigKeyInfoType->KeyName.arrayLen < xmldsigKeyInfoType_KeyName_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_KeyName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->KeyName.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					if (xmldsigKeyInfoType->KeyValue.arrayLen < xmldsigKeyInfoType_KeyValue_ARRAY_SIZE) {
						errn = decode_xmldsigKeyValueType(stream, &xmldsigKeyInfoType->KeyValue.array[xmldsigKeyInfoType->KeyValue.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 2:
					if (xmldsigKeyInfoType->RetrievalMethod.arrayLen < xmldsigKeyInfoType_RetrievalMethod_ARRAY_SIZE) {
						errn = decode_xmldsigRetrievalMethodType(stream, &xmldsigKeyInfoType->RetrievalMethod.array[xmldsigKeyInfoType->RetrievalMethod.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 3:
					if (xmldsigKeyInfoType->X509Data.arrayLen < xmldsigKeyInfoType_X509Data_ARRAY_SIZE) {
						errn = decode_xmldsigX509DataType(stream, &xmldsigKeyInfoType->X509Data.array[xmldsigKeyInfoType->X509Data.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 4:
					if (xmldsigKeyInfoType->PGPData.arrayLen < xmldsigKeyInfoType_PGPData_ARRAY_SIZE) {
						errn = decode_xmldsigPGPDataType(stream, &xmldsigKeyInfoType->PGPData.array[xmldsigKeyInfoType->PGPData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 5:
					if (xmldsigKeyInfoType->SPKIData.arrayLen < xmldsigKeyInfoType_SPKIData_ARRAY_SIZE) {
						errn = decode_xmldsigSPKIDataType(stream, &xmldsigKeyInfoType->SPKIData.array[xmldsigKeyInfoType->SPKIData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 6:
					if (xmldsigKeyInfoType->MgmtData.arrayLen < xmldsigKeyInfoType_MgmtData_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_MgmtData_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->MgmtData.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 7:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 64;
					break;
				case 8:
					grammarID = 65;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 64:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData), START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 4, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigKeyInfoType->KeyName.arrayLen < xmldsigKeyInfoType_KeyName_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_KeyName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->KeyName.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					if (xmldsigKeyInfoType->KeyValue.arrayLen < xmldsigKeyInfoType_KeyValue_ARRAY_SIZE) {
						errn = decode_xmldsigKeyValueType(stream, &xmldsigKeyInfoType->KeyValue.array[xmldsigKeyInfoType->KeyValue.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 2:
					if (xmldsigKeyInfoType->RetrievalMethod.arrayLen < xmldsigKeyInfoType_RetrievalMethod_ARRAY_SIZE) {
						errn = decode_xmldsigRetrievalMethodType(stream, &xmldsigKeyInfoType->RetrievalMethod.array[xmldsigKeyInfoType->RetrievalMethod.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 3:
					if (xmldsigKeyInfoType->X509Data.arrayLen < xmldsigKeyInfoType_X509Data_ARRAY_SIZE) {
						errn = decode_xmldsigX509DataType(stream, &xmldsigKeyInfoType->X509Data.array[xmldsigKeyInfoType->X509Data.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 4:
					if (xmldsigKeyInfoType->PGPData.arrayLen < xmldsigKeyInfoType_PGPData_ARRAY_SIZE) {
						errn = decode_xmldsigPGPDataType(stream, &xmldsigKeyInfoType->PGPData.array[xmldsigKeyInfoType->PGPData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 5:
					if (xmldsigKeyInfoType->SPKIData.arrayLen < xmldsigKeyInfoType_SPKIData_ARRAY_SIZE) {
						errn = decode_xmldsigSPKIDataType(stream, &xmldsigKeyInfoType->SPKIData.array[xmldsigKeyInfoType->SPKIData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 6:
					if (xmldsigKeyInfoType->MgmtData.arrayLen < xmldsigKeyInfoType_MgmtData_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_MgmtData_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->MgmtData.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 7:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 64;
					break;
				case 8:
					done = 1;
					grammarID = 3;
					break;
				case 9:
					grammarID = 64;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 65:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData), START_ELEMENT_GENERIC, CHARACTERS_GENERIC[STRING]] */
			errn = decodeNBitUnsignedInteger(stream, 4, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigKeyInfoType->KeyName.arrayLen < xmldsigKeyInfoType_KeyName_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_KeyName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].charactersLen, xmldsigKeyInfoType->KeyName.array[xmldsigKeyInfoType->KeyName.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->KeyName.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 1:
					if (xmldsigKeyInfoType->KeyValue.arrayLen < xmldsigKeyInfoType_KeyValue_ARRAY_SIZE) {
						errn = decode_xmldsigKeyValueType(stream, &xmldsigKeyInfoType->KeyValue.array[xmldsigKeyInfoType->KeyValue.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 2:
					if (xmldsigKeyInfoType->RetrievalMethod.arrayLen < xmldsigKeyInfoType_RetrievalMethod_ARRAY_SIZE) {
						errn = decode_xmldsigRetrievalMethodType(stream, &xmldsigKeyInfoType->RetrievalMethod.array[xmldsigKeyInfoType->RetrievalMethod.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 3:
					if (xmldsigKeyInfoType->X509Data.arrayLen < xmldsigKeyInfoType_X509Data_ARRAY_SIZE) {
						errn = decode_xmldsigX509DataType(stream, &xmldsigKeyInfoType->X509Data.array[xmldsigKeyInfoType->X509Data.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 4:
					if (xmldsigKeyInfoType->PGPData.arrayLen < xmldsigKeyInfoType_PGPData_ARRAY_SIZE) {
						errn = decode_xmldsigPGPDataType(stream, &xmldsigKeyInfoType->PGPData.array[xmldsigKeyInfoType->PGPData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 5:
					if (xmldsigKeyInfoType->SPKIData.arrayLen < xmldsigKeyInfoType_SPKIData_ARRAY_SIZE) {
						errn = decode_xmldsigSPKIDataType(stream, &xmldsigKeyInfoType->SPKIData.array[xmldsigKeyInfoType->SPKIData.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 64;
					break;
				case 6:
					if (xmldsigKeyInfoType->MgmtData.arrayLen < xmldsigKeyInfoType_MgmtData_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2) <= xmldsigKeyInfoType_MgmtData_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen >= 2) {
										xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen = (uint16_t)(xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].charactersLen, xmldsigKeyInfoType->MgmtData.array[xmldsigKeyInfoType->MgmtData.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigKeyInfoType->MgmtData.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 64;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 7:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 64;
					break;
				case 8:
					grammarID = 65;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,ManifestType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='("http://www.w3.org/2000/09/xmldsig#":Reference{1-UNBOUNDED})',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigManifestType(bitstream_t* stream, struct xmldsigManifestType* xmldsigManifestType) {
	int grammarID = 66;
	int done = 0;
	
	init_xmldsigManifestType(xmldsigManifestType);
	
	while(!done) {
		switch(grammarID) {
		case 66:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference)] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigManifestType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigManifestType->Id.charactersLen - 2) <= xmldsigManifestType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigManifestType->Id.charactersLen >= 2) {
							xmldsigManifestType->Id.charactersLen = (uint16_t)(xmldsigManifestType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigManifestType->Id.charactersLen, xmldsigManifestType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigManifestType->Id_isUsed = 1u;
					grammarID = 67;
					break;
				case 1:
					if (xmldsigManifestType->Reference.arrayLen < xmldsigManifestType_Reference_ARRAY_SIZE) {
						errn = decode_xmldsigReferenceType(stream, &xmldsigManifestType->Reference.array[xmldsigManifestType->Reference.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 61;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 67:
			/* StartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference)] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigManifestType->Reference.arrayLen < xmldsigManifestType_Reference_ARRAY_SIZE) {
						errn = decode_xmldsigReferenceType(stream, &xmldsigManifestType->Reference.array[xmldsigManifestType->Reference.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 61;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 61:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference), END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigManifestType->Reference.arrayLen < xmldsigManifestType_Reference_ARRAY_SIZE) {
						errn = decode_xmldsigReferenceType(stream, &xmldsigManifestType->Reference.array[xmldsigManifestType->Reference.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 61;
					break;
				case 1:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,SignatureValueType',  base type name='base64Binary',  content type='SIMPLE',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  derivedBy='EXTENSION'.  */
static int decode_xmldsigSignatureValueType(bitstream_t* stream, struct xmldsigSignatureValueType* xmldsigSignatureValueType) {
	int grammarID = 68;
	int done = 0;
	
	init_xmldsigSignatureValueType(xmldsigSignatureValueType);
	
	while(!done) {
		switch(grammarID) {
		case 68:
			/* FirstStartTag[ATTRIBUTE[STRING](Id), CHARACTERS[BINARY_BASE64]] */
			errn = decodeNBitUnsignedInteger(stream, 2, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignatureValueType->Id.charactersLen);
					if (errn == 0) {
						errn =  (xmldsigSignatureValueType->Id.charactersLen - 2) <= xmldsigSignatureValueType_Id_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
					}
					if (errn == 0) {
						if (xmldsigSignatureValueType->Id.charactersLen >= 2) {
							xmldsigSignatureValueType->Id.charactersLen = (uint16_t)(xmldsigSignatureValueType->Id.charactersLen - 2); /* string table miss */
							errn = decodeCharacters(stream, xmldsigSignatureValueType->Id.charactersLen, xmldsigSignatureValueType->Id.characters);
						} else {
							/* string table hit */
							errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
						}
					}
					xmldsigSignatureValueType->Id_isUsed = 1u;
					grammarID = 69;
					break;
				case 1:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignatureValueType->CONTENT.bytesLen);
					if (errn == 0) {
						errn =  (xmldsigSignatureValueType->CONTENT.bytesLen) <= xmldsigSignatureValueType_CONTENT_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
					}
					if (errn == 0) {
						errn = decodeBytes(stream, xmldsigSignatureValueType->CONTENT.bytesLen, xmldsigSignatureValueType->CONTENT.bytes);
					}
					grammarID = 11;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 69:
			/* StartTag[CHARACTERS[BINARY_BASE64]] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					errn = decodeUnsignedInteger16(stream, &xmldsigSignatureValueType->CONTENT.bytesLen);
					if (errn == 0) {
						errn =  (xmldsigSignatureValueType->CONTENT.bytesLen) <= xmldsigSignatureValueType_CONTENT_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
					}
					if (errn == 0) {
						errn = decodeBytes(stream, xmldsigSignatureValueType->CONTENT.bytesLen, xmldsigSignatureValueType->CONTENT.bytes);
					}
					grammarID = 11;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 11:
			/* Element[END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}

/* Complex type name='http://www.w3.org/2000/09/xmldsig#,X509DataType',  base type name='anyType',  content type='ELEMENT',  isAbstract='false',  hasTypeId='false',  final='0',  block='0',  particle='(("http://www.w3.org/2000/09/xmldsig#":X509IssuerSerial|"http://www.w3.org/2000/09/xmldsig#":X509SKI|"http://www.w3.org/2000/09/xmldsig#":X509SubjectName|"http://www.w3.org/2000/09/xmldsig#":X509Certificate|"http://www.w3.org/2000/09/xmldsig#":X509CRL|(WC[##other:"http://www.w3.org/2000/09/xmldsig#"]))){1-UNBOUNDED}',  derivedBy='RESTRICTION'.  */
static int decode_xmldsigX509DataType(bitstream_t* stream, struct xmldsigX509DataType* xmldsigX509DataType) {
	int grammarID = 70;
	int done = 0;
	
	init_xmldsigX509DataType(xmldsigX509DataType);
	
	while(!done) {
		switch(grammarID) {
		case 70:
			/* FirstStartTag[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SKI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SubjectName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Certificate), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509CRL), START_ELEMENT_GENERIC] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigX509DataType->X509IssuerSerial.arrayLen < xmldsigX509DataType_X509IssuerSerial_ARRAY_SIZE) {
						errn = decode_xmldsigX509IssuerSerialType(stream, &xmldsigX509DataType->X509IssuerSerial.array[xmldsigX509DataType->X509IssuerSerial.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 71;
					break;
				case 1:
					if (xmldsigX509DataType->X509SKI.arrayLen < xmldsigX509DataType_X509SKI_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytesLen) <= xmldsigX509DataType_X509SKI_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytesLen, xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytes);
								}
								xmldsigX509DataType->X509SKI.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SKI) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 2:
					if (xmldsigX509DataType->X509SubjectName.arrayLen < xmldsigX509DataType_X509SubjectName_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen - 2) <= xmldsigX509DataType_X509SubjectName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen >= 2) {
										xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen = (uint16_t)(xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen, xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigX509DataType->X509SubjectName.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SubjectName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 3:
					if (xmldsigX509DataType->X509Certificate.arrayLen < xmldsigX509DataType_X509Certificate_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytesLen) <= xmldsigX509DataType_X509Certificate_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytesLen, xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytes);
								}
								xmldsigX509DataType->X509Certificate.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Certificate) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 4:
					if (xmldsigX509DataType->X509CRL.arrayLen < xmldsigX509DataType_X509CRL_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytesLen) <= xmldsigX509DataType_X509CRL_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytesLen, xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytes);
								}
								xmldsigX509DataType->X509CRL.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509CRL) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 5:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 71;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		case 71:
			/* Element[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SKI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SubjectName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Certificate), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509CRL), START_ELEMENT_GENERIC, END_ELEMENT] */
			errn = decodeNBitUnsignedInteger(stream, 3, &eventCode);
			if (errn == 0) {
				switch(eventCode) {
				case 0:
					if (xmldsigX509DataType->X509IssuerSerial.arrayLen < xmldsigX509DataType_X509IssuerSerial_ARRAY_SIZE) {
						errn = decode_xmldsigX509IssuerSerialType(stream, &xmldsigX509DataType->X509IssuerSerial.array[xmldsigX509DataType->X509IssuerSerial.arrayLen++]);
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					grammarID = 71;
					break;
				case 1:
					if (xmldsigX509DataType->X509SKI.arrayLen < xmldsigX509DataType_X509SKI_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytesLen) <= xmldsigX509DataType_X509SKI_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytesLen, xmldsigX509DataType->X509SKI.array[xmldsigX509DataType->X509SKI.arrayLen].bytes);
								}
								xmldsigX509DataType->X509SKI.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SKI) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 2:
					if (xmldsigX509DataType->X509SubjectName.arrayLen < xmldsigX509DataType_X509SubjectName_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen - 2) <= xmldsigX509DataType_X509SubjectName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
								}
								if (errn == 0) {
									if (xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen >= 2) {
										xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen = (uint16_t)(xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen - 2); /* string table miss */
										errn = decodeCharacters(stream, xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].charactersLen, xmldsigX509DataType->X509SubjectName.array[xmldsigX509DataType->X509SubjectName.arrayLen].characters);
									} else {
										/* string table hit */
										errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
									}
								}
								xmldsigX509DataType->X509SubjectName.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SubjectName) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 3:
					if (xmldsigX509DataType->X509Certificate.arrayLen < xmldsigX509DataType_X509Certificate_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytesLen) <= xmldsigX509DataType_X509Certificate_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytesLen, xmldsigX509DataType->X509Certificate.array[xmldsigX509DataType->X509Certificate.arrayLen].bytes);
								}
								xmldsigX509DataType->X509Certificate.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Certificate) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 4:
					if (xmldsigX509DataType->X509CRL.arrayLen < xmldsigX509DataType_X509CRL_ARRAY_SIZE) {
						/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(errn == 0) {
							if(eventCode == 0) {
								errn = decodeUnsignedInteger16(stream, &xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytesLen);
								if (errn == 0) {
									errn =  (xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytesLen) <= xmldsigX509DataType_X509CRL_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
								}
								if (errn == 0) {
									errn = decodeBytes(stream, xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytesLen, xmldsigX509DataType->X509CRL.array[xmldsigX509DataType->X509CRL.arrayLen].bytes);
								}
								xmldsigX509DataType->X509CRL.arrayLen++;
							} else {
								/* Second level event (e.g., xsi:type, xsi:nil, ...) */
								errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
							}
						}
					} else { 
						errn = EXI_ERROR_OUT_OF_BOUNDS;
					}
					if(errn == 0) {
						/* valid EE for simple element START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509CRL) ? */
						errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
						if(eventCode == 0) {
						grammarID = 71;
						} else {
							errn = EXI_DEVIANT_SUPPORT_NOT_DEPLOYED; /* or also typecast and nillable */
						}
					}
					break;
				case 5:
					errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					/* TODO unsupported event : START_ELEMENT_GENERIC */
					grammarID = 71;
					break;
				case 6:
					done = 1;
					grammarID = 3;
					break;
				default:
					errn = EXI_ERROR_UNKOWN_EVENT_CODE;
					break;
				}
			}
			break;
		default:
			errn = EXI_ERROR_UNKOWN_GRAMMAR_ID;
			break;
		}
		if(errn) {
			done = 1;
		}
	}
	return errn;
}




int decode_xmldsigExiDocument(bitstream_t* stream, struct xmldsigEXIDocument* exiDoc) {
	errn = readEXIHeader(stream);

	if(errn == 0) {
		/* DocContent[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DSAKeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyInfo), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Manifest), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Object), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RSAKeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Signature), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperties), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignedInfo), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transform), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data), START_ELEMENT_GENERIC] */
		init_xmldsigEXIDocument(exiDoc);
		errn = decodeNBitUnsignedInteger(stream, 5, &eventCode);
		if(errn == 0) {
			switch(eventCode) {
			case 0:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod) */
				errn = decode_xmldsigCanonicalizationMethodType(stream, &exiDoc->CanonicalizationMethod);
				exiDoc->CanonicalizationMethod_isUsed = 1u;
				break;
			case 1:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DSAKeyValue) */
				errn = decode_xmldsigDSAKeyValueType(stream, &exiDoc->DSAKeyValue);
				exiDoc->DSAKeyValue_isUsed = 1u;
				break;
			case 2:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod) */
				errn = decode_xmldsigDigestMethodType(stream, &exiDoc->DigestMethod);
				exiDoc->DigestMethod_isUsed = 1u;
				break;
			case 3:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestValue) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiDoc->DigestValue.bytesLen);
						if (errn == 0) {
							errn =  (exiDoc->DigestValue.bytesLen) <= EXIDocument_DigestValue_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiDoc->DigestValue.bytesLen, exiDoc->DigestValue.bytes);
						}
						exiDoc->DigestValue_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 4:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyInfo) */
				errn = decode_xmldsigKeyInfoType(stream, &exiDoc->KeyInfo);
				exiDoc->KeyInfo_isUsed = 1u;
				break;
			case 5:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiDoc->KeyName.charactersLen);
						if (errn == 0) {
							errn =  (exiDoc->KeyName.charactersLen - 2) <= EXIDocument_KeyName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiDoc->KeyName.charactersLen >= 2) {
								exiDoc->KeyName.charactersLen = (uint16_t)(exiDoc->KeyName.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiDoc->KeyName.charactersLen, exiDoc->KeyName.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiDoc->KeyName_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 6:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue) */
				errn = decode_xmldsigKeyValueType(stream, &exiDoc->KeyValue);
				exiDoc->KeyValue_isUsed = 1u;
				break;
			case 7:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Manifest) */
				errn = decode_xmldsigManifestType(stream, &exiDoc->Manifest);
				exiDoc->Manifest_isUsed = 1u;
				break;
			case 8:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiDoc->MgmtData.charactersLen);
						if (errn == 0) {
							errn =  (exiDoc->MgmtData.charactersLen - 2) <= EXIDocument_MgmtData_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiDoc->MgmtData.charactersLen >= 2) {
								exiDoc->MgmtData.charactersLen = (uint16_t)(exiDoc->MgmtData.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiDoc->MgmtData.charactersLen, exiDoc->MgmtData.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiDoc->MgmtData_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 9:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Object) */
				errn = decode_xmldsigObjectType(stream, &exiDoc->Object);
				exiDoc->Object_isUsed = 1u;
				break;
			case 10:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData) */
				errn = decode_xmldsigPGPDataType(stream, &exiDoc->PGPData);
				exiDoc->PGPData_isUsed = 1u;
				break;
			case 11:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RSAKeyValue) */
				errn = decode_xmldsigRSAKeyValueType(stream, &exiDoc->RSAKeyValue);
				exiDoc->RSAKeyValue_isUsed = 1u;
				break;
			case 12:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference) */
				errn = decode_xmldsigReferenceType(stream, &exiDoc->Reference);
				exiDoc->Reference_isUsed = 1u;
				break;
			case 13:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod) */
				errn = decode_xmldsigRetrievalMethodType(stream, &exiDoc->RetrievalMethod);
				exiDoc->RetrievalMethod_isUsed = 1u;
				break;
			case 14:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData) */
				errn = decode_xmldsigSPKIDataType(stream, &exiDoc->SPKIData);
				exiDoc->SPKIData_isUsed = 1u;
				break;
			case 15:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Signature) */
				errn = decode_xmldsigSignatureType(stream, &exiDoc->Signature);
				exiDoc->Signature_isUsed = 1u;
				break;
			case 16:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureMethod) */
				errn = decode_xmldsigSignatureMethodType(stream, &exiDoc->SignatureMethod);
				exiDoc->SignatureMethod_isUsed = 1u;
				break;
			case 17:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperties) */
				errn = decode_xmldsigSignaturePropertiesType(stream, &exiDoc->SignatureProperties);
				exiDoc->SignatureProperties_isUsed = 1u;
				break;
			case 18:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty) */
				errn = decode_xmldsigSignaturePropertyType(stream, &exiDoc->SignatureProperty);
				exiDoc->SignatureProperty_isUsed = 1u;
				break;
			case 19:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureValue) */
				errn = decode_xmldsigSignatureValueType(stream, &exiDoc->SignatureValue);
				exiDoc->SignatureValue_isUsed = 1u;
				break;
			case 20:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignedInfo) */
				errn = decode_xmldsigSignedInfoType(stream, &exiDoc->SignedInfo);
				exiDoc->SignedInfo_isUsed = 1u;
				break;
			case 21:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transform) */
				errn = decode_xmldsigTransformType(stream, &exiDoc->Transform);
				exiDoc->Transform_isUsed = 1u;
				break;
			case 22:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms) */
				errn = decode_xmldsigTransformsType(stream, &exiDoc->Transforms);
				exiDoc->Transforms_isUsed = 1u;
				break;
			case 23:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data) */
				errn = decode_xmldsigX509DataType(stream, &exiDoc->X509Data);
				exiDoc->X509Data_isUsed = 1u;
				break;
			default:
				errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
				break;
			}
		}

	}

	return errn;
}

#if DEPLOY_XMLDSIG_CODEC_FRAGMENT == SUPPORT_YES
int decode_xmldsigExiFragment(bitstream_t* stream, struct xmldsigEXIFragment* exiFrag) {
	errn = readEXIHeader(stream);

	if(errn == 0) {
		/* FragmentContent[START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DSAKeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Exponent), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}G), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}HMACOutputLength), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}J), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyInfo), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Manifest), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Modulus), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Object), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}P), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyID), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PgenCounter), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Q), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RSAKeyValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Seed), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Signature), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureMethod), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperties), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureValue), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignedInfo), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transform), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509CRL), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Certificate), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SKI), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SerialNumber), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SubjectName), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}XPath), START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y), START_ELEMENT_GENERIC, END_DOCUMENT] */
		init_xmldsigEXIFragment(exiFrag);
		errn = decodeNBitUnsignedInteger(stream, 6, &eventCode);
		if(errn == 0) {
			switch(eventCode) {
			case 0:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod) */
				errn = decode_xmldsigCanonicalizationMethodType(stream, &exiFrag->CanonicalizationMethod);
				exiFrag->CanonicalizationMethod_isUsed = 1u;
				break;
			case 1:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DSAKeyValue) */
				errn = decode_xmldsigDSAKeyValueType(stream, &exiFrag->DSAKeyValue);
				exiFrag->DSAKeyValue_isUsed = 1u;
				break;
			case 2:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestMethod) */
				errn = decode_xmldsigDigestMethodType(stream, &exiFrag->DigestMethod);
				exiFrag->DigestMethod_isUsed = 1u;
				break;
			case 3:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}DigestValue) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->DigestValue.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->DigestValue.bytesLen) <= EXIFragment_DigestValue_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->DigestValue.bytesLen, exiFrag->DigestValue.bytes);
						}
						exiFrag->DigestValue_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 4:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Exponent) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->Exponent.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->Exponent.bytesLen) <= EXIFragment_Exponent_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->Exponent.bytesLen, exiFrag->Exponent.bytes);
						}
						exiFrag->Exponent_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 5:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}G) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->G.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->G.bytesLen) <= EXIFragment_G_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->G.bytesLen, exiFrag->G.bytes);
						}
						exiFrag->G_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 6:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}HMACOutputLength) */
				/* FirstStartTag[CHARACTERS[INTEGER]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeInteger64(stream, &exiFrag->HMACOutputLength);
						exiFrag->HMACOutputLength_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 7:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}J) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->J.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->J.bytesLen) <= EXIFragment_J_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->J.bytesLen, exiFrag->J.bytes);
						}
						exiFrag->J_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 8:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyInfo) */
				errn = decode_xmldsigKeyInfoType(stream, &exiFrag->KeyInfo);
				exiFrag->KeyInfo_isUsed = 1u;
				break;
			case 9:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyName) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->KeyName.charactersLen);
						if (errn == 0) {
							errn =  (exiFrag->KeyName.charactersLen - 2) <= EXIFragment_KeyName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiFrag->KeyName.charactersLen >= 2) {
								exiFrag->KeyName.charactersLen = (uint16_t)(exiFrag->KeyName.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiFrag->KeyName.charactersLen, exiFrag->KeyName.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiFrag->KeyName_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 10:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}KeyValue) */
				errn = decode_xmldsigKeyValueType(stream, &exiFrag->KeyValue);
				exiFrag->KeyValue_isUsed = 1u;
				break;
			case 11:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Manifest) */
				errn = decode_xmldsigManifestType(stream, &exiFrag->Manifest);
				exiFrag->Manifest_isUsed = 1u;
				break;
			case 12:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}MgmtData) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->MgmtData.charactersLen);
						if (errn == 0) {
							errn =  (exiFrag->MgmtData.charactersLen - 2) <= EXIFragment_MgmtData_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiFrag->MgmtData.charactersLen >= 2) {
								exiFrag->MgmtData.charactersLen = (uint16_t)(exiFrag->MgmtData.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiFrag->MgmtData.charactersLen, exiFrag->MgmtData.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiFrag->MgmtData_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 13:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Modulus) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->Modulus.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->Modulus.bytesLen) <= EXIFragment_Modulus_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->Modulus.bytesLen, exiFrag->Modulus.bytes);
						}
						exiFrag->Modulus_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 14:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Object) */
				errn = decode_xmldsigObjectType(stream, &exiFrag->Object);
				exiFrag->Object_isUsed = 1u;
				break;
			case 15:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}P) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->P.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->P.bytesLen) <= EXIFragment_P_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->P.bytesLen, exiFrag->P.bytes);
						}
						exiFrag->P_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 16:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPData) */
				errn = decode_xmldsigPGPDataType(stream, &exiFrag->PGPData);
				exiFrag->PGPData_isUsed = 1u;
				break;
			case 17:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyID) */
				/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->PGPKeyID.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->PGPKeyID.bytesLen) <= EXIFragment_PGPKeyID_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->PGPKeyID.bytesLen, exiFrag->PGPKeyID.bytes);
						}
						exiFrag->PGPKeyID_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 18:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket) */
				errn = EXI_UNSUPPORTED_FRAGMENT_ELEMENT; /* overlapping name PGPKeyPacket */
				break;
			case 19:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}PgenCounter) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->PgenCounter.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->PgenCounter.bytesLen) <= EXIFragment_PgenCounter_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->PgenCounter.bytesLen, exiFrag->PgenCounter.bytes);
						}
						exiFrag->PgenCounter_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 20:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Q) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->Q.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->Q.bytesLen) <= EXIFragment_Q_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->Q.bytesLen, exiFrag->Q.bytes);
						}
						exiFrag->Q_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 21:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RSAKeyValue) */
				errn = decode_xmldsigRSAKeyValueType(stream, &exiFrag->RSAKeyValue);
				exiFrag->RSAKeyValue_isUsed = 1u;
				break;
			case 22:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Reference) */
				errn = decode_xmldsigReferenceType(stream, &exiFrag->Reference);
				exiFrag->Reference_isUsed = 1u;
				break;
			case 23:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}RetrievalMethod) */
				errn = decode_xmldsigRetrievalMethodType(stream, &exiFrag->RetrievalMethod);
				exiFrag->RetrievalMethod_isUsed = 1u;
				break;
			case 24:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKIData) */
				errn = decode_xmldsigSPKIDataType(stream, &exiFrag->SPKIData);
				exiFrag->SPKIData_isUsed = 1u;
				break;
			case 25:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SPKISexp) */
				/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->SPKISexp.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->SPKISexp.bytesLen) <= EXIFragment_SPKISexp_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->SPKISexp.bytesLen, exiFrag->SPKISexp.bytes);
						}
						exiFrag->SPKISexp_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 26:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Seed) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->Seed.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->Seed.bytesLen) <= EXIFragment_Seed_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->Seed.bytesLen, exiFrag->Seed.bytes);
						}
						exiFrag->Seed_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 27:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Signature) */
				errn = decode_xmldsigSignatureType(stream, &exiFrag->Signature);
				exiFrag->Signature_isUsed = 1u;
				break;
			case 28:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureMethod) */
				errn = decode_xmldsigSignatureMethodType(stream, &exiFrag->SignatureMethod);
				exiFrag->SignatureMethod_isUsed = 1u;
				break;
			case 29:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperties) */
				errn = decode_xmldsigSignaturePropertiesType(stream, &exiFrag->SignatureProperties);
				exiFrag->SignatureProperties_isUsed = 1u;
				break;
			case 30:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureProperty) */
				errn = decode_xmldsigSignaturePropertyType(stream, &exiFrag->SignatureProperty);
				exiFrag->SignatureProperty_isUsed = 1u;
				break;
			case 31:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignatureValue) */
				errn = decode_xmldsigSignatureValueType(stream, &exiFrag->SignatureValue);
				exiFrag->SignatureValue_isUsed = 1u;
				break;
			case 32:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}SignedInfo) */
				errn = decode_xmldsigSignedInfoType(stream, &exiFrag->SignedInfo);
				exiFrag->SignedInfo_isUsed = 1u;
				break;
			case 33:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transform) */
				errn = decode_xmldsigTransformType(stream, &exiFrag->Transform);
				exiFrag->Transform_isUsed = 1u;
				break;
			case 34:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Transforms) */
				errn = decode_xmldsigTransformsType(stream, &exiFrag->Transforms);
				exiFrag->Transforms_isUsed = 1u;
				break;
			case 35:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509CRL) */
				/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->X509CRL.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->X509CRL.bytesLen) <= EXIFragment_X509CRL_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->X509CRL.bytesLen, exiFrag->X509CRL.bytes);
						}
						exiFrag->X509CRL_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 36:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Certificate) */
				/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->X509Certificate.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->X509Certificate.bytesLen) <= EXIFragment_X509Certificate_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->X509Certificate.bytesLen, exiFrag->X509Certificate.bytes);
						}
						exiFrag->X509Certificate_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 37:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509Data) */
				errn = decode_xmldsigX509DataType(stream, &exiFrag->X509Data);
				exiFrag->X509Data_isUsed = 1u;
				break;
			case 38:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerName) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->X509IssuerName.charactersLen);
						if (errn == 0) {
							errn =  (exiFrag->X509IssuerName.charactersLen - 2) <= EXIFragment_X509IssuerName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiFrag->X509IssuerName.charactersLen >= 2) {
								exiFrag->X509IssuerName.charactersLen = (uint16_t)(exiFrag->X509IssuerName.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiFrag->X509IssuerName.charactersLen, exiFrag->X509IssuerName.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiFrag->X509IssuerName_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 39:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial) */
				errn = decode_xmldsigX509IssuerSerialType(stream, &exiFrag->X509IssuerSerial);
				exiFrag->X509IssuerSerial_isUsed = 1u;
				break;
			case 40:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SKI) */
				/* First(xsi:type)StartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->X509SKI.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->X509SKI.bytesLen) <= EXIFragment_X509SKI_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->X509SKI.bytesLen, exiFrag->X509SKI.bytes);
						}
						exiFrag->X509SKI_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 41:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SerialNumber) */
				/* First(xsi:type)StartTag[CHARACTERS[INTEGER]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeInteger64(stream, &exiFrag->X509SerialNumber);
						exiFrag->X509SerialNumber_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 42:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}X509SubjectName) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->X509SubjectName.charactersLen);
						if (errn == 0) {
							errn =  (exiFrag->X509SubjectName.charactersLen - 2) <= EXIFragment_X509SubjectName_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiFrag->X509SubjectName.charactersLen >= 2) {
								exiFrag->X509SubjectName.charactersLen = (uint16_t)(exiFrag->X509SubjectName.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiFrag->X509SubjectName.charactersLen, exiFrag->X509SubjectName.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiFrag->X509SubjectName_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 43:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}XPath) */
				/* First(xsi:type)StartTag[CHARACTERS[STRING]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->XPath.charactersLen);
						if (errn == 0) {
							errn =  (exiFrag->XPath.charactersLen - 2) <= EXIFragment_XPath_CHARACTERS_SIZE ? 0 : EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
						}
						if (errn == 0) {
							if (exiFrag->XPath.charactersLen >= 2) {
								exiFrag->XPath.charactersLen = (uint16_t)(exiFrag->XPath.charactersLen - 2); /* string table miss */
								errn = decodeCharacters(stream, exiFrag->XPath.charactersLen, exiFrag->XPath.characters);
							} else {
								/* string table hit */
								errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
							}
						}
						exiFrag->XPath_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			case 44:
				/* START_ELEMENT({http://www.w3.org/2000/09/xmldsig#}Y) */
				/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode);
				if(errn == 0) {
					if(eventCode == 0) {
						errn = decodeUnsignedInteger16(stream, &exiFrag->Y.bytesLen);
						if (errn == 0) {
							errn =  (exiFrag->Y.bytesLen) <= EXIFragment_Y_BYTES_SIZE ? 0 : EXI_ERROR_OUT_OF_BYTE_BUFFER;
						}
						if (errn == 0) {
							errn = decodeBytes(stream, exiFrag->Y.bytesLen, exiFrag->Y.bytes);
						}
						exiFrag->Y_isUsed = 1u;
					} else {
						/* Second level event (e.g., xsi:type, xsi:nil, ...) */
						errn = EXI_UNSUPPORTED_EVENT_CODE_CHARACTERISTICS;
					}
				}
				break;
			default:
				errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
				break;
			}
		}
		if(errn == 0) {
			/* EndDocument */
			errn = decodeNBitUnsignedInteger(stream, 6, &eventCode);
			if (eventCode != 46) {
				errn = EXI_UNSUPPORTED_FRAGMENT_ELEMENT;
			}
		}

	}

	return errn;
}
#endif /* DEPLOY_XMLDSIG_CODEC_FRAGMENT */

#endif /* DEPLOY_XMLDSIG_CODEC */

#endif

