
/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Sebastian.Kaebisch.EXT@siemens.com
 * @version 0.6
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXISeGen</p>
 *
 ********************************************************************/


#include "appHand_service.h"
#include "appHand_dataTypes.h"


#include "appHand_dataTypes.h"
#include "StringTable.h"
#include "EXITypes.h"
#include "appHand_EXIEncoder.h"
#include <string.h>
 
 
 
 

static int serialize_AppProtocolType(struct AppProtocolType* type, struct EXIDatabinder* service)
{
	
			/* element ID assignment of ProtocolNamespace*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=2;	


			/* encode start element ProtocolNamespace */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_STRING;
			service->val.string.len = type->ProtocolNamespace.arraylen.data;
			memcpy(service->val.string.codepoints, type->ProtocolNamespace.data,type->ProtocolNamespace.arraylen.data*sizeof(uint32_t));
						
		
			/* encode character  ProtocolNamespace */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
					return -1;
			}
			
			 
			/* encode end element of ProtocolNamespace */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

			
			/* element ID assignment of VersionNumberMajor*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=5;	


			/* encode start element VersionNumberMajor */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_UNSIGNED_INTEGER;
			service->val.integer.val.uint32=type->VersionNumberMajor;
			service->val.integer.type = EXI_UNSIGNED_INTEGER_32;
			
			/* encode character  VersionNumberMajor */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
				return -1;
			}
				
			 
			/* encode end element of VersionNumberMajor */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

			
			/* element ID assignment of VersionNumberMinor*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=6;	


			/* encode start element VersionNumberMinor */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_UNSIGNED_INTEGER;
			service->val.integer.val.uint32=type->VersionNumberMinor;
			service->val.integer.type = EXI_UNSIGNED_INTEGER_32;
			
			/* encode character  VersionNumberMinor */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
				return -1;
			}
				
			 
			/* encode end element of VersionNumberMinor */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

			
			/* element ID assignment of SchemaID*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=4;	


			/* encode start element SchemaID */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			service->val.integer.val.uint8=type->SchemaID;
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  SchemaID */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
				return -1;
			}
				
			 
			/* encode end element of SchemaID */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

			
			/* element ID assignment of Priority*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=1;	


			/* encode start element Priority */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			service->val.integer.val.uint8=type->Priority;
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  Priority */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
				return -1;
			}
				
			 
			/* encode end element of Priority */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		

	return 0;			
}


static int serialize_AnonType_supportedAppProtocolReq(struct AnonType_supportedAppProtocolReq* type, struct EXIDatabinder* service)
{

			size_t i_loop;
	
	for(i_loop=0;i_loop < type->arraylen.AppProtocol;i_loop++)
		{
			
			/* element ID assignment of AppProtocol*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=0;	


			/* encode start element AppProtocol */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			/* encode children of AppProtocol */
			if(serialize_AppProtocolType(&(type->AppProtocol[i_loop]),service))
			{
				return -1;
			}
			
			 
			/* encode end element of AppProtocol */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}


static int serialize_AnonType_supportedAppProtocolRes(struct AnonType_supportedAppProtocolRes* type, struct EXIDatabinder* service)
{
	
			/* element ID assignment of ResponseCode*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=3;	


			/* encode start element ResponseCode */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_ENUMERATION;
			service->val.enumeration=type->ResponseCode;
			
			/* encode character  ResponseCode */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
				return -1;
			}
				
			 
			/* encode end element of ResponseCode */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		
	if(type->isused.SchemaID)
		{		
					
			/* element ID assignment of SchemaID*/
			service->eqn.namespaceURI=0;			
			service->eqn.localPart=4;	


			/* encode start element SchemaID */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			service->val.integer.val.uint8=type->SchemaID;
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  SchemaID */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val)))
			{
				 
				return -1;
			}
				
			 
			/* encode end element of SchemaID */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}


static int serialize_EXIDocumentType(struct EXIDocumentType_appHand* type, struct EXIDatabinder* service)
{

	if(type->isused.supportedAppProtocolReq)
		{		
					
			/* element ID assignment of supportedAppProtocolReq*/
			service->eqn.namespaceURI=4;			
			service->eqn.localPart=6;	


			/* encode start element supportedAppProtocolReq */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
						
			/* encode children of supportedAppProtocolReq */
			if(serialize_AnonType_supportedAppProtocolReq( (type->supportedAppProtocolReq),service))
			{
				return -1;
			}

			
			 
			/* encode end element of supportedAppProtocolReq */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));
			return 0;

		}
				
	if(type->isused.supportedAppProtocolRes)
		{		
					
			/* element ID assignment of supportedAppProtocolRes*/
			service->eqn.namespaceURI=4;			
			service->eqn.localPart=7;	


			/* encode start element supportedAppProtocolRes */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), &(service->eqn)))
			{
					return -1;
			}
						
			/* encode children of supportedAppProtocolRes */
			if(serialize_AnonType_supportedAppProtocolRes( (type->supportedAppProtocolRes),service))
			{
				return -1;
			}

			
			 
			/* encode end element of supportedAppProtocolRes */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}

 
 
 
 
 
 /* marshal data to EXI stream */
static int serialize_message(struct EXIDatabinder* service)
 {
	

	/* encode start document */ 	
	if (exiappHandEncodeStartDocument(&(service->outStream), &(service->stateEncode)) )
	{
	 
		return -1;
	}

	/* encode root element of null */
	if (serialize_EXIDocumentType(&(service->exiMsg), service)) 
	{
			 
		return -1;
	}


	/* encode end document */
	if (exiappHandEncodeEndDocument(&(service->outStream), &(service->stateEncode))) {
	 
	return -1;
	}	
 	
 	return 0;
 	
 }

 
 
int serialize_appHand(struct EXIDatabinder* service, uint8_t* outStream, uint16_t* payloadLength, struct EXIDocumentType_appHand* exiDoc)
{
 	exi_name_table_runtime_t runtimeTableEncode;
	uint32_t outPos;
 
	outPos=service->transportHeaderOffset;

 	/* assign outStream data to service EXI structure */
	service->outStream.data = outStream;
	service->outStream.pos = &outPos;
	service->outStream.buffer=0;
	service->outStream.capacity=8;
 
  	service->exiMsg = *exiDoc;
 
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiappHandInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	if(serialize_message(service))
		return -1;

	outPos -= service->transportHeaderOffset;
	*payloadLength = outPos;

 	return 0;
 }
 
/* Initialize serializer */
int init_appHandSerializer(struct EXIDatabinder* service, bytes_t bytes, string_ucs_t string, size_t max_outStream_size, uint16_t transportHeaderOffset)
{

	/* init byte array */
	 service->val.binary = bytes;

	/* init string array */
	 service->val.string = string;

	 /* init output stream */

	 service->outStream.size=max_outStream_size;

	 service->transportHeaderOffset=transportHeaderOffset;

	return 0;
}
 
 
