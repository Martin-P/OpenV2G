

/*
 * Copyright (C) 2007-2011 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Sebastian.Kaebisch.EXT@siemens.com
 * @version 0.5
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXISeGen</p>
 *
 ********************************************************************/

 
 #include "v2g_serviceDataTypes.h"
  #include "v2g_serviceDataTypes.c"
 #include "v2g_serviceClientStubs.h"
 #include "v2g_serviceDataSerialization.c"
 #include "v2g_serviceClientDataTransmitter.h"
 #include "EXITypes.h"
 #include "EXIDecoder.h"
 #include "EXIEncoder.h"
 #include "StringTable.h"
 #include <string.h>
 

static int deserializeMessage(struct EXIService* service);


static int _setInt32Value(integer_t* iv, int32_t* int32) {
	int errn = 0;
	switch(iv->type) {
	/* Unsigned Integer */
	case UNSIGNED_INTEGER_8:
		*int32 = iv->val.uint8;
		break;
	case UNSIGNED_INTEGER_16:
		*int32 = iv->val.uint16;
		break;
	case UNSIGNED_INTEGER_32:
		if (iv->val.uint32 <= 2147483647) {
			*int32 = iv->val.uint32;
		} else {
			errn = EXI_UNSUPPORTED_INTEGER_VALUE;
		}
		break;
	case UNSIGNED_INTEGER_64:
		errn = EXI_UNSUPPORTED_INTEGER_VALUE;
		break;
	/* (Signed) Integer */
	case INTEGER_8:
		*int32 = iv->val.int8;
		break;
	case INTEGER_16:
		*int32 = iv->val.int16;
		break;
	case INTEGER_32:
		*int32 = iv->val.int32;
		break;
	case INTEGER_64:
		errn = EXI_UNSUPPORTED_INTEGER_VALUE;
	}
	return errn;
}


static int _setInt16Value(integer_t* iv, int16_t* int16) {
	int errn = 0;
	switch(iv->type) {
	/* Unsigned Integer */
	case UNSIGNED_INTEGER_8:
		*int16 = iv->val.uint8;
		break;
	case UNSIGNED_INTEGER_16:
		*int16 = iv->val.uint16;
		break;
	case UNSIGNED_INTEGER_32:
		if (iv->val.uint32 <= 2147483647) {
			*int16 = iv->val.uint32;
		} else {
			errn = EXI_UNSUPPORTED_INTEGER_VALUE;
		}
		break;
	case UNSIGNED_INTEGER_64:
		errn = EXI_UNSUPPORTED_INTEGER_VALUE;
		break;
	/* (Signed) Integer */
	case INTEGER_8:
		*int16 = iv->val.int8;
		break;
	case INTEGER_16:
		*int16 = iv->val.int16;
		break;
	case INTEGER_32:
		*int16 = iv->val.int32;
		break;
	case INTEGER_64:
		errn = EXI_UNSUPPORTED_INTEGER_VALUE;
	}
	return errn;
}




/**
 * \brief   Calls the remote sessionSetup method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct SessionSetupReqType* Request data for the server (has to be set up before)
 * \param	result   struct SessionSetupResType* Contains the response data from the server
 * \return  0 = 0K; -1 = ERROR */
int call_sessionSetup(struct EXIService* service, struct MessageHeaderType* header, struct SessionSetupReqType* params, struct SessionSetupResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

	/* init uniqueID stack */
	service->idPath.pos=0;

	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;

	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;



	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));



	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.SessionSetupReq = params;
	service->exiMsg.V2G_Message.Body.isused.SessionSetupReq=1;

	/* encode data to exi stream*/
	if(serialize_message(service))
	{

		return -1;
	}

 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode)
 	{
		return -1;
 	}



 	service->exiMsg.V2G_Message.Body.SessionSetupRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{

 		return -1;
 	}



	return 0;
}

/**
 * \brief   Calls the remote serviceDiscovery method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct ServiceDiscoveryReqType* Request data for the server (has to be set up before)
 * \param	result   struct ServiceDiscoveryResType* Contains the response data from the server
 * \return  0 = 0K; -1 = ERROR */
int call_serviceDiscovery(struct EXIService* service, struct MessageHeaderType* header, struct ServiceDiscoveryReqType* params, struct ServiceDiscoveryResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

	/* init uniqueID stack */
	service->idPath.pos=0;

	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;

	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;



	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));



	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.ServiceDiscoveryReq = params;
	service->exiMsg.V2G_Message.Body.isused.ServiceDiscoveryReq=1;

	/* encode data to exi stream*/
	if(serialize_message(service))
	{

		return -1;
	}

 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode)
 	{
		return -1;
 	}


	init_ServiceDiscoveryResType(result);

 	service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{

 		return -1;
 	}



	return 0;
}

/**
 * \brief   Calls the remote serviceDetail method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct ServiceDetailReqType* Request data for the server (has to be set up before)
 * \param	result   struct ServiceDetailResType* Contains the response data from the server
 * \return  0 = 0K; -1 = ERROR */
int call_serviceDetail(struct EXIService* service, struct MessageHeaderType* header, struct ServiceDetailReqType* params, struct ServiceDetailResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

	/* init uniqueID stack */
	service->idPath.pos=0;

	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;

	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;



	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));



	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.ServiceDetailReq = params;
	service->exiMsg.V2G_Message.Body.isused.ServiceDetailReq=1;

	/* encode data to exi stream*/
	if(serialize_message(service))
	{

		return -1;
	}

 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode)
 	{
		return -1;
 	}


 	init_ServiceDetailResType(result);
 	service->exiMsg.V2G_Message.Body.ServiceDetailRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{

 		return -1;
 	}



	return 0;
}

/**
 * \brief   Calls the remote selectedServicePayment method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct ServicePaymentSelectionReqType* Request data for the server (has to be set up before)
 * \param	result   struct ServicePaymentSelectionResType* Contains the response data from the server
 * \return  0 = 0K; -1 = ERROR */
int call_selectedServicePayment(struct EXIService* service, struct MessageHeaderType* header, struct ServicePaymentSelectionReqType* params, struct ServicePaymentSelectionResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

	/* init uniqueID stack */
	service->idPath.pos=0;

	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;

	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;



	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));



	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.ServicePaymentSelectionReq = params;
	service->exiMsg.V2G_Message.Body.isused.ServicePaymentSelectionReq=1;

	/* encode data to exi stream*/
	if(serialize_message(service))
	{

		return -1;
	}

 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode)
 	{
		return -1;
 	}



 	service->exiMsg.V2G_Message.Body.ServicePaymentSelectionRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{

 		return -1;
 	}



	return 0;
}

/**
 * \brief   Calls the remote paymentDetails method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct PaymentDetailsReqType* Request data for the server (has to be set up before)
 * \param	result   struct PaymentDetailsResType* Contains the response data from the server
 * \return  0 = 0K; -1 = ERROR */
int call_paymentDetails(struct EXIService* service, struct MessageHeaderType* header, struct PaymentDetailsReqType* params, struct PaymentDetailsResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

	/* init uniqueID stack */
	service->idPath.pos=0;

	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;

	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;



	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));



	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.PaymentDetailsReq = params;
	service->exiMsg.V2G_Message.Body.isused.PaymentDetailsReq=1;

	/* encode data to exi stream*/
	if(serialize_message(service))
	{

		return -1;
	}

 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode)
 	{
		return -1;
 	}



 	service->exiMsg.V2G_Message.Body.PaymentDetailsRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{

 		return -1;
 	}



	return 0;
}


/** 
 * \brief   Calls the remote contractAuthentication method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct ContractAuthenticationReqType* Request data for the server (has to be set up before)
 * \param	result   struct ContractAuthenticationResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_contractAuthentication(struct EXIService* service, struct MessageHeaderType* header, struct ContractAuthenticationReqType* params, struct ContractAuthenticationResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.ContractAuthenticationReq = params;
	service->exiMsg.V2G_Message.Body.isused.ContractAuthenticationReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.ContractAuthenticationRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote chargeParameterDiscovery method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct ChargeParameterDiscoveryReqType* Request data for the server (has to be set up before)
 * \param	result   struct ChargeParameterDiscoveryResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_chargeParameterDiscovery(struct EXIService* service, struct MessageHeaderType* header, struct ChargeParameterDiscoveryReqType* params, struct ChargeParameterDiscoveryResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryReq = params;
	service->exiMsg.V2G_Message.Body.isused.ChargeParameterDiscoveryReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote lineLock method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct LineLockReqType* Request data for the server (has to be set up before)
 * \param	result   struct LineLockResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_lineLock(struct EXIService* service, struct MessageHeaderType* header, struct LineLockReqType* params, struct LineLockResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.LineLockReq = params;
	service->exiMsg.V2G_Message.Body.isused.LineLockReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.LineLockRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote powerDelivery method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct PowerDeliveryReqType* Request data for the server (has to be set up before)
 * \param	result   struct PowerDeliveryResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_powerDelivery(struct EXIService* service, struct MessageHeaderType* header, struct PowerDeliveryReqType* params, struct PowerDeliveryResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.PowerDeliveryReq = params;
	service->exiMsg.V2G_Message.Body.isused.PowerDeliveryReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.PowerDeliveryRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote meteringStatus method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct MeteringStatusReqType* Request data for the server (has to be set up before)
 * \param	result   struct MeteringStatusResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_meteringStatus(struct EXIService* service, struct MessageHeaderType* header, struct MeteringStatusReqType* params, struct MeteringStatusResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.MeteringStatusReq = params;
	service->exiMsg.V2G_Message.Body.isused.MeteringStatusReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.MeteringStatusRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote meteringReceipt method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct MeteringReceiptReqType* Request data for the server (has to be set up before)
 * \param	result   struct MeteringReceiptResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_meteringReceipt(struct EXIService* service, struct MessageHeaderType* header, struct MeteringReceiptReqType* params, struct MeteringReceiptResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.MeteringReceiptReq = params;
	service->exiMsg.V2G_Message.Body.isused.MeteringReceiptReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.MeteringReceiptRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote certificateUpdate method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct CertificateUpdateReqType* Request data for the server (has to be set up before)
 * \param	result   struct CertificateUpdateResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_certificateUpdate(struct EXIService* service, struct MessageHeaderType* header, struct CertificateUpdateReqType* params, struct CertificateUpdateResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.CertificateUpdateReq = params;
	service->exiMsg.V2G_Message.Body.isused.CertificateUpdateReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.CertificateUpdateRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote certificateInstallation method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct CertificateInstallationReqType* Request data for the server (has to be set up before)
 * \param	result   struct CertificateInstallationResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_certificateInstallation(struct EXIService* service, struct MessageHeaderType* header, struct CertificateInstallationReqType* params, struct CertificateInstallationResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.CertificateInstallationReq = params;
	service->exiMsg.V2G_Message.Body.isused.CertificateInstallationReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	
 	init_CertificateInstallationResType(result);
 	service->exiMsg.V2G_Message.Body.CertificateInstallationRes = result;


	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote cableCheck method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct CableCheckReqType* Request data for the server (has to be set up before)
 * \param	result   struct CableCheckResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_cableCheck(struct EXIService* service, struct MessageHeaderType* header, struct CableCheckReqType* params, struct CableCheckResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.CableCheckReq = params;
	service->exiMsg.V2G_Message.Body.isused.CableCheckReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.CableCheckRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote preCharge method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct PreChargeReqType* Request data for the server (has to be set up before)
 * \param	result   struct PreChargeResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_preCharge(struct EXIService* service, struct MessageHeaderType* header, struct PreChargeReqType* params, struct PreChargeResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.PreChargeReq = params;
	service->exiMsg.V2G_Message.Body.isused.PreChargeReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.PreChargeRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote currentDemand method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct CurrentDemandReqType* Request data for the server (has to be set up before)
 * \param	result   struct CurrentDemandResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_currentDemand(struct EXIService* service, struct MessageHeaderType* header, struct CurrentDemandReqType* params, struct CurrentDemandResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.CurrentDemandReq = params;
	service->exiMsg.V2G_Message.Body.isused.CurrentDemandReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.CurrentDemandRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote weldingDetection method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct WeldingDetectionReqType* Request data for the server (has to be set up before)
 * \param	result   struct WeldingDetectionResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_weldingDetection(struct EXIService* service, struct MessageHeaderType* header, struct WeldingDetectionReqType* params, struct WeldingDetectionResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.WeldingDetectionReq = params;
	service->exiMsg.V2G_Message.Body.isused.WeldingDetectionReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.WeldingDetectionRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

/** 
 * \brief   Calls the remote terminateCharging method
 * \param	service  struct EXIService* Service data structure (has to be initialized before)
 * \param	header   struct HeaderType* Header data structure
 * \param	params   struct TerminateChargingReqType* Request data for the server (has to be set up before)
 * \param	result   struct TerminateChargingResType* Contains the response data from the server 
 * \return  0 = 0K; -1 = ERROR */
int call_terminateCharging(struct EXIService* service, struct MessageHeaderType* header, struct TerminateChargingReqType* params, struct TerminateChargingResType* result)
{
	uint32_t posEncode, posDecode;
	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;
	
	/* init uniqueID stack */
	service->idPath.pos=0;
	
	/* init outStream data structure */
	posEncode = service->transportHeaderOffset;
	service->outStream.pos = &posEncode;
	service->outStream.buffer = 0;
	service->outStream.capacity = 8;
	
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode);

	/* init inStream data structure */
	posDecode = service->transportHeaderOffset;
	service->inStream.pos = &posDecode;
	service->inStream.buffer=0;
	service->inStream.capacity=0;
	


	/* init EXI message */
	init_EXIDocumentType(&(service->exiMsg));
	

	
	/* assign data to service data structure */
 	service->exiMsg.V2G_Message.Header = header;
	service->exiMsg.V2G_Message.Body.TerminateChargingReq = params;
	service->exiMsg.V2G_Message.Body.isused.TerminateChargingReq=1;
	
	/* encode data to exi stream*/
	if(serialize_message(service))
	{ 
	
		return -1;
	}
 
 	/* send data to server and wait for the response message */
 	service->errorCode=serviceDataTransmitter(service->outStream.data, (*(service->outStream.pos)-service->transportHeaderOffset), service->inStream.data);
 	if(service->errorCode) 
 	{
		return -1;
 	}
 	
 	

 	service->exiMsg.V2G_Message.Body.TerminateChargingRes = result;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&(service->inStream), &(service->stateDecode), runtimeTableDecode);

	/* deserilize the response message */
 	if(deserializeMessage(service)<0)
 	{
 	 
 		return -1;
 	}

 		
 	
	return 0;
}	

 

 /**
 * Deserialize an element value of the EXI stream and assign it to the
 * service data structure 
 */
static int deserializeElementCharacter(struct EXIService* service)
{

	switch(service->eqn.namespaceURI) {
		case 0:
			switch(service->eqn.localPart) {
				case 0: /*attr_Algorithm*/

				if(service->val.type == STRING) 
					{
						if( service->idPath.id[5] == 0)
						{
							memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.CanonicalizationMethod.attr_Algorithm.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.CanonicalizationMethod.attr_Algorithm.arraylen.data = service->val.string.len;

						} else if(service->idPath.id[5] == 43)
						{
							memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.SignatureMethod.attr_Algorithm.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.SignatureMethod.attr_Algorithm.arraylen.data = service->val.string.len;

						} else if(service->idPath.id[6] == 5)
						{
							/* memcpy(service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].DigestMethod.attr_Algorithm.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].DigestMethod.attr_Algorithm.arraylen.data = service->val.string.len; */
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 2: /*attr_Id*/

				if(service->val.type == STRING) 
					{
						if( service->idPath.id[3] == 42)
						{
							memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->attr_Id.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->attr_Id.arraylen.data = service->val.string.len;

						} else if(service->idPath.id[4] == 52)
						{
						/*	memcpy(service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.attr_Id.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.attr_Id.arraylen.data = service->val.string.len; */

						} else if(service->idPath.id[4] == 14)
						{
							memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.attr_Id.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.attr_Id.arraylen.data = service->val.string.len;

						} else if(service->idPath.id[5] == 34)
						{
						/*	memcpy(service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].attr_Id.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].attr_Id.arraylen.data = service->val.string.len; */
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 6: /*attr_URI*/

				if(service->val.type == STRING) 
					{
					/*	memcpy(service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].attr_URI.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].attr_URI.arraylen.data = service->val.string.len; */

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 5: /*attr_Type*/

				if(service->val.type == STRING) 
					{
					/*	memcpy(service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].attr_Type.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.Reference[service->exiMsg.V2G_Message.Header->Security.Signature.SignedInfo.arraylen.Reference].attr_Type.arraylen.data = service->val.string.len; */

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;	
			} /* close switch(service->eqn.localPart) */	
		break;
		case 4:
			switch(service->eqn.localPart) {
			case 7: /*DigestValue*/
				if(service->val.type == BINARY_BASE64)
				{
					memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.Reference.DigestValue.data, service->val.binary.data,service->val.binary.len);
					service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.Reference.DigestValue.arraylen.data = service->val.binary.len;


				}
				else
				{
					return -1; /* wrong data type */
				}

			break;
			case 50: /*SignatureValue*/

			if(service->val.type == BINARY_BASE64)
			{
				memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignatureValue.data, service->val.binary.data,service->val.binary.len);
				service->exiMsg.V2G_Message.Header->Security.Signature->SignatureValue.arraylen.data = service->val.binary.len;


			}
			else
			{
				return -1; /* wrong data type */
			}

			break;
			case 62: /*X509IssuerName*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509IssuerSerial.X509IssuerName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509IssuerSerial.X509IssuerName.arraylen.data = service->val.string.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 66: /*X509SerialNumber*/

				if(service->val.type == INTEGER) 
					{
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509IssuerSerial.X509SerialNumber = service->val.integer.val.int64;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 65: /*X509SKI*/

				if(service->val.type == BINARY_BASE64) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509SKI.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509SKI.arraylen.data = service->val.binary.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 67: /*X509SubjectName*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509SubjectName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509SubjectName.arraylen.data = service->val.string.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 59: /*X509Certificate*/

				if(service->val.type == BINARY_BASE64) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509Certificate.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509Certificate.arraylen.data = service->val.binary.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 58: /*X509CRL*/

				if(service->val.type == BINARY_BASE64) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509CRL.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Header->Security.Signature->KeyInfo.X509Data.X509CRL.arraylen.data = service->val.binary.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;	
			} /* close switch(service->eqn.localPart) */	
		break;
		case 5:
			switch(service->eqn.localPart) {
				case 93: /*ResponseCode*/

				if(service->val.type == ENUMERATION) 
					{
						if( service->idPath.id[2] == 116)
						{
							service->exiMsg.V2G_Message.Body.SessionSetupRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 102)
						{
							service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 98)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 108)
						{
							service->exiMsg.V2G_Message.Body.ServicePaymentSelectionRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 77)
						{
							service->exiMsg.V2G_Message.Body.PaymentDetailsRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 25)
						{
							service->exiMsg.V2G_Message.Body.ContractAuthenticationRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 18)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 13)
						{
							service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 9)
						{
							service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 54)
						{
							service->exiMsg.V2G_Message.Body.LineLockRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 5)
						{
							service->exiMsg.V2G_Message.Body.CableCheckRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 86)
						{
							service->exiMsg.V2G_Message.Body.PreChargeRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 35)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 128)
						{
							service->exiMsg.V2G_Message.Body.WeldingDetectionRes->ResponseCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 123)
						{
							service->exiMsg.V2G_Message.Body.TerminateChargingRes->ResponseCode = service->val.enumeration;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 41: /*EVSEID*/

				if(service->val.type == BINARY_HEX) 
					{
						if( service->idPath.id[2] == 116)
						{
							memcpy(service->exiMsg.V2G_Message.Body.SessionSetupRes->EVSEID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.SessionSetupRes->EVSEID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[2] == 63)
						{
							memcpy(service->exiMsg.V2G_Message.Body.MeteringStatusRes->EVSEID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->EVSEID.arraylen.data = service->val.binary.len;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 118: /*TCurrent*/

				if(service->val.type == INTEGER) 
					{
						if( service->idPath.id[2] == 116)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.SessionSetupRes->TCurrent));

						} else if(service->idPath.id[2] == 77)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.PaymentDetailsRes->TCurrent));

						} else if(service->idPath.id[2] == 63)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.MeteringStatusRes->TCurrent));
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 51: /*GenChallenge*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Body.PaymentDetailsRes->GenChallenge.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.PaymentDetailsRes->GenChallenge.arraylen.data = service->val.string.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 50: /*EnergyProvider*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->EnergyProvider.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->EnergyProvider.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->isused.EnergyProvider=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 32: /*ContractSignaturePrivateKey*/

				if(service->val.type == BINARY_BASE64) 
					{


						if( service->idPath.id[2] == 13)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractSignaturePrivateKey.data, service->val.binary.data,service->val.binary.len);
							service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractSignaturePrivateKey.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[2] == 9)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignaturePrivateKey.data, service->val.binary.data,service->val.binary.len);
							service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignaturePrivateKey.arraylen.data = service->val.binary.len;

						}


					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 29: /*ContractEncryptionPrivateKey*/

				if(service->val.type == BINARY_BASE64) 
					{
						if( service->idPath.id[2] == 13)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractEncryptionPrivateKey.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractEncryptionPrivateKey.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[2] == 9)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionPrivateKey.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionPrivateKey.arraylen.data = service->val.binary.len;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 30: /*ContractID*/

				if(service->val.type == STRING) 
					{
						if( service->idPath.id[2] == 13)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractID.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractID.arraylen.data = service->val.string.len;

						} else if(service->idPath.id[2] == 9)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractID.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractID.arraylen.data = service->val.string.len;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 94: /*RetryCounter*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						service->exiMsg.V2G_Message.Body.CertificateUpdateRes->RetryCounter = service->val.integer.val.int8;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 40: /*EVSECurrentLimitAchieved*/

				if(service->val.type == BOOLEAN) 
					{
						service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSECurrentLimitAchieved = service->val.boolean;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 49: /*EVSEVoltageLimitAchieved*/

				if(service->val.type == BOOLEAN) 
					{
						service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEVoltageLimitAchieved = service->val.boolean;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 46: /*EVSEPowerLimitAchieved*/

				if(service->val.type == BOOLEAN) 
					{
						service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPowerLimitAchieved = service->val.boolean;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;	
			} /* close switch(service->eqn.localPart) */	
		break;
		case 6:
			switch(service->eqn.localPart) {
				case 132: /*SessionID*/

				if(service->val.type == BINARY_HEX) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->SessionInformation.SessionID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Header->SessionInformation.SessionID.arraylen.data = service->val.binary.len;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 127: /*ServiceSessionID*/

				if(service->val.type == BINARY_HEX) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->SessionInformation.ServiceSessionID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Header->SessionInformation.ServiceSessionID.arraylen.data = service->val.binary.len;
						service->exiMsg.V2G_Message.Header->SessionInformation.isused.ServiceSessionID=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 107: /*ProtocolVersion*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->SessionInformation.ProtocolVersion.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->SessionInformation.ProtocolVersion.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Header->SessionInformation.isused.ProtocolVersion=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 67: /*FaultCode*/

				if(service->val.type == ENUMERATION) 
					{
						service->exiMsg.V2G_Message.Header->Notification.FaultCode = service->val.enumeration;
						service->exiMsg.V2G_Message.Header->Notification.isused.FaultCode=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 68: /*FaultMsg*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Header->Notification.FaultMsg.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Notification.FaultMsg.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Header->Notification.isused.FaultMsg=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 103: /*PaymentOption*/

				if(service->val.type == ENUMERATION) 
					{
						if( service->idPath.id[2] == 102)
						{
							service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->PaymentOptions.PaymentOption[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->PaymentOptions.arraylen.PaymentOption++] = service->val.enumeration;

						} else if(service->idPath.id[2] == 98)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->PaymentOptions.PaymentOption[service->exiMsg.V2G_Message.Body.ServiceDetailRes->PaymentOptions.arraylen.PaymentOption++] = service->val.enumeration;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 120: /*ServiceID*/

				if(service->val.type == BINARY_HEX) 
					{
						if( service->idPath.id[3] == 111)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 20)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 105)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 114)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 112)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 116)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 124)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceID.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 121)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceID.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceID.arraylen.data = service->val.binary.len;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 123: /*ServiceName*/

				if(service->val.type == STRING) 
					{
						if( service->idPath.id[3] == 111)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.isused.ServiceName=1;

						} else if(service->idPath.id[3] == 20)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.isused.ServiceName=1;

						} else if(service->idPath.id[3] == 105)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].isused.ServiceName=1;

						} else if(service->idPath.id[3] == 114)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.isused.ServiceName=1;

						} else if(service->idPath.id[3] == 112)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.isused.ServiceName=1;

						} else if(service->idPath.id[3] == 116)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.isused.ServiceName=1;

						} else if(service->idPath.id[3] == 124)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.isused.ServiceName=1;

						} else if(service->idPath.id[3] == 121)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceName.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceName.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.isused.ServiceName=1;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 111: /*ServiceCategory*/

				if(service->val.type == ENUMERATION) 
					{
						if( service->idPath.id[3] == 111)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 20)
						{
							service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 105)
						{
							service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 114)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 112)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 116)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 124)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.isused.ServiceCategory=1;

						} else if(service->idPath.id[3] == 121)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceCategory = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.isused.ServiceCategory=1;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 126: /*ServiceScope*/

				if(service->val.type == STRING) 
					{
						if( service->idPath.id[3] == 111)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceTag.isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 20)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.ServiceTag.isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 105)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.Service[service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service].isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 114)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->ServiceTag.isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 112)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->ServiceTag.isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 116)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCustom->ServiceTag.isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 124)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceRCS->ServiceTag.isused.ServiceScope=1;

						} else if(service->idPath.id[3] == 121)
						{
							memcpy(service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceScope.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.ServiceScope.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceInternet->ServiceTag.isused.ServiceScope=1;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 70: /*FreeService*/

				if(service->val.type == BOOLEAN) 
					{
						if( service->idPath.id[2] == 102)
						{
							service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.FreeService = service->val.boolean;

						} else if(service->idPath.id[2] == 98)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->FreeService = service->val.boolean;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 65: /*EnergyTransferType*/

				if(service->val.type == ENUMERATION) 
					{
						if( service->idPath.id[2] == 102)
						{
							service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ChargeService.EnergyTransferType = service->val.enumeration;

						} else if(service->idPath.id[2] == 98)
						{
							service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCharge->EnergyTransferType = service->val.enumeration;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 15: /*CertificateInstall*/

				if(service->val.type == BOOLEAN) 
					{
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->CertificateInstall = service->val.boolean;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 16: /*CertificateUpdate*/

				if(service->val.type == BOOLEAN) 
					{
						service->exiMsg.V2G_Message.Body.ServiceDetailRes->ServiceCertificate->CertificateUpdate = service->val.boolean;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 13: /*Certificate*/

				if(service->val.type == BINARY_BASE64) 
					{
						if( service->idPath.id[3] == 31 && service->idPath.id[2] == 13)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractSignatureCertChain.Certificate.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractSignatureCertChain.Certificate.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 28 && service->idPath.id[2] == 13)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractEncryptionCertChain.Certificate.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractEncryptionCertChain.Certificate.arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[4] == 137 && service->idPath.id[3] == 31)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.SubCertificates.Certificate[service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.SubCertificates.arraylen.Certificate].data, service->val.binary.data,service->val.binary.len);
							service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.SubCertificates.Certificate[service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.SubCertificates.arraylen.Certificate].arraylen.data = service->val.binary.len;

						}
						else if(service->idPath.id[3] == 31 && service->idPath.id[2] == 9)
						{

							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.Certificate.data, service->val.binary.data,service->val.binary.len);
							service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.Certificate.arraylen.data = service->val.binary.len;

						}
						else if(service->idPath.id[4] == 137 && service->idPath.id[2] == 9)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.SubCertificates.Certificate[service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.SubCertificates.arraylen.Certificate].data, service->val.binary.data,service->val.binary.len);
							service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.SubCertificates.Certificate[service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.SubCertificates.arraylen.Certificate].arraylen.data = service->val.binary.len;

						} else if(service->idPath.id[3] == 28 && service->idPath.id[2] == 9)
						{
							memcpy(service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.Certificate.data, service->val.binary.data,service->val.binary.len);
							service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.Certificate.arraylen.data = service->val.binary.len;


						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 77: /*Multiplier*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						if( service->idPath.id[3] == 42)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->EVSEMaxPower.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 66)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->PCurrent.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 86)
						{
							service->exiMsg.V2G_Message.Body.PreChargeRes->EVSEPresentVoltage.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 35)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPresentVoltage.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 47)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPresentCurrent.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 45)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumVoltageLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 43)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumCurrentLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 44)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumPowerLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 128)
						{
							service->exiMsg.V2G_Message.Body.WeldingDetectionRes->EVSEPresentVoltage.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 123)
						{
							service->exiMsg.V2G_Message.Body.TerminateChargingRes->EVSEPresentVoltage.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 50)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxVoltage.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 55)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMinVoltage.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 48)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxCurrent.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 54)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMinCurrent.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 51)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumCurrentLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 52)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumPowerLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 53)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumVoltageLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 56)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMinimumCurrentLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 57)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMinimumVoltageLimit.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 46)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSECurrentRegulationTolerance.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 58)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEPeakCurrentRipple.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 47)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEEnergyToBeDelivered.Multiplier = service->val.integer.val.int8;

						} else if(service->idPath.id[4] == 75)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterReading.Multiplier = service->val.integer.val.int8;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 151: /*Unit*/

				if(service->val.type == ENUMERATION) 
					{
						if( service->idPath.id[3] == 42)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->EVSEMaxPower.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 66)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->PCurrent.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 86)
						{
							service->exiMsg.V2G_Message.Body.PreChargeRes->EVSEPresentVoltage.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 35)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPresentVoltage.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 47)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPresentCurrent.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 45)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumVoltageLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 43)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumCurrentLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 44)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumPowerLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 128)
						{
							service->exiMsg.V2G_Message.Body.WeldingDetectionRes->EVSEPresentVoltage.Unit = service->val.enumeration;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 123)
						{
							service->exiMsg.V2G_Message.Body.TerminateChargingRes->EVSEPresentVoltage.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 50)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxVoltage.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 55)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMinVoltage.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 48)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxCurrent.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 54)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMinCurrent.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 51)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumCurrentLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 52)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumPowerLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 53)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumVoltageLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 56)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMinimumCurrentLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 57)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMinimumVoltageLimit.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 46)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSECurrentRegulationTolerance.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 58)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEPeakCurrentRipple.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 47)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEEnergyToBeDelivered.Unit = service->val.enumeration;

						} else if(service->idPath.id[4] == 75)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterReading.Unit = service->val.enumeration;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 152: /*Value*/

				if(service->val.type == INTEGER) 
					{
					_setInt16Value( &(service->val.integer),&(service->val.integer.val.int16));

						if( service->idPath.id[3] == 42)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->EVSEMaxPower.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 66)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->PCurrent.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 86)
						{
							service->exiMsg.V2G_Message.Body.PreChargeRes->EVSEPresentVoltage.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 35)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPresentVoltage.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 47)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEPresentCurrent.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 45)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumVoltageLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 43)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumCurrentLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 44)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->EVSEMaximumPowerLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 128)
						{
							service->exiMsg.V2G_Message.Body.WeldingDetectionRes->EVSEPresentVoltage.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[3] == 48 && service->idPath.id[2] == 123)
						{
							service->exiMsg.V2G_Message.Body.TerminateChargingRes->EVSEPresentVoltage.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 50)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxVoltage.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 55)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMinVoltage.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 48)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxCurrent.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 54)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMinCurrent.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 51)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumCurrentLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 52)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumPowerLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 53)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMaximumVoltageLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 56)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMinimumCurrentLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 57)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEMinimumVoltageLimit.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 46)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSECurrentRegulationTolerance.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 58)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEPeakCurrentRipple.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 47)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEEnergyToBeDelivered.Value = service->val.integer.val.int16;

						} else if(service->idPath.id[4] == 75)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterReading.Value = service->val.integer.val.int16;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 148: /*TariffPMax*/

				if(service->val.type == INTEGER) 
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.TariffEntry[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.arraylen.TariffEntry].TariffPMax = service->val.integer.val.int16;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 40: /*EPrice*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.TariffEntry[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.arraylen.TariffEntry].EPrice.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.TariffEntry[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.arraylen.TariffEntry].EPrice.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.TariffEntry[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.arraylen.TariffEntry].isused.EPrice=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 147: /*TariffID*/

				if(service->val.type == INTEGER) 
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffID = service->val.integer.val.int16;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 142: /*TariffDescription*/

				if(service->val.type == ENUMERATION) 
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffDescription = service->val.enumeration;
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].isused.TariffDescription=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 22: /*Currency*/

				if(service->val.type == ENUMERATION) 
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Currency = service->val.enumeration;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 43: /*EPriceUnit*/

				if(service->val.type == ENUMERATION) 
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.EPriceUnit = service->val.enumeration;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 41: /*EPriceMultiplier*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.EPriceMultiplier = service->val.integer.val.int8;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 60: /*EVSEStandby*/

				if(service->val.type == BOOLEAN) 
					{
						if( service->idPath.id[3] == 2 && service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->AC_EVSEStatus->EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 2 && service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->AC_EVSEStatus->EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 2 && service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->AC_EVSEStatus->EVSEStandby = service->val.boolean;

						}  else if(service->idPath.id[3] == 27 && service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->DC_EVSEStatus->EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 27 && service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->DC_EVSEStatus->EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 27 && service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->DC_EVSEStatus->EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 38 && service->idPath.id[2] == 5)
						{
							service->exiMsg.V2G_Message.Body.CableCheckRes->DC_EVSEStatus.EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 38 && service->idPath.id[2] == 86)
						{
							service->exiMsg.V2G_Message.Body.PreChargeRes->DC_EVSEStatus.EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 38 && service->idPath.id[2] == 35)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->DC_EVSEStatus.EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[3] == 38 && service->idPath.id[2] == 128)
						{
							service->exiMsg.V2G_Message.Body.WeldingDetectionRes->DC_EVSEStatus.EVSEStandby = service->val.boolean;

						} else if(service->idPath.id[4] == 2)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->AC_EVSEStatus.EVSEStandby = service->val.boolean;
						}  else if(service->idPath.id[4] == 27)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->DC_EVSEStatus.EVSEStandby = service->val.boolean;
						}
						else if(service->idPath.id[3] == 0)
						{
							service->exiMsg.V2G_Message.Body.LineLockRes->AC_EVSEStatus.EVSEStandby = service->val.boolean;

						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 21: /*ConnectorLocked*/

				if(service->val.type == BOOLEAN) 
					{
						if( service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->AC_EVSEStatus->ConnectorLocked = service->val.boolean;

						} else if(service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->AC_EVSEStatus->ConnectorLocked = service->val.boolean;

						} else if(service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->AC_EVSEStatus->ConnectorLocked = service->val.boolean;

						} else if(service->idPath.id[2] == 54)
						{
							service->exiMsg.V2G_Message.Body.LineLockRes->AC_EVSEStatus.ConnectorLocked = service->val.boolean;

						} else if(service->idPath.id[4] == 2)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->AC_EVSEStatus.ConnectorLocked = service->val.boolean;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 104: /*PowerSwitchClosed*/

				if(service->val.type == BOOLEAN) 
					{
						if( service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->AC_EVSEStatus->PowerSwitchClosed = service->val.boolean;

						} else if(service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->AC_EVSEStatus->PowerSwitchClosed = service->val.boolean;

						} else if(service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->AC_EVSEStatus->PowerSwitchClosed = service->val.boolean;

						} else if(service->idPath.id[2] == 54)
						{
							service->exiMsg.V2G_Message.Body.LineLockRes->AC_EVSEStatus.PowerSwitchClosed = service->val.boolean;

						} else if(service->idPath.id[4] == 2)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->AC_EVSEStatus.PowerSwitchClosed = service->val.boolean;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 108: /*RCD*/

				if(service->val.type == BOOLEAN) 
					{
						if( service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->AC_EVSEStatus->RCD = service->val.boolean;

						} else if(service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->AC_EVSEStatus->RCD = service->val.boolean;

						} else if(service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->AC_EVSEStatus->RCD = service->val.boolean;

						} else if(service->idPath.id[2] == 54)
						{
							service->exiMsg.V2G_Message.Body.LineLockRes->AC_EVSEStatus.RCD = service->val.boolean;

						} else if(service->idPath.id[4] == 2)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->AC_EVSEStatus.RCD = service->val.boolean;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 134: /*ShutDownTime*/

				if(service->val.type == INTEGER) 
					{
						if( service->idPath.id[2] == 82)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.PowerDeliveryRes->AC_EVSEStatus->ShutDownTime));

						} else if(service->idPath.id[2] == 63)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.MeteringStatusRes->AC_EVSEStatus->ShutDownTime));

						} else if(service->idPath.id[2] == 59)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.MeteringReceiptRes->AC_EVSEStatus->ShutDownTime));

						} else if(service->idPath.id[2] == 54)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.LineLockRes->AC_EVSEStatus.ShutDownTime));

						} else if(service->idPath.id[4] == 2)
						{
							_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->AC_EVSEStatus.ShutDownTime));
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 136: /*StopCharging*/

				if(service->val.type == BOOLEAN) 
					{
						if( service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->AC_EVSEStatus->StopCharging = service->val.boolean;

						} else if(service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->AC_EVSEStatus->StopCharging = service->val.boolean;

						} else if(service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->AC_EVSEStatus->StopCharging = service->val.boolean;

						} else if(service->idPath.id[2] == 54)
						{
							service->exiMsg.V2G_Message.Body.LineLockRes->AC_EVSEStatus.StopCharging = service->val.boolean;

						} else if(service->idPath.id[4] == 2)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->AC_EVSEStatus.StopCharging = service->val.boolean;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 49: /*EVSEMaxPhases*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->AC_EVSEChargeParameter->EVSEMaxPhases = service->val.integer.val.int8;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 62: /*EVSEStatusCode*/

				if(service->val.type == ENUMERATION) 
					{
						if( service->idPath.id[2] == 82)
						{
							service->exiMsg.V2G_Message.Body.PowerDeliveryRes->DC_EVSEStatus->EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 63)
						{
							service->exiMsg.V2G_Message.Body.MeteringStatusRes->DC_EVSEStatus->EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 59)
						{
							service->exiMsg.V2G_Message.Body.MeteringReceiptRes->DC_EVSEStatus->EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 5)
						{
							service->exiMsg.V2G_Message.Body.CableCheckRes->DC_EVSEStatus.EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 86)
						{
							service->exiMsg.V2G_Message.Body.PreChargeRes->DC_EVSEStatus.EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 35)
						{
							service->exiMsg.V2G_Message.Body.CurrentDemandRes->DC_EVSEStatus.EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[2] == 128)
						{
							service->exiMsg.V2G_Message.Body.WeldingDetectionRes->DC_EVSEStatus.EVSEStatusCode = service->val.enumeration;

						} else if(service->idPath.id[4] == 27)
						{
							service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->DC_EVSEStatus.EVSEStatusCode = service->val.enumeration;
						}

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 59: /*EVSEProtocolVersion*/

				if(service->val.type == NBIT_UNSIGNED_INTEGER)
					{
						service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->EVSEProtocolVersion = service->val.integer.val.int8;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 72: /*MeterID*/

				if(service->val.type == STRING) 
					{
						memcpy(service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterID.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterID.arraylen.data = service->val.string.len;
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.isused.MeterID=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 74: /*MeterPubKey*/

				if(service->val.type == BINARY_BASE64) 
					{
						memcpy(service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterPubKey.data, service->val.binary.data,service->val.binary.len);
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterPubKey.arraylen.data = service->val.binary.len;
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.isused.MeterPubKey=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 76: /*MeterStatus*/
				if(service->val.type == INTEGER) 
					{
						_setInt16Value( &(service->val.integer),&(service->val.integer.val.int16));
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.MeterStatus = service->val.integer.val.int16;
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.isused.MeterStatus=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;
				case 139: /*TMeter*/

				if(service->val.type == INTEGER) 
					{
						_setInt32Value( &(service->val.integer),&(service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.TMeter));
						service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.isused.TMeter=1;

					} 
					else
					{
						return -1; /* wrong data type */
					}
		

				break;	
			} /* close switch(service->eqn.localPart) */	
		break;
	
	} /* close switch(service->eqn.namespaceURI) */
	return 0;
}
 
/**
 * Deserialize an element of the EXI stream
 * @return 0 = 0K; -1 = ERROR
 */
static int deserializeElement(struct EXIService* service)
{
	switch(service->eqn.namespaceURI) {
		case 0:
			switch(service->eqn.localPart) {

			}
		break;
		case 4:
			switch(service->eqn.localPart) {

				case 14:/* KeyInfo */	

								service->exiMsg.V2G_Message.Header->Security.Signature->isused.KeyInfo=1;
		  
				break;	
				case 42:/* Signature */	

								service->exiMsg.V2G_Message.Header->Security.isused.Signature=1;
		  
				break;	

			}
		break;
		case 5:
			switch(service->eqn.localPart) {
				case 105:/* ServiceList */	

								service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->isused.ServiceList=1;
		  
				break;	
				case 120:/* TariffTable */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->isused.TariffTable=1;
		  
				break;	
				case 66:/* PCurrent */	

								service->exiMsg.V2G_Message.Body.MeteringStatusRes->isused.PCurrent=1;
		  
				break;	
				case 56:/* MeterInfo */	

								service->exiMsg.V2G_Message.Body.MeteringStatusRes->isused.MeterInfo=1;
		  
				break;	
				case 45:/* EVSEMaximumVoltageLimit */	

								service->exiMsg.V2G_Message.Body.CurrentDemandRes->isused.EVSEMaximumVoltageLimit=1;
		  
				break;	
				case 43:/* EVSEMaximumCurrentLimit */	

								service->exiMsg.V2G_Message.Body.CurrentDemandRes->isused.EVSEMaximumCurrentLimit=1;
		  
				break;	
				case 44:/* EVSEMaximumPowerLimit */	

								service->exiMsg.V2G_Message.Body.CurrentDemandRes->isused.EVSEMaximumPowerLimit=1;
		  
				break;	

			}
		break;
		case 6:
			switch(service->eqn.localPart) {
				case 110:/* Service */	

								service->exiMsg.V2G_Message.Body.ServiceDiscoveryRes->ServiceList.arraylen.Service++;
		  
				break;	
				case 114:/* ServiceCharge */	

								service->exiMsg.V2G_Message.Body.ServiceDetailRes->isused.ServiceCharge=1;
		  
				break;	
				case 112:/* ServiceCertificate */	

								service->exiMsg.V2G_Message.Body.ServiceDetailRes->isused.ServiceCertificate=1;
		  
				break;	
				case 116:/* ServiceCustom */	

								service->exiMsg.V2G_Message.Body.ServiceDetailRes->isused.ServiceCustom=1;
		  
				break;	
				case 124:/* ServiceRCS */	

								service->exiMsg.V2G_Message.Body.ServiceDetailRes->isused.ServiceRCS=1;
		  
				break;	
				case 121:/* ServiceInternet */	

								service->exiMsg.V2G_Message.Body.ServiceDetailRes->isused.ServiceInternet=1;
		  
				break;	
				case 137:/* SubCertificates */	

					if( service->idPath.id[-1] == -1)
				{
								service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractSignatureCertChain.isused.SubCertificates=1;

				} else if(service->idPath.id[-1] == -1)
				{
								service->exiMsg.V2G_Message.Body.CertificateUpdateRes->ContractEncryptionCertChain.isused.SubCertificates=1;

				} else if(service->idPath.id[-1] == -1)
				{
								service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractSignatureCertChain.isused.SubCertificates=1;

				} else if(service->idPath.id[-1] == -1)
				{
								service->exiMsg.V2G_Message.Body.CertificateInstallationRes->ContractEncryptionCertChain.isused.SubCertificates=1;
				}
		  
				break;	
				case 145:/* TariffEntry */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.Tariff[service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff].TariffEntries.arraylen.TariffEntry++;
		  
				break;	
				case 140:/* Tariff */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->TariffTable.arraylen.Tariff++;
		  
				break;	
				case 52:/* EVSEMaximumPowerLimit */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->isused.EVSEMaximumPowerLimit=1;
		  
				break;	
				case 46:/* EVSECurrentRegulationTolerance */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->isused.EVSECurrentRegulationTolerance=1;
		  
				break;	
				case 47:/* EVSEEnergyToBeDelivered */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->DC_EVSEChargeParameter->isused.EVSEEnergyToBeDelivered=1;
		  
				break;	
				case 0:/* AC_EVSEChargeParameter */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->isused.AC_EVSEChargeParameter=1;
		  
				break;	
				case 25:/* DC_EVSEChargeParameter */	

								service->exiMsg.V2G_Message.Body.ChargeParameterDiscoveryRes->isused.DC_EVSEChargeParameter=1;
		  
				break;	
				case 2:/* AC_EVSEStatus */	

					if( service->idPath.id[2] == 82)
				{
								service->exiMsg.V2G_Message.Body.PowerDeliveryRes->isused.AC_EVSEStatus=1;

				} else if(service->idPath.id[2] == 63)
				{
								service->exiMsg.V2G_Message.Body.MeteringStatusRes->isused.AC_EVSEStatus=1;

				} else if(service->idPath.id[2] == 59)
				{
								service->exiMsg.V2G_Message.Body.MeteringReceiptRes->isused.AC_EVSEStatus=1;
				}
		  
				break;	
				case 27:/* DC_EVSEStatus */	

					if( service->idPath.id[2] == 82)
				{
								service->exiMsg.V2G_Message.Body.PowerDeliveryRes->isused.DC_EVSEStatus=1;

				} else if(service->idPath.id[2] == 63)
				{
								service->exiMsg.V2G_Message.Body.MeteringStatusRes->isused.DC_EVSEStatus=1;

				} else if(service->idPath.id[2] == 59)
				{
								service->exiMsg.V2G_Message.Body.MeteringReceiptRes->isused.DC_EVSEStatus=1;
				}
		  
				break;	
				case 75:/* MeterReading */	

								service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.isused.MeterReading=1;
		  
				break;	
				case 135:/* SigMeterReading */	

								service->exiMsg.V2G_Message.Body.MeteringStatusRes->MeterInfo.isused.SigMeterReading=1;
		  
				break;	

			}
		break;
		case 8:
			switch(service->eqn.localPart) {
				case 1:/* Notification */	

								service->exiMsg.V2G_Message.Header->isused.Notification=1;
		  
				break;	
				case 2:/* Security */	

								service->exiMsg.V2G_Message.Header->isused.Security=1;
		  
				break;	

			}
		break;
		

	}
	return 0;
}


/**
 * Deserialize an attribute of the EXI stream
 * @return 0 = 0K; -1 = ERROR
 */
static int deserializeAttributeCharacter(struct EXIService* service)
{
	switch(service->eqn.namespaceURI) {
			case 0:
				switch(service->eqn.localPart) {

					case 2:/* Id */
				if(service->val.type == STRING)
					{

						memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->attr_Id.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
						service->exiMsg.V2G_Message.Header->Security.Signature->attr_Id.arraylen.data = service->val.string.len;
					}

					else
					{
						return -1; /* wrong data type */
					}

					break;
					case 0:/* Algorithm */
						if(service->val.type == STRING)
							{
							if( service->idPath.id[5] == 0)
									{
							memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.CanonicalizationMethod.attr_Algorithm.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
							service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.CanonicalizationMethod.attr_Algorithm.arraylen.data = service->val.string.len;
							}
							else if( service->idPath.id[5] == 43)
							{

								memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.SignatureMethod.attr_Algorithm.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
								service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.SignatureMethod.attr_Algorithm.arraylen.data = service->val.string.len;
							}
							else if( service->idPath.id[6] == 5)
							{

								memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.Reference.DigestMethod.attr_Algorithm.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
								service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.Reference.DigestMethod.attr_Algorithm.arraylen.data = service->val.string.len;
							}
						}
						break;
						case 6:/* URI */
							if(service->val.type == STRING)
								{

								memcpy(service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.Reference.attr_URI.data, service->val.string.codepoints,service->val.string.len*sizeof(uint32_t));
								service->exiMsg.V2G_Message.Header->Security.Signature->SignedInfo.Reference.attr_URI.arraylen.data = service->val.string.len;

							}
						break;
				}
			break;
	}

	return 0;
}

 
 
 /** 
 * Deserialize the EXI stream
 * @return 0 = 0K; -1 = ERROR
 */
static int deserializeMessage(struct EXIService* service)
{
	int noEndOfDocument = 1; /* true */
	int returnCode=0;
	

	do {
			exiDecodeNextEvent(&(service->inStream), &(service->stateDecode), &(service->event));
			if (returnCode < 0) {
				printf("[ERROR] %d \n", returnCode);
				return returnCode;
			}

			switch (service->event) {
			case START_DOCUMENT:

				returnCode = exiDecodeStartDocument(&(service->inStream), &(service->stateDecode));

				break;
			case END_DOCUMENT:

				returnCode = exiDecodeEndDocument(&(service->inStream), &(service->stateDecode));
				noEndOfDocument = 0; /* false */
				break;
			case START_ELEMENT:
				returnCode = exiDecodeStartElement(&(service->inStream), &(service->stateDecode), &(service->eqn));
				service->idPath.id[service->idPath.pos++]=service->eqn.localPart;
				 
				break;
			case END_ELEMENT:

				returnCode = exiDecodeEndElement(&(service->inStream), &(service->stateDecode), &(service->eqn));
				service->idPath.pos--;
				 
				returnCode = deserializeElement(service);
				break;
			case CHARACTERS:
				/* decode */
				returnCode = exiDecodeCharacters(&(service->inStream), &(service->stateDecode), &(service->val));
				 
				/* assign character data to the v2g message structure */
				returnCode = deserializeElementCharacter(service);
				break;
			case ATTRIBUTE:
				/* decode */
				returnCode = exiDecodeAttribute(&(service->inStream), &(service->stateDecode), &(service->eqn), &(service->val));
				returnCode = deserializeAttributeCharacter(service);
				break;
			default:
				/* ERROR */
				return -1;
			}

		} while (noEndOfDocument);

	return 0;
}



 
 
 /* Initialize the v2g client */
int init_v2gServiceClient(struct EXIService* service, bytes_t bytes, string_ucs_t string, uint8_t* inStream, size_t max_inStream_size, uint8_t* outStream, size_t max_outStream_size, uint16_t transportHeaderOffset)
{

	/* init byte array */
	 service->val.binary = bytes;

	/* init string array */
	 service->val.string = string;

	 /* init input / output stream */
	 service->inStream.data=inStream;
	 service->inStream.size=max_inStream_size;

	 service->outStream.data=outStream;
	 service->outStream.size=max_outStream_size;

	/* init offset for transport protocoll */
	 service->transportHeaderOffset=transportHeaderOffset;

	return 0;
}

