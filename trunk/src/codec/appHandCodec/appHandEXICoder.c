/*
 * Copyright (C) 2007-2013 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.8
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer.com</p>
 * <p>Schema: input/appHandshake/V2G_CI_AppProtocol.xsd</p>
 *
 *
 ********************************************************************/



#ifndef EXI_appHand_CODER_C
#define EXI_appHand_CODER_C

#include "appHandEXICoder.h"

#include "EXIConfig.h"
#include "EXITypes.h"
#include "EXIOptions.h"
#include "BitInputStream.h"
#include "DecoderChannel.h"
#include "ErrorCodes.h"

#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
#include "StringValueTable.h"
#endif /* DYNAMIC_ALLOCATION */


#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'qnameID' */
#endif /* __GNUC__ */
int exi_appHand_AddStringValue(exi_state_t* state, exi_string_ucs_t* sv, uint16_t qnameID) {
	int errn = 0;
#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0
	/* increment global string count */
#if EXI_OPTION_VALUE_PARTITION_CAPACITY < 0
	state->stringTable.numberOfGlobalStrings++;
#else /* EXI_OPTION_VALUE_PARTITION_CAPACITY < 0 */
	if (state->stringTable.numberOfGlobalStrings < EXI_OPTION_VALUE_PARTITION_CAPACITY) {
		state->stringTable.numberOfGlobalStrings++;
	}
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY < 0 */
	/* increment local string count */
	if (qnameID < state->stringTable.sizeLocalStrings) {
#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
		errn = exiAddStringValue(&(state->stringTable), sv, qnameID);
#endif /* DYNAMIC_ALLOCATION */
		state->stringTable.numberOfLocalStrings[qnameID]++;
		/* printf("\tSV %d:  lv=%d  and gv=%d \n", qnameID, state->numberOfLocalStrings[qnameID], state->numberOfGlobalStrings);*/
	} else {
		/* currently we do support a set of qnames only */
		errn = EXI_ERROR_OUT_OF_QNAMES;
	}
#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */

	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'qnameID' */
#endif /* __GNUC__ */


int exi_appHand_PushStack(exi_state_t* state, int16_t newState, uint16_t qnameID) {
	int errn = 0;
	/* eqname_t* eqn*/
	if ((state->stackIndex + 1) < EXI_ELEMENT_STACK_SIZE) {
		state->grammarStack[++state->stackIndex] = newState;
		/* qname */
		state->elementStack[state->stackIndex] = qnameID;
	} else {
		errn = EXI_ERROR_OUT_OF_GRAMMAR_STACK;
	}

	return errn;
}

int exi_appHand_PopStack(exi_state_t* state) {
	int errn = 0;
	if (state->stackIndex >= 1) {
		state->stackIndex--;
	} else {
		errn = EXI_ERROR_OUT_OF_BOUNDS;
	}
	return errn;
}

int exi_appHand_HandleXsiNilTrue(exi_state_t* state) {
	switch (state->grammarStack[state->stackIndex]) {

	}

	return EXI_ERROR_UNEXPECTED_ATTRIBUTE_XSI_NIL;
}

int exi_appHand_HandleXsiType(exi_state_t* state, exi_eqname_t* xsiType) {
	switch(xsiType->namespaceURI) {
	case 0:
		switch(xsiType->localPart) {
		}
		break;
	case 1:
		switch(xsiType->localPart) {
		}
		break;
	case 2:
		switch(xsiType->localPart) {
		}
		break;
	case 3:
		switch(xsiType->localPart) {
		case 0:
			/* {3}0,ENTITIES */
			state->grammarStack[state->stackIndex] = 47;
			break;
		case 1:
			/* {3}1,ENTITY */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 2:
			/* {3}2,ID */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 3:
			/* {3}3,IDREF */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 4:
			/* {3}4,IDREFS */
			state->grammarStack[state->stackIndex] = 47;
			break;
		case 5:
			/* {3}5,NCName */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 6:
			/* {3}6,NMTOKEN */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 7:
			/* {3}7,NMTOKENS */
			state->grammarStack[state->stackIndex] = 47;
			break;
		case 8:
			/* {3}8,NOTATION */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 9:
			/* {3}9,Name */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 10:
			/* {3}10,QName */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 11:
			/* {3}11,anySimpleType */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 12:
			/* {3}12,anyType */
			state->grammarStack[state->stackIndex] = 49;
			break;
		case 13:
			/* {3}13,anyURI */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 14:
			/* {3}14,base64Binary */
			state->grammarStack[state->stackIndex] = 51;
			break;
		case 15:
			/* {3}15,boolean */
			state->grammarStack[state->stackIndex] = 53;
			break;
		case 16:
			/* {3}16,byte */
			state->grammarStack[state->stackIndex] = 55;
			break;
		case 17:
			/* {3}17,date */
			state->grammarStack[state->stackIndex] = 57;
			break;
		case 18:
			/* {3}18,dateTime */
			state->grammarStack[state->stackIndex] = 59;
			break;
		case 19:
			/* {3}19,decimal */
			state->grammarStack[state->stackIndex] = 61;
			break;
		case 20:
			/* {3}20,double */
			state->grammarStack[state->stackIndex] = 63;
			break;
		case 21:
			/* {3}21,duration */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 22:
			/* {3}22,float */
			state->grammarStack[state->stackIndex] = 63;
			break;
		case 23:
			/* {3}23,gDay */
			state->grammarStack[state->stackIndex] = 65;
			break;
		case 24:
			/* {3}24,gMonth */
			state->grammarStack[state->stackIndex] = 67;
			break;
		case 25:
			/* {3}25,gMonthDay */
			state->grammarStack[state->stackIndex] = 69;
			break;
		case 26:
			/* {3}26,gYear */
			state->grammarStack[state->stackIndex] = 71;
			break;
		case 27:
			/* {3}27,gYearMonth */
			state->grammarStack[state->stackIndex] = 73;
			break;
		case 28:
			/* {3}28,hexBinary */
			state->grammarStack[state->stackIndex] = 75;
			break;
		case 29:
			/* {3}29,int */
			state->grammarStack[state->stackIndex] = 77;
			break;
		case 30:
			/* {3}30,integer */
			state->grammarStack[state->stackIndex] = 77;
			break;
		case 31:
			/* {3}31,language */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 32:
			/* {3}32,long */
			state->grammarStack[state->stackIndex] = 77;
			break;
		case 33:
			/* {3}33,negativeInteger */
			state->grammarStack[state->stackIndex] = 77;
			break;
		case 34:
			/* {3}34,nonNegativeInteger */
			state->grammarStack[state->stackIndex] = 79;
			break;
		case 35:
			/* {3}35,nonPositiveInteger */
			state->grammarStack[state->stackIndex] = 77;
			break;
		case 36:
			/* {3}36,normalizedString */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 37:
			/* {3}37,positiveInteger */
			state->grammarStack[state->stackIndex] = 79;
			break;
		case 38:
			/* {3}38,short */
			state->grammarStack[state->stackIndex] = 77;
			break;
		case 39:
			/* {3}39,string */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 40:
			/* {3}40,time */
			state->grammarStack[state->stackIndex] = 80;
			break;
		case 41:
			/* {3}41,token */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 42:
			/* {3}42,unsignedByte */
			state->grammarStack[state->stackIndex] = 13;
			break;
		case 43:
			/* {3}43,unsignedInt */
			state->grammarStack[state->stackIndex] = 79;
			break;
		case 44:
			/* {3}44,unsignedLong */
			state->grammarStack[state->stackIndex] = 79;
			break;
		case 45:
			/* {3}45,unsignedShort */
			state->grammarStack[state->stackIndex] = 79;
			break;
		}
		break;
	case 4:
		switch(xsiType->localPart) {
		case 0:
			/* {4}0,AppProtocolType */
			state->grammarStack[state->stackIndex] = 3;
			break;
		case 1:
			/* {4}1,idType */
			state->grammarStack[state->stackIndex] = 13;
			break;
		case 2:
			/* {4}2,priorityType */
			state->grammarStack[state->stackIndex] = 16;
			break;
		case 3:
			/* {4}3,protocolNameType */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 4:
			/* {4}4,protocolNamespaceType */
			state->grammarStack[state->stackIndex] = 4;
			break;
		case 5:
			/* {4}5,responseCodeType */
			state->grammarStack[state->stackIndex] = 41;
			break;
		}
		break;
	}


	return 0;
}


int exi_appHand_RetrieveAndPushGlobalGrammar(exi_state_t* state, uint16_t qnameID) {
	int errn = EXI_ERROR_OUT_OF_RUNTIME_GRAMMAR_STACK;
	int i;
	int found = 1;

	/* schema-informed global element --> Stack ID */
	switch(qnameID) {
	case 65:
		errn = exi_appHand_PushStack(state, 2, 65);
		break;
	case 66:
		errn = exi_appHand_PushStack(state, 40, 66);
		break;

	default:
		found = 0;
		break;
	}

	if (!found) {
		/* retrieve existing grammar for qname if any available */
		for(i=0; i<state->numberOfRuntimeGrammars && !found; i+=2) {
			if( state->runtimeGrammars[i].qnameID == qnameID ) {
				/* runtime grammar exists already */

				/* push element stack */
				errn = exi_appHand_PushStack(state, (int16_t)((i+1) * (-1)), qnameID);
				found = 1;
			}
		}

		/* create new runtime grammars if possible and not found already */
		if(!found && (state->numberOfRuntimeGrammars + 2) < (MAX_NUMBER_OF_RUNTIME_ELEMENTS * 2) ) {
			/* StartTagContent StackIds: -1, -3, -5, ... */
			state->runtimeGrammars[state->numberOfRuntimeGrammars].qnameID = qnameID;
			state->runtimeGrammars[state->numberOfRuntimeGrammars].numberOfProductions = 0;
			state->runtimeGrammars[state->numberOfRuntimeGrammars].hasXsiType = 0;
			state->runtimeGrammars[state->numberOfRuntimeGrammars].hasEE = 0;
			/* ElementContent StackIds: -2, -4, -6, ... */
			state->runtimeGrammars[state->numberOfRuntimeGrammars+1].qnameID = qnameID;
			state->runtimeGrammars[state->numberOfRuntimeGrammars+1].numberOfProductions = 1;
			state->runtimeGrammars[state->numberOfRuntimeGrammars+1].hasXsiType = 0;
			state->runtimeGrammars[state->numberOfRuntimeGrammars+1].hasEE = 1;

			/* push element stack */
			errn = exi_appHand_PushStack(state, (int16_t)((state->numberOfRuntimeGrammars+1) * (-1)), qnameID);

			state->numberOfRuntimeGrammars = (uint16_t)(state->numberOfRuntimeGrammars + 2);
		}
	}

	return errn;
}

#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'qnameID' */
#endif /* __GNUC__ */
int exi_appHand_LearnAttribute(exi_state_t* state, uint16_t uriID, uint16_t localID) {
	int errn = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	int16_t runtimeID;

	if (currentID < 0) {
		runtimeID = (int16_t)((currentID+1)*(-1));

		if (uriID == 2 && localID == 1 ) {
			/* xsi:type: learned just once */
			if(!state->runtimeGrammars[runtimeID].hasXsiType) {
				/* hasXsiType stores production position PLUS 1 (one) */
				state->runtimeGrammars[runtimeID].hasXsiType = ++state->runtimeGrammars[runtimeID].numberOfProductions;
			}
		} else {
			/* increment production count */
			++state->runtimeGrammars[runtimeID].numberOfProductions;
			/* TODO store production information. Note: not necessary in restricted profile */
		}
	} else {
		/* schema-informed grammar do no evolve */
	}

	return errn;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'qnameID' */
#endif /* __GNUC__ */

int exi_appHand_LearnEndElement(exi_state_t* state) {
	int errn = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	int16_t runtimeID;

	if (currentID < 0) {
		if( exi_appHand_IsStartContent(currentID) ) {
			/* check whether EE with an event code of length 1 does not exist in the current element grammar already */
			runtimeID = (int16_t)((currentID+1)*(-1));

			if(!state->runtimeGrammars[runtimeID].hasEE) {
				/* hasXsiType stores production position PLUS 1 (one) */
				state->runtimeGrammars[runtimeID].hasEE = ++state->runtimeGrammars[runtimeID].numberOfProductions;
			}
		} else {
			/* ElementContent disposes already of an EE event */
		}
	} else {
		/* schema-informed grammar do no evolve */
	}

	return errn;
}


/*
 * RUNTIME RULES
 * each rule has 2 ids and counts backwards from -1, -2, ...
 * 1) StartTagContent (e.g., -1, -3, -5, ...)
 * 2) ElementContent (e.g., -2, -4, -6)
 *
 */

int exi_appHand_IsStartContent(int16_t ruleID) {
	/* Note: only for built-in element grammars */
	return (ruleID % 2 != 0);
}

int exi_appHand_MoveToElementContentRule(exi_state_t* state) {
	int errn = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	int found = 1;


	switch (currentID) {
	case 65:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 66;
		break;
	case 41:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] --> Element[CHARACTERS[ENUMERATION]] */
		state->grammarStack[state->stackIndex] = 42;
		break;
	case 40:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] --> Element[START_ELEMENT(ResponseCode)] */
		state->grammarStack[state->stackIndex] = 44;
		break;
	case 4:
		/* FirstStartTag[CHARACTERS[STRING]] --> Element[CHARACTERS[STRING]] */
		state->grammarStack[state->stackIndex] = 7;
		break;
	case 77:
		/* FirstStartTag[CHARACTERS[INTEGER]] --> Element[CHARACTERS[INTEGER]] */
		state->grammarStack[state->stackIndex] = 78;
		break;
	case 2:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] --> Element[START_ELEMENT(AppProtocol)] */
		state->grammarStack[state->stackIndex] = 38;
		break;
	case 75:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] --> Element[CHARACTERS[BINARY_HEX]] */
		state->grammarStack[state->stackIndex] = 76;
		break;
	case 0:
		/* Document[START_DOCUMENT] --> Document[START_DOCUMENT] */
	case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] --> DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
	case 5:
		/* Element[END_ELEMENT] --> Element[END_ELEMENT] */
	case 6:
		/* Element[] --> Element[] */
	case 7:
		/* Element[CHARACTERS[STRING]] --> Element[CHARACTERS[STRING]] */
	case 8:
		/* Element[START_ELEMENT(VersionNumberMajor)] --> Element[START_ELEMENT(VersionNumberMajor)] */
	case 10:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] --> Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] --> Element[START_ELEMENT(VersionNumberMinor)] */
	case 12:
		/* Element[START_ELEMENT(SchemaID)] --> Element[START_ELEMENT(SchemaID)] */
	case 14:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] --> Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 15:
		/* Element[START_ELEMENT(Priority)] --> Element[START_ELEMENT(Priority)] */
	case 17:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] --> Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 18:
		/* Element[START_ELEMENT(ProtocolNamespace)] --> Element[START_ELEMENT(ProtocolNamespace)] */
	case 19:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 20:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 21:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 22:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] --> Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol)] --> Element[START_ELEMENT(AppProtocol)] */
	case 39:
		/* DocEnd[END_DOCUMENT] --> DocEnd[END_DOCUMENT] */
	case 42:
		/* Element[CHARACTERS[ENUMERATION]] --> Element[CHARACTERS[ENUMERATION]] */
	case 43:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] --> Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 44:
		/* Element[START_ELEMENT(ResponseCode)] --> Element[START_ELEMENT(ResponseCode)] */
	case 45:
		/* Fragment[START_DOCUMENT] --> Fragment[START_DOCUMENT] */
	case 46:
		/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] --> FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */
	case 48:
		/* Element[CHARACTERS[LIST]] --> Element[CHARACTERS[LIST]] */
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] --> Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 52:
		/* Element[CHARACTERS[BINARY_BASE64]] --> Element[CHARACTERS[BINARY_BASE64]] */
	case 54:
		/* Element[CHARACTERS[BOOLEAN]] --> Element[CHARACTERS[BOOLEAN]] */
	case 56:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] --> Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 58:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 60:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 62:
		/* Element[CHARACTERS[DECIMAL]] --> Element[CHARACTERS[DECIMAL]] */
	case 64:
		/* Element[CHARACTERS[FLOAT]] --> Element[CHARACTERS[FLOAT]] */
	case 66:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 68:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 70:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 72:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 74:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
	case 76:
		/* Element[CHARACTERS[BINARY_HEX]] --> Element[CHARACTERS[BINARY_HEX]] */
	case 78:
		/* Element[CHARACTERS[INTEGER]] --> Element[CHARACTERS[INTEGER]] */
	case 81:
		/* Element[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		break;
	case 51:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] --> Element[CHARACTERS[BINARY_BASE64]] */
		state->grammarStack[state->stackIndex] = 52;
		break;
	case 73:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 74;
		break;
	case 80:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 81;
		break;
	case 9:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] --> Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 79:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] --> Element[CHARACTERS[UNSIGNED_INTEGER]] */
		state->grammarStack[state->stackIndex] = 10;
		break;
	case 67:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 68;
		break;
	case 47:
		/* FirstStartTag[CHARACTERS[LIST]] --> Element[CHARACTERS[LIST]] */
		state->grammarStack[state->stackIndex] = 48;
		break;
	case 13:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] --> Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		state->grammarStack[state->stackIndex] = 14;
		break;
	case 63:
		/* FirstStartTag[CHARACTERS[FLOAT]] --> Element[CHARACTERS[FLOAT]] */
		state->grammarStack[state->stackIndex] = 64;
		break;
	case 3:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] --> Element[START_ELEMENT(ProtocolNamespace)] */
		state->grammarStack[state->stackIndex] = 18;
		break;
	case 53:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] --> Element[CHARACTERS[BOOLEAN]] */
		state->grammarStack[state->stackIndex] = 54;
		break;
	case 16:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] --> Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		state->grammarStack[state->stackIndex] = 17;
		break;
	case 59:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 60;
		break;
	case 55:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] --> Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		state->grammarStack[state->stackIndex] = 56;
		break;
	case 69:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 70;
		break;
	case 61:
		/* FirstStartTag[CHARACTERS[DECIMAL]] --> Element[CHARACTERS[DECIMAL]] */
		state->grammarStack[state->stackIndex] = 62;
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] --> Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		state->grammarStack[state->stackIndex] = 50;
		break;
	case 57:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 58;
		break;
	case 71:
		/* FirstStartTag[CHARACTERS[DATETIME]] --> Element[CHARACTERS[DATETIME]] */
		state->grammarStack[state->stackIndex] = 72;
		break;

	default:
		found = 0;
		break;
	}

	if(!found) {
		if (currentID < 0) {
			if(exi_appHand_IsStartContent(currentID)) {
				state->grammarStack[state->stackIndex] = (int16_t)(currentID - 1);
			}
		} else {
			errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE_MOVE_TO_CONTENT_RULE;
		}
	}

	return errn;
}


#endif

