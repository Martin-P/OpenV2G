/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.7
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer.com</p>
 ********************************************************************/



#ifndef EXI_appHand_DECODER_C
#define EXI_appHand_DECODER_C


#include "appHandEXIDecoder.h"

#include "EXITypes.h"
#include "EXIOptions.h"
#include "BitInputStream.h"
#include "DecoderChannel.h"
#include "CoderChannel.h"

#include "StringTable.h"
#include "appHandNameTableEntries.h"
#include "MethodsBag.h"

#include "appHandEXICoder.h"
#include "EXIHeaderDecoder.h"
#include "ErrorCodes.h"

#include "appHandQNames.h"
#include "appHandQNameDefines.h"



/* local variables */
static uint32_t xsi;
static uint32_t bits;
static int errn;
static exi_event_t currEvent;

#define URI_CODEPOINTS_SIZE 35
#define LOCALNAME_CODEPOINTS_SIZE 25

uint32_t codepointsUri[URI_CODEPOINTS_SIZE];
uint32_t codepointsLocalName[LOCALNAME_CODEPOINTS_SIZE];

/*static exi_string_ucs_t stringUri = {URI_CODEPOINTS_SIZE, codepointsUri, 0};*/
/*static exi_name_entry_t uri = {EXI_NAME_ENTRY_TYPE_ID, 0, {URI_CODEPOINTS_SIZE, codepointsUri, 0}};*/
/*static exi_name_entry_t localName = {EXI_NAME_ENTRY_TYPE_ID, 0, {LOCALNAME_CODEPOINTS_SIZE, codepointsLocalName, 0}};*/
static exi_qname_t _qname = {
		{EXI_NAME_ENTRY_TYPE_ID, 0, {URI_CODEPOINTS_SIZE, codepointsUri, 0}},
		{EXI_NAME_ENTRY_TYPE_ID, 0, {LOCALNAME_CODEPOINTS_SIZE, codepointsLocalName, 0}}
};


static int _decodeNBitIntegerValue(bitstream_t* stream, exi_integer_t* iv, uint16_t nbits, int32_t lowerBound) {
	int errn;
	uint32_t val;

	errn = decodeNBitUnsignedInteger(stream, nbits, &val);
	if(errn) {
		return errn;
	}

	/* TODO map integer value more fine-grained */
	iv->type = EXI_INTEGER_32;
	iv->val.int32 = val + lowerBound;

	return errn;
}



static int exiDecodeNext2Event(bitstream_t* stream, exi_state_t* state,
		exi_event_t* nextEvent) {
	uint32_t eventCode2 = 0;
	int16_t ruleID = state->grammarStack[state->stackIndex];

	switch (ruleID) {
	case 7:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 11:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 10:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 18:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 20:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 21:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 25:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 24:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 29:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 36:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 48:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 49:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 53:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 55:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 57:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 58:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 45:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 64:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 16:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 68:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 46:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 69:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 74:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 15:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 76:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 78:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 79:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 80:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 35:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 44:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 86:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 89:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 93:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 98:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 99:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 101:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 100:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 102:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 104:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 106:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 111:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 43:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 112:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 122:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 130:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 132:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 133:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 134:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 135:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
	case 138:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 141:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 143:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 144:
		/* FirstStartTag[CHARACTERS[LIST]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_END_ELEMENT_UNDECLARED;
			return errn;
		case 1:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_TYPE;
			return errn;
		case 2:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_NIL;
			return errn;
		case 3:
			*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED;
			return errn;
		case 4:
			*nextEvent = EXI_EVENT_ATTRIBUTE_INVALID_VALUE;
			errn = decodeNBitUnsignedInteger(stream, 0, &state->eventCode);
			state->eventCode -= 1;
			return errn;
		case 5:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 6:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;
	case 22:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 50:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_TYPE;
			return errn;
		case 1:
			*nextEvent = EXI_EVENT_ATTRIBUTE_XSI_NIL;
			return errn;
		case 2:
			*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED;
			return errn;
		case 3:
			*nextEvent = EXI_EVENT_ATTRIBUTE_INVALID_VALUE;
			errn = decodeNBitUnsignedInteger(stream, 0, &state->eventCode);
			state->eventCode -= 1;
			return errn;
		case 4:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 5:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;
	case 1:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 12:
		/* Element[CHARACTERS[STRING]] */
	case 17:
		/* Element[CHARACTERS[INTEGER]] */
	case 19:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 28:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 30:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 32:
		/* Element[CHARACTERS[STRING]] */
	case 33:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 37:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 38:
		/* Element[CHARACTERS[STRING]] */
	case 40:
		/* Element[CHARACTERS[STRING]] */
	case 41:
		/* Element[CHARACTERS[STRING]] */
	case 47:
		/* Element[CHARACTERS[INTEGER]] */
	case 52:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 54:
		/* Element[CHARACTERS[STRING]] */
	case 56:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 59:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 31:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 62:
		/* Element[CHARACTERS[FLOAT]] */
	case 63:
		/* Element[CHARACTERS[DATETIME]] */
	case 65:
		/* Element[CHARACTERS[LIST]] */
	case 67:
		/* Element[CHARACTERS[STRING]] */
	case 70:
		/* Element[CHARACTERS[STRING]] */
	case 71:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 75:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 77:
		/* Element[CHARACTERS[STRING]] */
	case 81:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 82:
		/* Element[CHARACTERS[DATETIME]] */
	case 83:
		/* Element[CHARACTERS[INTEGER]] */
	case 84:
		/* Element[CHARACTERS[DATETIME]] */
	case 85:
		/* Element[CHARACTERS[STRING]] */
	case 87:
		/* Element[CHARACTERS[STRING]] */
	case 88:
		/* Element[CHARACTERS[DATETIME]] */
	case 34:
		/* Element[START_ELEMENT(SchemaID)] */
	case 91:
		/* Element[CHARACTERS[INTEGER]] */
	case 94:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 95:
		/* Element[CHARACTERS[LIST]] */
	case 96:
		/* Element[CHARACTERS[STRING]] */
	case 103:
		/* Element[CHARACTERS[FLOAT]] */
	case 107:
		/* Element[CHARACTERS[INTEGER]] */
	case 108:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 114:
		/* Element[CHARACTERS[STRING]] */
	case 116:
		/* Element[CHARACTERS[DECIMAL]] */
	case 117:
		/* Element[START_ELEMENT(ResponseCode)] */
	case 118:
		/* Element[CHARACTERS[STRING]] */
	case 119:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 120:
		/* Element[CHARACTERS[STRING]] */
	case 121:
		/* Element[CHARACTERS[DATETIME]] */
	case 123:
		/* Element[CHARACTERS[DATETIME]] */
	case 126:
		/* Element[CHARACTERS[DATETIME]] */
	case 90:
		/* Element[START_ELEMENT(Priority)] */
	case 131:
		/* Element[CHARACTERS[STRING]] */
	case 136:
		/* Element[CHARACTERS[INTEGER]] */
	case 137:
		/* Element[CHARACTERS[STRING]] */
	case 140:
		/* Element[CHARACTERS[LIST]] */
	case 139:
		/* Element[CHARACTERS[DATETIME]] */
	case 145:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
		errn = decodeNBitUnsignedInteger(stream, 2, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_END_ELEMENT_UNDECLARED;
			return errn;
		case 1:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 2:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;
	case 3:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 8:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 2:
		/* Element[END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 39:
		/* Element[END_ELEMENT] */
	case 60:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 72:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 9:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 97:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 109:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 92:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 115:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 124:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 51:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 128:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 66:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 110:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 61:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 127:
		/* Element[END_ELEMENT] */
	case 113:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 125:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 129:
		/* Element[END_ELEMENT] */
	case 73:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 1, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 1:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;

	default:
		if (ruleID < 0) {
			/* built-in element grammar */
			if ( exi_appHand_IsStartContent(ruleID) ) {
				/* TODO generate 2nd level productions */

				/* StartTagContent grammar */
				errn = decodeNBitUnsignedInteger(stream, 2, &eventCode2);
				if(errn) {
					return errn;
				}
				switch(eventCode2) {
				case 0:
					/* 0: EE */
					*nextEvent = EXI_EVENT_END_ELEMENT_UNDECLARED;
					break;
				case 1:
					/* 1: AT(*) */
					*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED;
					break;
				case 2:
					/* 2: SE(*) */
					*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
					break;
				case 3:
					/* 3: CH */
					*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
					break;
				default:
					return EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
					break;
				}
				return errn;
			} else {
				/* TODO generate 2nd level productions */

				/* ElementContent grammar */
				errn = decodeNBitUnsignedInteger(stream, 1, &eventCode2);
				if(errn) {
					return errn;
				}
				switch(eventCode2) {
				case 0:
					/* 0: SE(*) */
					*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED;
					break;
				case 1:
					/* 1: CH */
					*nextEvent = EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED;
					break;
				default:
					return EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
					break;
				}



			}

		} else {
			*nextEvent = EXI_EVENT_ERROR;
			return EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
		}
		break;
	}

	return EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
}



static int _exiDecodeNamespaceUri(bitstream_t* stream, exi_state_t* state,
		exi_name_entry_t* uri) {
/*		exi_string_ascii_t* namespaceURI, uint32_t* uriID) {*/
	uint16_t uriSize, uriCodingLength;
	uint32_t uriID;
	int errn;

	errn = exiGetUriSize(&state->nameTablePrepopulated, &state->nameTableRuntime, &uriSize);
	if (errn) {
		return errn;
	}
	/* URI Entries + 1 */
	errn = exiGetCodingLength(uriSize + 1, &uriCodingLength);
	if (errn) {
		return errn;
	}

	errn = decodeNBitUnsignedInteger(stream, uriCodingLength, &uriID);
	if (errn) {
		return errn;
	}

	if (uriID == 0) {
		/* uri string value was not found */
		/* ==> zero (0) as an n-nit unsigned integer */
		/* followed by uri encoded as string */
		uri->type = EXI_NAME_ENTRY_TYPE_STRING_AND_ID;
		errn = decodeString(stream, &uri->str);
		if (errn) {
			return errn;
		}
		/* after encoding string value is added to table */
		errn = exiAddUri(&state->nameTablePrepopulated, &state->nameTableRuntime); /*, namespaceURI->chars); */
		if (errn) {
			return errn;
		}
		uri->id = uriSize;
		/* uriID = uriSize; */
	} else {
		/* uri string value found */
		/* ==> value(i+1) is encoded as n-bit unsigned integer */
		uri->type = EXI_NAME_ENTRY_TYPE_ID;
		uri->id = (uint16_t)(uriID - 1);
		/* *uriID = *uriID - 1; */
	}

	return 0;
}

static int _exiDecodeLocalName(bitstream_t* stream, exi_state_t* state,
		uint16_t uriID, exi_name_entry_t* localName) {
/*		exi_string_ascii_t* localName,
		uint32_t* localNameID, uint32_t uriID) { */
	uint32_t localNameID;
	uint16_t slen;
	uint16_t localNameSize;
	uint16_t localNameCodingLength;


	int errn = decodeUnsignedInteger16(stream, &slen);
	if (errn) {
		return errn;
	}

	if (slen > 0) {
		/* string value was not found in local partition */
		/* ==> string literal is encoded as a String */
		/* with the length of the string incremented by one */
		localName->type = EXI_NAME_ENTRY_TYPE_STRING_AND_ID;
		if (slen-- >= (localName->str.size) ) {
			return EXI_ERROR_OUT_OF_BOUNDS;
		}
		localName->str.len = slen;
		errn = decodeCharacters(stream, slen, localName->str.codepoints);

		/*if (slen-- >= localName->size) {
			return EXI_ERROR_OUT_OF_BOUNDS;
		}
		errn = decodeCharactersASCII(stream, slen, localName->chars); */

		if (errn) {
			return errn;
		}
		/* After encoding the string value, it is added to the string table */
		/* partition and assigned the next available compact identifier */
		errn = exiAddLocalName(&state->nameTablePrepopulated, &state->nameTableRuntime, uriID, &localName->id); /* uriID); *//*, localName->chars); */

		/*if (errn) {
			return errn;
		}*/
		/* TODO UCD Profile */
		/* qname = addLocalName(localName, uriID); */
	} else {
		/* string value found in local partition */
		/* ==> string value is represented as zero (0) encoded as an */
		/* Unsigned Integer */
		/* followed by an the compact identifier of the string value as an */
		/* n-bit unsigned integer */
		/* n is log2 m and m is the number of entries in the string table */
		/* partition */
		localName->type = EXI_NAME_ENTRY_TYPE_ID;
		errn = exiGetLocalNameSize(&state->nameTablePrepopulated, &state->nameTableRuntime, uriID, &localNameSize); /* uriID, &localNameSize); */
		if (errn) {
			return errn;
		}
		errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
		if (errn) {
			return errn;
		}
		errn = decodeNBitUnsignedInteger(stream, localNameCodingLength, &localNameID); /*  localNameID);*/
		localName->id = (uint16_t)(localNameID);
		/*if (errn) {
			return errn;
		}*/
	}

	return errn;
}

static int _exiDecodeQName(bitstream_t* stream, exi_state_t* state,
		uint16_t* qnameID,  exi_qname_t* qname) {

	/*uint32_t uriID;
	uint32_t localNameID;*/
	/* const char * clocalName; */

	/* uri */
	int errn =_exiDecodeNamespaceUri(stream, state, &qname->uri); /* &qname->namespaceURI, &uriID); */
	if (errn) {
		return errn;
	}
	/* localName */
	errn = _exiDecodeLocalName(stream, state, qname->uri.id, &qname->localName); /* &qname->localName, &localNameID, uriID); */
	if (errn) {
		return errn;
	}

	/*
	errn = exiGetLocalName(nameTable, runtimeTable, uriID, localNameID, &clocalName);
	if (errn) {
		return errn;
	}
	strcpy ( qname->localName.chars, clocalName );
	*/

	if (_qname.localName.type == EXI_NAME_ENTRY_TYPE_STRING_AND_ID) {
		errn = exiappHandAddEQName(state, qnameID, qname->uri.id, qname->localName.id);
	} else {
		/* IDs known --> retrieve qnameID */
		errn = exiappHandGetQNameID(state, qname->uri.id, qname->localName.id, qnameID);
	}


	return errn;
}


static int _exiDecodeStartElement(exi_state_t* state, uint16_t qnameID,
		uint16_t stackId, uint16_t newState) {
	/*uint16_t ns, uint16_t ln, uint16_t qn, */
	/*se->namespaceURI = ns;
	se->localPart = ln;
	se->qname = qn;*/
	/* move on */
	state->grammarStack[state->stackIndex] = stackId;
	/* push element on stack */
	return exi_appHand_PushStack(state, newState, qnameID); /* se);*/
}


int exiappHandGetLastQName(exi_qname_t** qname) {
	*qname = &_qname;
	return 0;
}


int exiappHandDecodeListValue(bitstream_t* stream, exi_state_t* state, uint16_t qnameID, exi_value_t* val, exi_list_t lt) {
	uint32_t uint32;

	val->type = lt.type;

	switch(lt.type) {
	case EXI_DATATYPE_BINARY_BASE64:
	case EXI_DATATYPE_BINARY_HEX:
		errn = decodeBinary(stream, &val->binary);
		break;
	case EXI_DATATYPE_BOOLEAN:
		errn = decodeBoolean(stream, &val->boolean);
		break;
	case EXI_DATATYPE_BOOLEAN_FACET:
		errn = decodeNBitUnsignedInteger(stream, 2, &uint32);
		val->boolean = uint32 > 1;
		break;
	case EXI_DATATYPE_DECIMAL:
		errn = decodeDecimal(stream, &val->decimal);
		break;
	case EXI_DATATYPE_FLOAT:
		errn = decodeFloat(stream, &val->float_me);
		break;
	case EXI_DATATYPE_NBIT_UNSIGNED_INTEGER:
		errn = EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		break;
	case EXI_DATATYPE_UNSIGNED_INTEGER:
		errn = decodeUnsignedInteger(stream, &val->integer);
		break;
	case EXI_DATATYPE_INTEGER:
		errn = decodeInteger(stream, &val->integer);
		break;
	case EXI_DATATYPE_DATETIME:
		errn = decodeDateTime(stream,lt.datetimeType, &val->datetime);
		break;
	case EXI_DATATYPE_STRING:
		errn = decodeStringValue(stream, state, qnameID, &val->str);
		break;
	default:
		return EXI_UNSUPPORTED_LIST_VALUE_TYPE;
	}

	return errn;
}




int exiappHandInitDecoder(bitstream_t* stream, exi_state_t* state,
		exi_name_table_runtime_t runtimeTable, exi_string_table_t stringTable) {
#if EXI_appHandVALUE_PARTITION_CAPACITY != 0
#if EXI_appHandVALUE_MAX_LENGTH != 0
	int i;
#endif /* EXI_appHandVALUE_MAX_LENGTH != 0 */
#endif /* EXI_appHandVALUE_PARTITION_CAPACITY != 0 */
	/* init grammar state */
	state->stackIndex = 0;
	state->grammarStack[0] = DOCUMENT;
	/* name table */
	state->nameTablePrepopulated = exiappHandNameTablePrepopulated;
	state->nameTableRuntime = runtimeTable;
	/* next qname ID */
	state->nextQNameID = EXI_appHandNUMBER_OF_PREPOPULATED_QNAMES;
	/* string table */
	state->stringTable = stringTable;
	state->stringTable.numberOfGlobalStrings = 0;
#if EXI_appHandVALUE_PARTITION_CAPACITY != 0
#if EXI_appHandVALUE_MAX_LENGTH != 0
	for(i=0; i<(state->stringTable.sizeLocalStrings); i++) {
		state->stringTable.numberOfLocalStrings[i] = 0;
	}
#endif /* EXI_appHandVALUE_MAX_LENGTH != 0 */
#endif /* EXI_appHandVALUE_PARTITION_CAPACITY != 0 */

	/* runtime grammars */
	state->numberOfRuntimeGrammars = 0;

	/* Avoid warning: Unused declaration of variable 'name' */
	xsi = 0;
	bits = 0;

	/* decode header */
	return readEXIHeader(stream);
}

int exiappHandDecodeNextEvent(bitstream_t* stream, exi_state_t* state,
		exi_event_t* nextEvent) {
	uint16_t codingLength;
	uint16_t numberOfProductions;
	uint32_t eventCode1;
	int16_t ruleID = state->grammarStack[state->stackIndex];
	state->eventCode = 0;
	errn = 0;

	switch (ruleID) {
	case 3:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 8:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 60:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 72:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 9:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 97:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 109:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 92:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 115:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 124:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 128:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 66:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 110:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 61:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 113:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 125:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 73:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 1:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 2:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 30:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 33:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 31:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 16:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 15:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 34:
		/* Element[START_ELEMENT(SchemaID)] */
	case 94:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 117:
		/* Element[START_ELEMENT(ResponseCode)] */
	case 90:
		/* Element[START_ELEMENT(Priority)] */
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 0:
		/* Document[START_DOCUMENT] */
	case 105:
		/* Fragment[START_DOCUMENT] */
		*nextEvent = EXI_EVENT_START_DOCUMENT;
		break;
	case 14:
		/* DocEnd[END_DOCUMENT] */
		*nextEvent = EXI_EVENT_END_DOCUMENT;
		break;
	case 42:
		/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */
		errn = decodeNBitUnsignedInteger(stream, 4, &state->eventCode);
		switch (state->eventCode) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 9:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		case 10:
			*nextEvent = EXI_EVENT_END_DOCUMENT;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 22:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 50:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_ATTRIBUTE_GENERIC;
			break;
		case 1:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		case 2:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 3:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC;
			break;
		case 4:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 1:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 7:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 11:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 10:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 12:
		/* Element[CHARACTERS[STRING]] */
	case 17:
		/* Element[CHARACTERS[INTEGER]] */
	case 18:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 19:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 20:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 21:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 25:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 24:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 29:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 28:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 32:
		/* Element[CHARACTERS[STRING]] */
	case 37:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 36:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 38:
		/* Element[CHARACTERS[STRING]] */
	case 40:
		/* Element[CHARACTERS[STRING]] */
	case 41:
		/* Element[CHARACTERS[STRING]] */
	case 48:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 47:
		/* Element[CHARACTERS[INTEGER]] */
	case 49:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 52:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 53:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 54:
		/* Element[CHARACTERS[STRING]] */
	case 55:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 56:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 57:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 58:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 59:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 45:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 62:
		/* Element[CHARACTERS[FLOAT]] */
	case 63:
		/* Element[CHARACTERS[DATETIME]] */
	case 64:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 65:
		/* Element[CHARACTERS[LIST]] */
	case 67:
		/* Element[CHARACTERS[STRING]] */
	case 68:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 46:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 69:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 70:
		/* Element[CHARACTERS[STRING]] */
	case 71:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 74:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 75:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 76:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 77:
		/* Element[CHARACTERS[STRING]] */
	case 78:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 79:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 80:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 81:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 35:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 82:
		/* Element[CHARACTERS[DATETIME]] */
	case 44:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 83:
		/* Element[CHARACTERS[INTEGER]] */
	case 84:
		/* Element[CHARACTERS[DATETIME]] */
	case 85:
		/* Element[CHARACTERS[STRING]] */
	case 86:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 87:
		/* Element[CHARACTERS[STRING]] */
	case 88:
		/* Element[CHARACTERS[DATETIME]] */
	case 89:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 91:
		/* Element[CHARACTERS[INTEGER]] */
	case 93:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 95:
		/* Element[CHARACTERS[LIST]] */
	case 96:
		/* Element[CHARACTERS[STRING]] */
	case 98:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 99:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 101:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 100:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 102:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 103:
		/* Element[CHARACTERS[FLOAT]] */
	case 104:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 106:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 107:
		/* Element[CHARACTERS[INTEGER]] */
	case 111:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 108:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 43:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 112:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 114:
		/* Element[CHARACTERS[STRING]] */
	case 116:
		/* Element[CHARACTERS[DECIMAL]] */
	case 118:
		/* Element[CHARACTERS[STRING]] */
	case 119:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 120:
		/* Element[CHARACTERS[STRING]] */
	case 121:
		/* Element[CHARACTERS[DATETIME]] */
	case 123:
		/* Element[CHARACTERS[DATETIME]] */
	case 122:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 126:
		/* Element[CHARACTERS[DATETIME]] */
	case 130:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 131:
		/* Element[CHARACTERS[STRING]] */
	case 132:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 133:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 134:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 135:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 136:
		/* Element[CHARACTERS[INTEGER]] */
	case 137:
		/* Element[CHARACTERS[STRING]] */
	case 140:
		/* Element[CHARACTERS[LIST]] */
	case 139:
		/* Element[CHARACTERS[DATETIME]] */
	case 138:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 141:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 143:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 144:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 145:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_CHARACTERS;
			break;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 2:
		/* Element[END_ELEMENT] */
	case 39:
		/* Element[END_ELEMENT] */
	case 127:
		/* Element[END_ELEMENT] */
	case 129:
		/* Element[END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 13:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
		case 1:
			*nextEvent = EXI_EVENT_START_ELEMENT;
			break;
		case 2:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;
	case 23:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 51:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = EXI_EVENT_START_ELEMENT_GENERIC;
			break;
		case 1:
			*nextEvent = EXI_EVENT_END_ELEMENT;
			break;
		case 2:
			*nextEvent = EXI_EVENT_CHARACTERS_GENERIC;
			break;
		case 3:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			break;
		default:
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
			break;
		}
		break;

	default:
		if(ruleID < 0)  {
			/* built-in element grammar */
			numberOfProductions = state->runtimeGrammars[(ruleID + 1)*(-1)].numberOfProductions;
			if(numberOfProductions > 0) {
				/* decode 1st level event code */
				errn = exiGetCodingLength(numberOfProductions + 1, &codingLength);
				if(errn) {
					return errn;
				}
				errn = decodeNBitUnsignedInteger(stream, codingLength, &eventCode1);
				if(errn) {
					return errn;
				}

				if(eventCode1 == numberOfProductions) {
					/* 2nd level */
					errn = exiDecodeNext2Event(stream, state, nextEvent);
				} else {
					/* 1st level event not supported in profile */
					errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
				}
			} else {
				errn = exiDecodeNext2Event(stream, state, nextEvent);
			}
		} else {
			*nextEvent = EXI_EVENT_ERROR;
			errn = EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
		}
		break;
	}

	currEvent = *nextEvent;
	return errn;
}

#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandDecodeStartDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 0 ) {
		/* move on */
		state->grammarStack[state->stackIndex] = 13;
		return 0;
	} 
	if ( state->grammarStack[state->stackIndex] == 105 ) {
		/* move on */
		state->grammarStack[state->stackIndex] = 42;
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_START_DOCUMENT;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */

#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandDecodeEndDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 42) {
		return 0;
	} 
	if ( state->grammarStack[state->stackIndex] == 14) {
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_END_DOCUMENT;
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */


int exiappHandDecodeStartElement(bitstream_t* stream, exi_state_t* state,
		uint16_t* qnameID) {
	errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;

	switch(currEvent) {
	case EXI_EVENT_START_ELEMENT:
		switch (state->grammarStack[state->stackIndex]) {
		case 3:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 4, 5);
				break;
			}
			break;
		case 4:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 124, 5);
				break;
			}
			break;
		case 5:
			/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 2, 31, 18);
				break;
			}
			break;
		case 8:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 9, 5);
				break;
			}
			break;
		case 9:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 92, 5);
				break;
			}
			break;
		case 13:
			/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 65, 14, 15);
				break;
			case 1:
				errn = _exiDecodeStartElement(state, *qnameID = 66, 14, 16);
				break;
			}
			break;
		case 15:
			/* FirstStartTag[START_ELEMENT(AppProtocol)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 3, 5);
				break;
			}
			break;
		case 16:
			/* FirstStartTag[START_ELEMENT(ResponseCode)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 3, 66, 44);
				break;
			}
			break;
		case 26:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 27, 5);
				break;
			}
			break;
		case 27:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 97, 5);
				break;
			}
			break;
		case 30:
			/* Element[START_ELEMENT(ProtocolNamespace)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 2, 31, 18);
				break;
			}
			break;
		case 31:
			/* Element[START_ELEMENT(VersionNumberMajor)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 5, 33, 46);
				break;
			}
			break;
		case 33:
			/* Element[START_ELEMENT(VersionNumberMinor)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 6, 34, 35);
				break;
			}
			break;
		case 34:
			/* Element[START_ELEMENT(SchemaID)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 4, 90, 45);
				break;
			}
			break;
		case 42:
			/* FragmentContent[START_ELEMENT(AppProtocol), START_ELEMENT(Priority), START_ELEMENT(ProtocolNamespace), START_ELEMENT(ResponseCode), START_ELEMENT(SchemaID), START_ELEMENT(VersionNumberMajor), START_ELEMENT(VersionNumberMinor), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC, END_DOCUMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 42, 5);
				break;
			case 1:
				errn = _exiDecodeStartElement(state, *qnameID = 1, 42, 43);
				break;
			case 2:
				errn = _exiDecodeStartElement(state, *qnameID = 2, 42, 18);
				break;
			case 3:
				errn = _exiDecodeStartElement(state, *qnameID = 3, 42, 44);
				break;
			case 4:
				errn = _exiDecodeStartElement(state, *qnameID = 4, 42, 45);
				break;
			case 5:
				errn = _exiDecodeStartElement(state, *qnameID = 5, 42, 46);
				break;
			case 6:
				errn = _exiDecodeStartElement(state, *qnameID = 6, 42, 35);
				break;
			case 7:
				errn = _exiDecodeStartElement(state, *qnameID = 65, 42, 15);
				break;
			case 8:
				errn = _exiDecodeStartElement(state, *qnameID = 66, 42, 16);
				break;
			}
			break;
		case 60:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 61, 5);
				break;
			}
			break;
		case 61:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 26, 5);
				break;
			}
			break;
		case 66:
			/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 4, 129, 45);
				break;
			}
			break;
		case 72:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 73, 5);
				break;
			}
			break;
		case 73:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 109, 5);
				break;
			}
			break;
		case 90:
			/* Element[START_ELEMENT(Priority)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 1, 127, 43);
				break;
			}
			break;
		case 92:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 113, 5);
				break;
			}
			break;
		case 94:
			/* Element[START_ELEMENT(AppProtocol)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 3, 5);
				break;
			}
			break;
		case 97:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 39, 5);
				break;
			}
			break;
		case 109:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 110, 5);
				break;
			}
			break;
		case 110:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 60, 5);
				break;
			}
			break;
		case 113:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 115, 5);
				break;
			}
			break;
		case 115:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 72, 5);
				break;
			}
			break;
		case 117:
			/* Element[START_ELEMENT(ResponseCode)] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 3, 66, 44);
				break;
			}
			break;
		case 124:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 125, 5);
				break;
			}
			break;
		case 125:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 128, 5);
				break;
			}
			break;
		case 128:
			/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
			switch(state->eventCode) {
			case 0:
				errn = _exiDecodeStartElement(state, *qnameID = 0, 8, 5);
				break;
			}
			break;

		}
		break;
	case EXI_EVENT_START_ELEMENT_NS:
		errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;
		break;
	case EXI_EVENT_START_ELEMENT_GENERIC:
	case EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED:
		errn = _exiDecodeQName(stream, state, qnameID,
				&_qname);
		if (errn) {
			return errn;
		}

		/* update current rule --> element content rule (if not already) */
		errn = exi_appHand_MoveToElementContentRule(state);
		if (errn) {
			return errn;
		}

		/* retrieve global grammar(existing OR runtime) and push it stack */
		errn = exi_appHand_RetrieveAndPushGlobalGrammar(state, *qnameID);
		break;
	default:
		errn = EXI_ERROR_UNEXPECTED_START_ELEMENT;
		break;
	}

	return errn;
}



/*int exiappHandDecodeStartElementGeneric(bitstream_t* stream, exi_state_t* state,
		qname_t* qname) {
	// decode qname
	int errn = _exiDecodeQName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), qname);
	if (errn) {
		return errn;
	}

	switch (state->grammarStack[state->stackIndex]) {
	// $EXI_DECODE_START_ELEMENT_GENERIC$
	case DOC_CONTENT:
		// move on to DocEnd
		state->grammarStack[state->stackIndex] = DOC_END;
		// push new ur-type grammar on stack
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	case UR_TYPE_GRAMMAR_0:
		// move on to UR_TYPE_GRAMMAR_1
		state->grammarStack[state->stackIndex] = UR_TYPE_GRAMMAR_1;
		// push new ur-type grammar on stack
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	case UR_TYPE_GRAMMAR_1:
		// remain in UR_TYPE_GRAMMAR_1
		// push new ur-type grammar on stack
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	default:
		return EXI_ERROR_UNEXPECTED_START_ELEMENT_GENERIC;
	}

	return EXI_ERROR_UNEXPECTED_START_ELEMENT_GENERIC;
}*/

#ifndef __GNUC__
#pragma warning( disable : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */
int exiappHandDecodeEndElement(bitstream_t* stream, exi_state_t* state, uint16_t* qnameID) {
	int16_t currentID;
	switch(currEvent) {
	case EXI_EVENT_END_ELEMENT_UNDECLARED:
		currentID = state->grammarStack[state->stackIndex];
		if (currentID < 0) {
			/* runtime grammars do have IDs smaller than 0 */
			/* TODO learn EE event */
			return -1;
		}
		/* Note: no break statement */
	default:
		/* copy IDs */
		*qnameID = state->elementStack[state->stackIndex];
		/*ee->localPart  = state->elementStack[state->stackIndex].localPart;
		ee->namespaceURI = state->elementStack[state->stackIndex].namespaceURI;*/

		return exi_appHand_PopStack(state);
	}
}
#ifndef __GNUC__
#pragma warning( default : 4100 ) /* warning unreferenced parameter 'stream' */
#endif /* __GNUC__ */

/*int exiappHandDecodeEndElementUndeclared(bitstream_t* stream, exi_state_t* state, eqname_t* ee) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	if (currentID < 0) {
		// runtime grammars do have IDs smaller than 0
		// TODO learn EE event
		return -1;
	}

	return exiappHandDecodeEndElement(stream, state, ee);
}*/

int exiappHandDecodeCharacters(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int16_t moveOnID = 0;
	errn = EXI_ERROR_UNEXPECTED_CHARACTERS;

	switch(currEvent) {
	case EXI_EVENT_CHARACTERS:
	case EXI_EVENT_CHARACTERS_GENERIC:
		switch (state->grammarStack[state->stackIndex]) {
		case 53:
			/* DECIMAL */
		case 116:
			/* DECIMAL */
			val->type = EXI_DATATYPE_DECIMAL;
			errn = decodeDecimal(stream, &val->decimal);
			moveOnID = 2; /* move on ID */
			break;
		case 10:
			/* STRING */
		case 12:
			/* STRING */
		case 18:
			/* STRING */
		case 20:
			/* STRING */
		case 24:
			/* STRING */
		case 32:
			/* STRING */
		case 36:
			/* STRING */
		case 38:
			/* STRING */
		case 40:
			/* STRING */
		case 41:
			/* STRING */
		case 48:
			/* STRING */
		case 54:
			/* STRING */
		case 55:
			/* STRING */
		case 58:
			/* STRING */
		case 67:
			/* STRING */
		case 70:
			/* STRING */
		case 77:
			/* STRING */
		case 78:
			/* STRING */
		case 79:
			/* STRING */
		case 85:
			/* STRING */
		case 86:
			/* STRING */
		case 87:
			/* STRING */
		case 96:
			/* STRING */
		case 98:
			/* STRING */
		case 101:
			/* STRING */
		case 106:
			/* STRING */
		case 114:
			/* STRING */
		case 118:
			/* STRING */
		case 120:
			/* STRING */
		case 131:
			/* STRING */
		case 137:
			/* STRING */
		case 141:
			/* STRING */
		case 142:
			/* STRING */
		case 143:
			/* STRING */
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			moveOnID = 2; /* move on ID */
			break;
		case 25:
			/* LIST */
		case 29:
			/* LIST */
		case 65:
			/* LIST */
		case 95:
			/* LIST */
		case 140:
			/* LIST */
		case 144:
			/* LIST */
			val->type = EXI_DATATYPE_LIST;
			val->list.type = EXI_DATATYPE_STRING;
			errn = decodeUnsignedInteger16(stream, &val->list.len);
			moveOnID = 2; /* move on ID */
			break;
		case 112:
			/* DATETIME */
		case 126:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_TIME, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 28:
			/* BINARY_HEX */
		case 132:
			/* BINARY_HEX */
			val->type = EXI_DATATYPE_BINARY_HEX;
			errn = decodeBinary(stream, &val->binary);
			moveOnID = 2; /* move on ID */
			break;
		case 74:
			/* DATETIME */
		case 123:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GYEARMONTH, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 1:
			/* NBIT_UNSIGNED_INTEGER */
		case 45:
			/* NBIT_UNSIGNED_INTEGER */
		case 75:
			/* NBIT_UNSIGNED_INTEGER */
		case 122:
			/* NBIT_UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			errn = _decodeNBitIntegerValue(stream, &val->integer, 8, 0);
			moveOnID = 2; /* move on ID */
			break;
		case 88:
			/* DATETIME */
		case 104:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_DATETIME, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 56:
			/* NBIT_UNSIGNED_INTEGER */
		case 134:
			/* NBIT_UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			errn = _decodeNBitIntegerValue(stream, &val->integer, 8, -128);
			moveOnID = 2; /* move on ID */
			break;
		case 100:
			/* DATETIME */
		case 139:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GMONTHDAY, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 17:
			/* INTEGER */
		case 47:
			/* INTEGER */
		case 68:
			/* INTEGER */
		case 69:
			/* INTEGER */
		case 76:
			/* INTEGER */
		case 83:
			/* INTEGER */
		case 89:
			/* INTEGER */
		case 91:
			/* INTEGER */
		case 93:
			/* INTEGER */
		case 107:
			/* INTEGER */
		case 136:
			/* INTEGER */
		case 138:
			/* INTEGER */
			val->type = EXI_DATATYPE_INTEGER;
			errn = decodeInteger(stream, &val->integer);
			moveOnID = 2; /* move on ID */
			break;
		case 71:
			/* ENUMERATION */
		case 44:
			/* ENUMERATION */
			val->type = EXI_DATATYPE_ENUMERATION;
			errn = decodeNBitUnsignedInteger(stream, 2, &val->enumeration);
			moveOnID = 2; /* move on ID */
			break;
		case 64:
			/* DATETIME */
		case 82:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GMONTH, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 84:
			/* DATETIME */
		case 99:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GYEAR, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 121:
			/* DATETIME */
		case 133:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_DATE, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 63:
			/* DATETIME */
		case 135:
			/* DATETIME */
			val->type = EXI_DATATYPE_DATETIME;
			errn = decodeDateTime(stream, EXI_DATETIME_GDAY, &val->datetime);
			moveOnID = 2; /* move on ID */
			break;
		case 22:
			/* STRING */
		case 23:
			/* STRING */
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			moveOnID = 23; /* move on ID */
			break;
		case 11:
			/* FLOAT */
		case 62:
			/* FLOAT */
		case 103:
			/* FLOAT */
		case 130:
			/* FLOAT */
			val->type = EXI_DATATYPE_FLOAT;
			errn = decodeFloat(stream, &val->float_me);
			moveOnID = 2; /* move on ID */
			break;
		case 19:
			/* NBIT_UNSIGNED_INTEGER */
		case 43:
			/* NBIT_UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
			errn = _decodeNBitIntegerValue(stream, &val->integer, 5, 1);
			moveOnID = 2; /* move on ID */
			break;
		case 37:
			/* BOOLEAN */
		case 80:
			/* BOOLEAN */
			val->type = EXI_DATATYPE_BOOLEAN;
			errn = decodeBoolean(stream, &val->boolean);
			moveOnID = 2; /* move on ID */
			break;
		case 7:
			/* UNSIGNED_INTEGER */
		case 21:
			/* UNSIGNED_INTEGER */
		case 49:
			/* UNSIGNED_INTEGER */
		case 57:
			/* UNSIGNED_INTEGER */
		case 59:
			/* UNSIGNED_INTEGER */
		case 46:
			/* UNSIGNED_INTEGER */
		case 81:
			/* UNSIGNED_INTEGER */
		case 35:
			/* UNSIGNED_INTEGER */
		case 102:
			/* UNSIGNED_INTEGER */
		case 108:
			/* UNSIGNED_INTEGER */
		case 119:
			/* UNSIGNED_INTEGER */
		case 145:
			/* UNSIGNED_INTEGER */
			val->type = EXI_DATATYPE_UNSIGNED_INTEGER;
			errn = decodeUnsignedInteger(stream, &val->integer);
			moveOnID = 2; /* move on ID */
			break;
		case 50:
			/* STRING */
		case 51:
			/* STRING */
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
			moveOnID = 51; /* move on ID */
			break;
		case 52:
			/* BINARY_BASE64 */
		case 111:
			/* BINARY_BASE64 */
			val->type = EXI_DATATYPE_BINARY_BASE64;
			errn = decodeBinary(stream, &val->binary);
			moveOnID = 2; /* move on ID */
			break;

		}
		if (errn) {
			/* error */
		} else {
			/* move on */
			state->grammarStack[state->stackIndex] = moveOnID;
		}
		break;
	case EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED:
		if (state->grammarStack[state->stackIndex] < 0) {
			/* runtime grammars do have IDs smaller than 0 */
			return EXI_UNSUPPORTED_GRAMMAR_LEARNING_CH;
		}

		/* update current rule --> element content rule (if not already) */
		errn = exi_appHand_MoveToElementContentRule(state);
		if (errn) {
			return errn;
		}

		/* read content value as STRING */
		val->type = EXI_DATATYPE_STRING;
		errn = decodeStringValue(stream, state, state->elementStack[state->stackIndex], &val->str);
		break;
	default:
		errn = EXI_ERROR_UNEXPECTED_CHARACTERS;
		break;
	}

	return errn;
}

/*int exiappHandDecodeCharactersGeneric(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	return exiappHandDecodeCharacters(stream, state, val);
}*/

/*int exiappHandDecodeCharactersGenericUndeclared(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int errn = 0;
	if (state->grammarStack[state->stackIndex] < 0) {
		// runtime grammars do have IDs smaller than 0
		// TODO learn CH event
		return -1;
	}

	// update current rule --> element content rule (if not already)
	errn = exiMoveToElementContentRule(state);
	if (errn) {
		return errn;
	}

	// read content value
	// STRING
	val->type = EXI_DATATYPE_STRING;
	errn = decodeStringValue(stream, &val->string);
	return errn;
}*/

int exiappHandDecodeAttributeGenericValue(bitstream_t* stream, exi_state_t* state, uint16_t* qnameID, exi_value_t* val) {
	int16_t currentID;

	if (_qname.uri.id == 2 && _qname.localName.id == 1 ) {
		/* xsi:type --> QName type */
		errn = exiappHandDecodeAttributeXsiType(stream, state, val);
	} else {
		currentID = state->grammarStack[state->stackIndex];
		if (currentID >= 0) {
			/* if schema-informed value type according global attribute */
			switch(*qnameID) {

			default:
				val->type = EXI_DATATYPE_STRING;
				errn = decodeStringValue(stream, state, *qnameID, &val->str);
				break;
			}

		} else {
			val->type = EXI_DATATYPE_STRING;
			errn = decodeStringValue(stream, state, *qnameID, &val->str);
		}
	}

	return errn;
}

int exiappHandDecodeAttribute(bitstream_t* stream, exi_state_t* state,
		uint16_t* qnameID, exi_value_t* val) {
	int16_t moveOnID = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE;

	switch(currEvent) {
	case EXI_EVENT_ATTRIBUTE:
	case EXI_EVENT_ATTRIBUTE_INVALID_VALUE:
		switch (currentID) {

		}

		if (errn) {
			/* error */
		} else {
			/* move on */
			state->grammarStack[state->stackIndex] = moveOnID;
		}
		break;
	case EXI_EVENT_ATTRIBUTE_GENERIC:
	case EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED:
		errn = _exiDecodeQName(stream, state, qnameID, &_qname);
		if (errn) {
			return errn;
		}
		/* learn attribute ? */
		errn = exi_appHand_LearnAttribute(state, *qnameID, _qname.uri.id,  _qname.localName.id);
		if (errn) {
			return errn;
		}
		/* decode attribute value */
		errn = exiappHandDecodeAttributeGenericValue(stream, state, qnameID, val);
		break;
	default:
		errn = EXI_ERROR_UNEXPECTED_ATTRIBUTE;
		break;
	}

	return errn;
}



/*int exiappHandDecodeAttributeGenericUndeclared(bitstream_t* stream, exi_state_t* state,
		qname_t* at, exi_value_t* val) {
	int errn;
	int16_t currentID = state->grammarStack[state->stackIndex];

	if (currentID < 0) {
		// TODO runtime elements
		return -1;
	} else {
		// decode qname
		errn = _exiDecodeQName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), at);
		if (errn) {
			return errn;
		}
	}


	if (currentID < 0) {
		// TODO learn AT event
		return -1;
	}

	 decode attribute value
	val->type = EXI_DATATYPE_STRING;
	errn = decodeStringValue(stream, &val->string);

	// we do not move forward in grammars

	return errn;
}*/



int exiappHandDecodeAttributeXsiNil(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	errn = decodeBoolean(stream, &val->boolean);
	if (errn >= 0 && val->boolean) {
		/* handle xsi:nil == true */
		 errn = exi_appHand_HandleXsiNilTrue(state);
	}
	return errn;
}


int exiappHandDecodeAttributeXsiType(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	/*uint32_t uriID;
	uint32_t localNameID; */
	/* uri */
	errn =_exiDecodeNamespaceUri(stream, state, &_qname.uri); /* NULL, &uriID); */
	if (errn) {
		return errn;
	}
	/* localName */
	errn = _exiDecodeLocalName(stream, state, _qname.uri.id, &_qname.localName); /* NULL, &localNameID, uriID);*/
	if (errn) {
		return errn;
	}

	val->type = EXI_DATATYPE_QNAME;
	val->eqname.namespaceURI = _qname.uri.id; /*  uriID; */
	val->eqname.localPart = _qname.localName.id; /* localNameID; */

	/* handle xsi type cast */
	errn = exi_appHand_HandleXsiType(state, &val->eqname);

	return errn;
}



#endif

