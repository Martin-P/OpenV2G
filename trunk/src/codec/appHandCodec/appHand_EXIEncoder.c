/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 2012-01-31 
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 ********************************************************************/



#ifndef EXI_appHand_ENCODER_C
#define EXI_appHand_ENCODER_C

#include "EXITypes.h"
#include "BitOutputStream.h"
#include "EncoderChannel.h"

#include "StringTable.h"
#include "appHand_NameTableEntries.h"
#include "MethodsBag.h"

#include "EXICoder.h"
#include "EXIHeaderEncoder.h"




/* local variables */
uint32_t bits;
static int errn;

/* ==================================== */

/* <0 ... Error, 1 .. Not-Found, 0.. Success */
static int _exiGet1stLevelEventCode(exi_state_t* state, exi_event_t eventType, uint16_t* resGrammarID) {
	/* retrieve current grammar-rule ID */
	uint16_t grammarID = state->grammarStack[ state->stackIndex ];

	switch(grammarID) {
	case DOCUMENT:
		switch(eventType) {
		case START_DOCUMENT:
			*resGrammarID = 0;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case DOC_CONTENT:
		switch(eventType) {
		/* TODO other IDs */
		case START_ELEMENT_GENERIC:
			*resGrammarID = 0;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case DOC_END:
		switch(eventType) {
		case END_DOCUMENT:
			*resGrammarID = 0;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case UR_TYPE_GRAMMAR_0:
		switch(eventType) {
		case ATTRIBUTE_GENERIC:
			*resGrammarID = 0;
			return 0;
		case START_ELEMENT_GENERIC:
			*resGrammarID = 1;
			return 0;
		case END_ELEMENT:
			*resGrammarID = 2;
			return 0;
		case CHARACTERS_GENERIC:
			*resGrammarID = 3;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	case UR_TYPE_GRAMMAR_1:
		switch(eventType) {
		case START_ELEMENT_GENERIC:
			*resGrammarID = 0;
			return 0;
		case END_ELEMENT:
			*resGrammarID = 1;
			return 0;
		case CHARACTERS_GENERIC:
			*resGrammarID = 2;
			return 0;
		default:
			return 1; /* not found */
		}
		break;
	}

	return 1; /* not found */
}


static int _exiGetEventCodeLength(exi_state_t* state, uint16_t* eventCodeLength) {
	/* retrieve current grammar-rule ID */
	uint16_t grammarID = state->grammarStack[ state->stackIndex ];

	switch(grammarID) {
	/* TODO OTHER IDs */
	case DOCUMENT:
		*eventCodeLength = 0;
		return 0;
	case DOC_CONTENT:
		/* TODO other root elements */
		*eventCodeLength = IS_STRICT ? 0 : 1;
		return 0;
	case DOC_END:
		*eventCodeLength = IS_STRICT ? 0 : 1;
		return 0;
	case UR_TYPE_GRAMMAR_0:
		*eventCodeLength = IS_STRICT ? 4 : 5;
		return 0;
	case UR_TYPE_GRAMMAR_1:
		*eventCodeLength = IS_STRICT ? 3 : 4;
		return 0;
	}

	return EXI_ERROR_UNEXPECTED_GRAMMAR_ID;
}

static int _encodeNBitIntegerValue(bitstream_t* stream, integer_t* iv, uint16_t nbits, int32_t lowerBound) {
	int errn;
	uint32_t val;
	switch(iv->type) {
	/* Unsigned Integer */
	case UNSIGNED_INTEGER_8:
		val = iv->val.int8 - lowerBound;
		break;
	case UNSIGNED_INTEGER_16:
		val = iv->val.int16 - lowerBound;
		break;
	case UNSIGNED_INTEGER_32:
		val = iv->val.int32 - lowerBound;
		break;
	case UNSIGNED_INTEGER_64:
		val = iv->val.int64 - lowerBound;
		break;
	/* (Signed) Integer */
	case INTEGER_8:
		val = iv->val.uint8 - lowerBound;
		break;
	case INTEGER_16:
		val = iv->val.uint16 - lowerBound;
		break;
	case INTEGER_32:
		val = iv->val.uint32 - lowerBound;
		break;
	case INTEGER_64:
		val = iv->val.uint64 - lowerBound;
		break;
	}

	errn = encodeNBitUnsignedInteger(stream, nbits, val);
	return errn;
}

#define MAX_NUMBER_CHARACTERS 50
char nameCharacters [MAX_NUMBER_CHARACTERS];

/*
#define MAX_NUMBER_URI 1
#define MAX_NUMBER_LOCALNAMES 0
char * uris [MAX_NUMBER_URI];
exi_name_table_runtime_t nameTableRuntime = {MAX_NUMBER_URI, uris, 0};
*/

int exiappHandInitEncoder(bitstream_t* stream, exi_state_t* state, exi_name_table_runtime_t runtimeTable) {
	/* init grammar state */
	state->stackIndex = 0;
	state->grammarStack[0] = DOCUMENT;
	/* string tables */
	state->nameTablePrepopulated = exiappHandNameTablePrepopulated;
	state->nameTableRuntime = runtimeTable;
	/* encode header */
	return writeEXIHeader(stream);
}

int exiappHandEncodeStartDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 0 ) {
		/* move on */
		state->grammarStack[state->stackIndex] = 1;
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_START_DOCUMENT;
}

int exiappHandEncodeEndDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 2) {
		encodeFinish(stream);
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_END_DOCUMENT;
}

static int _exiEncodeNamespaceUriID(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable, uint16_t uriID) {
	int errn;
	uint16_t uriCodingLength;
	uint16_t uriSize;

	errn = exiGetUriSize(nameTable, runtimeTable, &uriSize);
	if (errn) {
		return errn;
	}
	/* URI Entries + 1 */
	errn = exiGetCodingLength(uriSize + 1, &uriCodingLength);
	if (errn) {
		return errn;
	}

	/* uri string value found */
	/* ==> value(i+1) is encoded as n-bit unsigned integer */
	errn = encodeNBitUnsignedInteger(stream, uriCodingLength, uriID+1);

	return errn;
}


static int _exiEncodeLocalNameID(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		uint16_t uriID, uint16_t localNameID) {
	int errn;
	uint16_t localNameSize;
	uint16_t localNameCodingLength;

	/* string value found in local partition */
	/* ==> string value is represented as zero (0) encoded as an */
	errn = encodeUnsignedInteger32(stream, 0 );
	if (errn < 0) {
		return errn;
	}
	/* Unsigned Integer followed by an the compact identifier of the */
	/* string value as an n-bit unsigned integer n is log2 m and m is */
	/* the number of entries in the string table partition */
	errn = exiGetLocalNameSize(nameTable, runtimeTable, uriID, &localNameSize);
	if (errn < 0) {
		return errn;
	}
	errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
	if (errn) {
		return errn;
	}
	errn = encodeNBitUnsignedInteger(stream, localNameCodingLength, localNameID);
	return errn;

}



static int _exiEncodeStartElement(bitstream_t* stream, uint16_t nbits,
		uint32_t val, exi_state_t* state, eqname_t* se, uint16_t stackId,
		uint16_t newState) {
	/* event-code */
	int errn = encodeNBitUnsignedInteger(stream, nbits, val);
	if (errn) {
		return errn;
	}
	/* move on */
	state->grammarStack[state->stackIndex] = stackId;
	/* push element on stack */
	return exiPushStack(state, newState, se);
}

int exiappHandEncodeStartElement(bitstream_t* stream, exi_state_t* state, eqname_t* se) {
	switch (state->grammarStack[state->stackIndex]) {
		case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */ 
		if ( se->localPart == 6 && se->namespaceURI == 4  ) {
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 2, 3);
		}
		else if ( se->localPart == 7 && se->namespaceURI == 4 ) {
			/* SE( {urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes ) */
			return _exiEncodeStartElement(stream, 2, 1, state, se, 2, 43);
		}
		else {
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 2, 2, state, se, 2, 49);
		}
		break;
	case 3:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 4, 5);
		}
		break;
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 23, 5);
		}
		break;
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */ 
		if ( se->localPart == 2 && se->namespaceURI == 0  ) {
			/* SE( ProtocolNamespace ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 6, 7);
		}
		break;
	case 6:
		/* Element[START_ELEMENT(VersionNumberMajor)] */ 
		if ( se->localPart == 5 && se->namespaceURI == 0  ) {
			/* SE( VersionNumberMajor ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 11, 12);
		}
		break;
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */ 
		if ( se->localPart == 6 && se->namespaceURI == 0  ) {
			/* SE( VersionNumberMinor ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 14, 15);
		}
		break;
	case 14:
		/* Element[START_ELEMENT(SchemaID)] */ 
		if ( se->localPart == 4 && se->namespaceURI == 0  ) {
			/* SE( SchemaID ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 16, 17);
		}
		break;
	case 16:
		/* Element[START_ELEMENT(Priority)] */ 
		if ( se->localPart == 1 && se->namespaceURI == 0  ) {
			/* SE( Priority ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 19, 20);
		}
		break;
	case 22:
		/* Element[START_ELEMENT(ProtocolNamespace)] */ 
		if ( se->localPart == 2 && se->namespaceURI == 0  ) {
			/* SE( ProtocolNamespace ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 6, 7);
		}
		break;
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 24, 5);
		}
		break;
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 25, 5);
		}
		break;
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 26, 5);
		}
		break;
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 27, 5);
		}
		break;
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 28, 5);
		}
		break;
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 29, 5);
		}
		break;
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 30, 5);
		}
		break;
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 31, 5);
		}
		break;
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 32, 5);
		}
		break;
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 33, 5);
		}
		break;
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 34, 5);
		}
		break;
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 35, 5);
		}
		break;
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 36, 5);
		}
		break;
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 37, 5);
		}
		break;
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 38, 5);
		}
		break;
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 39, 5);
		}
		break;
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 40, 5);
		}
		break;
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 41, 5);
		}
		break;
	case 42:
		/* Element[START_ELEMENT(AppProtocol)] */ 
		if ( se->localPart == 0 && se->namespaceURI == 0  ) {
			/* SE( AppProtocol ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 4, 5);
		}
		break;
	case 43:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */ 
		if ( se->localPart == 3 && se->namespaceURI == 0  ) {
			/* SE( ResponseCode ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 44, 45);
		}
		break;
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */ 
		if ( se->localPart == 4 && se->namespaceURI == 0  ) {
			/* SE( SchemaID ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 47, 17);
		}
		break;
	case 48:
		/* Element[START_ELEMENT(ResponseCode)] */ 
		if ( se->localPart == 3 && se->namespaceURI == 0  ) {
			/* SE( ResponseCode ) */
			return _exiEncodeStartElement(stream, 1, 0, state, se, 44, 45);
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 3, 1, state, se, 50, 49);
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 50, 49);
		}
		break;
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 3, 1, state, se, 76, 49);
		}
		break;
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */ 
		{
			/* SE( null ) */
			return _exiEncodeStartElement(stream, 2, 0, state, se, 76, 49);
		}
		break;

	default:
		return EXI_ERROR_UNEXPECTED_START_ELEMENT;
	}

	return EXI_ERROR_UNEXPECTED_START_ELEMENT;
}


/* Look first for qualified name */
int exiappHandEncodeStartElementGeneric(bitstream_t* stream, exi_state_t* state,
		string_ascii_t* namespaceURI , string_ascii_t* localName) {
	int errn = -1;

	return errn;
}


int exiappHandEncodeEndElement(bitstream_t* stream, exi_state_t* state) {
	int errn = 0;
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = encodeNBitUnsignedInteger(stream, 3, 2);
		break;
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = encodeNBitUnsignedInteger(stream, 2, 1);
		break;
	case 8:
		/* Element[END_ELEMENT] */
	case 19:
		/* Element[END_ELEMENT] */
	case 41:
		/* Element[END_ELEMENT] */
	case 47:
		/* Element[END_ELEMENT] */
		errn = encodeNBitUnsignedInteger(stream, 1, 0);
		break;

	default:
		return EXI_ERROR_UNEXPECTED_END_ELEMENT;
	}

	if (errn < 0) {
		return errn;
	}

	/* pop item */
	return exiPopStack(state);
}

static int _exiValueToString(exi_value_t* val) {
	if (val->type == STRING) {
		return 0;
	} else {
		/* TODO convert typed value to string */
		return EXI_ERROR_CONVERSION_TYPE_TO_STRING;
	}
}

int exiappHandEncodeCharacters(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int errn;
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
		case 119:
	case 125:
	case 137:
	case 138:
	case 140:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 90:
		/* Element[CHARACTERS[DECIMAL]] */
		if (val->type == DECIMAL) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDecimal(stream, &val->decimal);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 79:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
		if (val->type == BINARY_BASE64) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 107:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
		if (val->type == BINARY_HEX) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == STRING) {
			encodeNBitUnsignedInteger(stream, 2, 2);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 76;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 2, 3);
			encodeNBitUnsignedInteger(stream, 1, 1);
		}
		break;
	case 108:
		/* Element[CHARACTERS[BINARY_HEX]] */
		if (val->type == BINARY_HEX) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 52:
	case 60:
	case 66:
		/* Element[CHARACTERS[LIST]] */
		if (val->type == LIST) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			/* List not supported properly yet, produce valid stream */
			errn = encodeUnsignedInteger32(stream, 0);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 85:
	case 87:
	case 97:
	case 99:
	case 101:
	case 103:
	case 105:
	case 131:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
		if (val->type == DATETIME) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDateTime(stream, &val->datetime);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 80:
		/* Element[CHARACTERS[BINARY_BASE64]] */
		if (val->type == BINARY_BASE64) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBinary(stream, &val->binary);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 82:
		/* Element[CHARACTERS[BOOLEAN]] */
		if (val->type == BOOLEAN) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBoolean(stream, val->boolean);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 45:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
		if (val->type == ENUMERATION) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeNBitUnsignedInteger(stream, 2, val->enumeration);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == STRING) {
			encodeNBitUnsignedInteger(stream, 2, 2);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 50;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 2, 3);
			encodeNBitUnsignedInteger(stream, 1, 1);
		}
		break;
	case 12:
	case 15:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 7:
	case 53:
	case 55:
	case 57:
	case 61:
	case 63:
	case 67:
	case 69:
	case 71:
	case 73:
	case 77:
	case 93:
	case 113:
	case 123:
	case 129:
	case 133:
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
		if (val->type == STRING) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 109:
	case 111:
	case 115:
	case 117:
	case 121:
	case 127:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
		if (val->type == INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 18:
	case 136:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, 0);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == STRING) {
			encodeNBitUnsignedInteger(stream, 3, 3);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 76;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 3, 4);
			encodeNBitUnsignedInteger(stream, 3, 5);
		}
		break;
	case 21:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 5, 1);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 92:
	case 96:
		/* Element[CHARACTERS[FLOAT]] */
		if (val->type == FLOAT) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeFloat(stream, &val->float_me);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 110:
	case 112:
	case 116:
	case 118:
	case 122:
	case 128:
		/* Element[CHARACTERS[INTEGER]] */
		if (val->type == INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		if (val->type == STRING) {
			encodeNBitUnsignedInteger(stream, 3, 3);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 50;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 3, 4);
			encodeNBitUnsignedInteger(stream, 3, 5);
		}
		break;
	case 91:
	case 95:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
		if (val->type == FLOAT) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeFloat(stream, &val->float_me);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 83:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, -128);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 20:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 5, 1);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 17:
	case 135:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, 0);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 13:
	case 120:
	case 126:
	case 139:
	case 141:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
		if (val->type == UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeUnsignedInteger(stream, &val->integer);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 86:
	case 88:
	case 98:
	case 100:
	case 102:
	case 104:
	case 106:
	case 132:
		/* Element[CHARACTERS[DATETIME]] */
		if (val->type == DATETIME) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDateTime(stream, &val->datetime);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 46:
		/* Element[CHARACTERS[ENUMERATION]] */
		if (val->type == ENUMERATION) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeNBitUnsignedInteger(stream, 2, val->enumeration);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 51:
	case 59:
	case 65:
		/* FirstStartTag[CHARACTERS[LIST]] */
		if (val->type == LIST) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			/* List not supported properly yet, produce valid stream */
			errn = encodeUnsignedInteger32(stream, 0);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 89:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
		if (val->type == DECIMAL) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeDecimal(stream, &val->decimal);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 84:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		if (val->type == NBIT_UNSIGNED_INTEGER) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = _encodeNBitIntegerValue(stream, &val->integer, 8, -128);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;
	case 81:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
		if (val->type == BOOLEAN) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeBoolean(stream, val->boolean);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 3, 6);
		}
		break;
	case 10:
	case 54:
	case 56:
	case 58:
	case 62:
	case 64:
	case 68:
	case 70:
	case 72:
	case 74:
	case 78:
	case 94:
	case 114:
	case 124:
	case 130:
	case 134:
	case 143:
		/* Element[CHARACTERS[STRING]] */
		if (val->type == STRING) {
			encodeNBitUnsignedInteger(stream, 1, 0);
			errn = encodeStringValue(stream, &val->string);
			if (errn) {
				return errn;
			}
			/* move on */
			state->grammarStack[state->stackIndex] = 8;
			return 0;
		} else { 
			/* deviant characters */ 
			encodeNBitUnsignedInteger(stream, 1, 1);
			encodeNBitUnsignedInteger(stream, 2, 2);
		}
		break;

	default:
		return EXI_ERROR_UNEXPECTED_CHARACTERS;
	}

	if (currentID < 0) {
		/* runtime rules */
		return -1;
	} else {
		/* convert typed value to string for EXI encoding */
		errn = _exiValueToString(val);
		if (errn) {
			return errn;
		}
		/* undeclared CH event code already written */
		/* encode deviant value */
		errn = encodeStringValue(stream, &val->string);
		if (errn) {
			return errn;
		}

		/* move to element content rule if not already */
		errn = exiMoveToElementContentRule( state);
	}

	return errn;
}


int exiappHandEncodeAttribute(bitstream_t* stream, exi_state_t* state, eqname_t* at,
		exi_value_t* val) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	switch (currentID) {
	
	}

	/* no expected attribute */
	if (currentID < 0) {
		/* runtime element */
		return -1;
	} else {
		return +1;
	}

	/* return EXI_ERROR_UNEXPECTED_ATTRIBUTE; */
}

int exiappHandEncodeAttributeXsiNil(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {

	switch (state->grammarStack[state->stackIndex]) {

	}

	if (errn < 0) {
		return errn;
	}

	errn = encodeBoolean(stream, val->boolean);
	if (errn >= 0 && val->boolean) {
		/* handle xsi:nil == true */
		 errn = exiHandleXsiNilTrue(state);
	}
	return errn;
}

int exiappHandEncodeAttributeXsiType(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	/* encode xsi:type event code */
	switch (state->grammarStack[state->stackIndex]) {
	case 12:
		errn = encodeNBitUnsignedInteger(stream, 1, 1);
		errn = encodeNBitUnsignedInteger(stream, 3, 1);
		break;
	case 15:
		errn = encodeNBitUnsignedInteger(stream, 1, 1);
		errn = encodeNBitUnsignedInteger(stream, 3, 1);
		break;

	default:
		return EXI_ERROR_UNEXPECTED_ATTRIBUTE_XSI_TYPE;
	}
	if (errn < 0) {
		return errn;
	}

	/* encode qname */
	errn = _exiEncodeNamespaceUriID(stream, &state->nameTablePrepopulated, &state->nameTableRuntime, val->eqname.namespaceURI);
	if (errn < 0) {
		return errn;
	}
	errn = _exiEncodeLocalNameID(stream, &state->nameTablePrepopulated, &state->nameTableRuntime, val->eqname.namespaceURI, val->eqname.localPart);
	if (errn < 0) {
		return errn;
	}

	/* handle xsi type cast */
	errn = exiHandleXsiType(state, &val->eqname);

	return errn;
}

#endif

