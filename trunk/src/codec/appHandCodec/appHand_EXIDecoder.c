/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.6
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 ********************************************************************/



#ifndef EXI_appHand_DECODER_C
#define EXI_appHand_DECODER_C

#include "EXITypes.h"
#include "BitInputStream.h"
#include "DecoderChannel.h"
#include "CoderChannel.h"

#include "StringTable.h"
#include "NameTableEntries.h"
#include "MethodsBag.h"

#include "EXICoder.h"
#include "EXIHeaderDecoder.h"



/* local variables */
static uint32_t xsi;
static uint32_t bits;
static int errn;

/* temporary over-read list values */
static int _decodeListValues(bitstream_t* stream, exi_datatype_t dt, uint16_t len) {
	unsigned int i, k;

	uint8_t uint8;
	uint16_t uint16;
	uint32_t uint32;
	integer_t iv;
	int64_t int64;

	for(i = 0; i<len; i++) {
		switch(dt) {
		case BINARY_BASE64:
		case BINARY_HEX:
			errn = decodeUnsignedInteger32(stream, &uint32);
			for(k = 0; k<uint32; k++) {
				errn = decode(stream, &uint8);
			}
			break;
		case BOOLEAN:
			errn = decodeNBitUnsignedInteger(stream, 1, &uint32);
			break;
		case BOOLEAN_FACET:
			errn = decodeNBitUnsignedInteger(stream, 2, &uint32);
			break;
		case DECIMAL:
			errn = decodeNBitUnsignedInteger(stream, 1, &uint32);
			errn = decodeUnsignedInteger32(stream, &uint32);
			errn = decodeUnsignedInteger32(stream, &uint32);
			break;
		case FLOAT:
			errn = decodeInteger64(stream, &int64);
			errn = decodeInteger64(stream, &int64);
			break;
		case NBIT_UNSIGNED_INTEGER:
			/* there is an lost int methods */
			return EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		case UNSIGNED_INTEGER:
			errn = decodeUnsignedInteger(stream, &iv);
			break;
		case INTEGER:
			errn = decodeInteger(stream, &iv);
			break;
		case DATETIME:
			/* more stuff to do */
			return -1;
			break;
		case STRING:
			errn = decodeUnsignedInteger16(stream, &uint16);
			for(k = 0; k<(uint16 - 2); k++) {
				errn= decodeUnsignedInteger32(stream, &uint32);
			}
			break;
		default:
			return EXI_UNSUPPORTED_LIST_VALUE_TYPE;
		}
	}

	return 0;
}


int exiappHandInitDecoder(bitstream_t* stream, exi_state_t* state, exi_name_table_runtime_t runtimeTable) {
	/* init grammar state */
	state->stackIndex = 0;
	state->grammarStack[0] = DOCUMENT;
	/* string table */
	/* state->nameTablePrepopulated = exiappHandNameTablePrepopulated; */
	state->nameTableRuntime = runtimeTable;
	/* decode header */
	return readEXIHeader(stream);
}

static int exiDecodeNext2Event(bitstream_t* stream, exi_state_t* state,
		exi_event_t* nextEvent) {
	uint32_t eventCode2 = 0;

	switch (state->grammarStack[state->stackIndex]) {
	case 70:
		/* Element[CHARACTERS[STRING]] */
	case 124:
		/* Element[CHARACTERS[STRING]] */
	case 96:
		/* Element[CHARACTERS[FLOAT]] */
	case 88:
		/* Element[CHARACTERS[DATETIME]] */
	case 139:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 46:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 22:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 134:
		/* Element[CHARACTERS[STRING]] */
	case 98:
		/* Element[CHARACTERS[DATETIME]] */
	case 120:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 54:
		/* Element[CHARACTERS[STRING]] */
	case 68:
		/* Element[CHARACTERS[STRING]] */
	case 72:
		/* Element[CHARACTERS[STRING]] */
	case 100:
		/* Element[CHARACTERS[DATETIME]] */
	case 21:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 78:
		/* Element[CHARACTERS[STRING]] */
	case 141:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 52:
		/* Element[CHARACTERS[LIST]] */
	case 82:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 84:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 60:
		/* Element[CHARACTERS[LIST]] */
	case 116:
		/* Element[CHARACTERS[INTEGER]] */
	case 128:
		/* Element[CHARACTERS[INTEGER]] */
	case 13:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 90:
		/* Element[CHARACTERS[DECIMAL]] */
	case 42:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 143:
		/* Element[CHARACTERS[STRING]] */
	case 110:
		/* Element[CHARACTERS[INTEGER]] */
	case 66:
		/* Element[CHARACTERS[LIST]] */
	case 92:
		/* Element[CHARACTERS[FLOAT]] */
	case 112:
		/* Element[CHARACTERS[INTEGER]] */
	case 58:
		/* Element[CHARACTERS[STRING]] */
	case 14:
		/* Element[START_ELEMENT(SchemaID)] */
	case 122:
		/* Element[CHARACTERS[INTEGER]] */
	case 16:
		/* Element[START_ELEMENT(Priority)] */
	case 104:
		/* Element[CHARACTERS[DATETIME]] */
	case 114:
		/* Element[CHARACTERS[STRING]] */
	case 108:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 106:
		/* Element[CHARACTERS[DATETIME]] */
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 74:
		/* Element[CHARACTERS[STRING]] */
	case 6:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 64:
		/* Element[CHARACTERS[STRING]] */
	case 62:
		/* Element[CHARACTERS[STRING]] */
	case 102:
		/* Element[CHARACTERS[DATETIME]] */
	case 130:
		/* Element[CHARACTERS[STRING]] */
	case 126:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 118:
		/* Element[CHARACTERS[INTEGER]] */
	case 48:
		/* Element[START_ELEMENT(ResponseCode)] */
	case 10:
		/* Element[CHARACTERS[STRING]] */
	case 136:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 80:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 86:
		/* Element[CHARACTERS[DATETIME]] */
	case 56:
		/* Element[CHARACTERS[STRING]] */
	case 132:
		/* Element[CHARACTERS[DATETIME]] */
	case 94:
		/* Element[CHARACTERS[STRING]] */
	case 18:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		errn = decodeNBitUnsignedInteger(stream, 2, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = END_ELEMENT_UNDECLARED;
			return errn;
		case 1:
			*nextEvent = START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 2:
			*nextEvent = CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;
	case 8:
		/* Element[END_ELEMENT] */
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 47:
		/* Element[END_ELEMENT] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 19:
		/* Element[END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 41:
		/* Element[END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 1, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 1:
			*nextEvent = CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = ATTRIBUTE_XSI_TYPE;
			return errn;
		case 1:
			*nextEvent = ATTRIBUTE_XSI_NIL;
			return errn;
		case 2:
			*nextEvent = ATTRIBUTE_GENERIC_UNDECLARED;
			return errn;
		case 3:
			*nextEvent = ATTRIBUTE_INVALID_VALUE;
			return errn;
		case 4:
			*nextEvent = START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 5:
			*nextEvent = CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;
	case 109:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 113:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 12:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 140:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 57:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 135:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
	case 111:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 103:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 7:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 89:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 123:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 61:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 73:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 53:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 91:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 99:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 59:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 63:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 93:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 115:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 71:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 77:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 121:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 101:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 95:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 17:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 117:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 3:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 79:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 85:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 97:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 67:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 87:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 137:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 81:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 119:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 51:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 105:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 69:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 45:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 65:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 129:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 55:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 43:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 20:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 83:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 125:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 138:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 15:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 133:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 131:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 107:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 127:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &eventCode2);
		switch (eventCode2) {
		case 0:
			*nextEvent = END_ELEMENT_UNDECLARED;
			return errn;
		case 1:
			*nextEvent = ATTRIBUTE_XSI_TYPE;
			return errn;
		case 2:
			*nextEvent = ATTRIBUTE_XSI_NIL;
			return errn;
		case 3:
			*nextEvent = ATTRIBUTE_GENERIC_UNDECLARED;
			return errn;
		case 4:
			*nextEvent = ATTRIBUTE_INVALID_VALUE;
			return errn;
		case 5:
			*nextEvent = START_ELEMENT_GENERIC_UNDECLARED;
			return errn;
		case 6:
			*nextEvent = CHARACTERS_GENERIC_UNDECLARED;
			return errn;
		}
		break;

	default:
		*nextEvent = ERROR;
		return EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
	}

	return EXI_ERROR_UNEXPECTED_EVENT_LEVEL2;
}


int exiappHandDecodeNextEvent(bitstream_t* stream, exi_state_t* state,
		exi_event_t* nextEvent) {
	state->eventCode = 0;

	switch (state->grammarStack[state->stackIndex]) {
	case 109:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 113:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 12:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 140:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 70:
		/* Element[CHARACTERS[STRING]] */
	case 124:
		/* Element[CHARACTERS[STRING]] */
	case 57:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 96:
		/* Element[CHARACTERS[FLOAT]] */
	case 135:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 88:
		/* Element[CHARACTERS[DATETIME]] */
	case 111:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 139:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 103:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 46:
		/* Element[CHARACTERS[ENUMERATION]] */
	case 7:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 89:
		/* FirstStartTag[CHARACTERS[DECIMAL]] */
	case 134:
		/* Element[CHARACTERS[STRING]] */
	case 123:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 61:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 98:
		/* Element[CHARACTERS[DATETIME]] */
	case 120:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 73:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 53:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 91:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 99:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 54:
		/* Element[CHARACTERS[STRING]] */
	case 59:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 68:
		/* Element[CHARACTERS[STRING]] */
	case 72:
		/* Element[CHARACTERS[STRING]] */
	case 63:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 93:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 115:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 100:
		/* Element[CHARACTERS[DATETIME]] */
	case 21:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 71:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 77:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 142:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 78:
		/* Element[CHARACTERS[STRING]] */
	case 121:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 141:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 52:
		/* Element[CHARACTERS[LIST]] */
	case 101:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 95:
		/* FirstStartTag[CHARACTERS[FLOAT]] */
	case 17:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 82:
		/* Element[CHARACTERS[BOOLEAN]] */
	case 117:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 84:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 60:
		/* Element[CHARACTERS[LIST]] */
	case 79:
		/* FirstStartTag[CHARACTERS[BINARY_BASE64]] */
	case 85:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 116:
		/* Element[CHARACTERS[INTEGER]] */
	case 97:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 128:
		/* Element[CHARACTERS[INTEGER]] */
	case 67:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 13:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 87:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 90:
		/* Element[CHARACTERS[DECIMAL]] */
	case 137:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 81:
		/* FirstStartTag[CHARACTERS[BOOLEAN]] */
	case 119:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 143:
		/* Element[CHARACTERS[STRING]] */
	case 110:
		/* Element[CHARACTERS[INTEGER]] */
	case 66:
		/* Element[CHARACTERS[LIST]] */
	case 51:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 92:
		/* Element[CHARACTERS[FLOAT]] */
	case 112:
		/* Element[CHARACTERS[INTEGER]] */
	case 58:
		/* Element[CHARACTERS[STRING]] */
	case 105:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 122:
		/* Element[CHARACTERS[INTEGER]] */
	case 69:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 104:
		/* Element[CHARACTERS[DATETIME]] */
	case 114:
		/* Element[CHARACTERS[STRING]] */
	case 45:
		/* FirstStartTag[CHARACTERS[ENUMERATION]] */
	case 65:
		/* FirstStartTag[CHARACTERS[LIST]] */
	case 108:
		/* Element[CHARACTERS[BINARY_HEX]] */
	case 129:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 106:
		/* Element[CHARACTERS[DATETIME]] */
	case 55:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 74:
		/* Element[CHARACTERS[STRING]] */
	case 20:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 83:
		/* FirstStartTag[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 125:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 64:
		/* Element[CHARACTERS[STRING]] */
	case 62:
		/* Element[CHARACTERS[STRING]] */
	case 102:
		/* Element[CHARACTERS[DATETIME]] */
	case 138:
		/* FirstStartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 130:
		/* Element[CHARACTERS[STRING]] */
	case 126:
		/* Element[CHARACTERS[UNSIGNED_INTEGER]] */
	case 15:
		/* First(xsi:type)StartTag[CHARACTERS[UNSIGNED_INTEGER]] */
	case 133:
		/* FirstStartTag[CHARACTERS[STRING]] */
	case 118:
		/* Element[CHARACTERS[INTEGER]] */
	case 131:
		/* FirstStartTag[CHARACTERS[DATETIME]] */
	case 10:
		/* Element[CHARACTERS[STRING]] */
	case 136:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
	case 80:
		/* Element[CHARACTERS[BINARY_BASE64]] */
	case 86:
		/* Element[CHARACTERS[DATETIME]] */
	case 56:
		/* Element[CHARACTERS[STRING]] */
	case 107:
		/* FirstStartTag[CHARACTERS[BINARY_HEX]] */
	case 127:
		/* FirstStartTag[CHARACTERS[INTEGER]] */
	case 132:
		/* Element[CHARACTERS[DATETIME]] */
	case 94:
		/* Element[CHARACTERS[STRING]] */
	case 18:
		/* Element[CHARACTERS[NBIT_UNSIGNED_INTEGER]] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = CHARACTERS;
			return errn;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			return errn;
		}
		break;
	case 0:
		/* Document[START_DOCUMENT] */
		*nextEvent = START_DOCUMENT;
		return errn;
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
	case 22:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
	case 3:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
	case 42:
		/* Element[START_ELEMENT(AppProtocol)] */
	case 14:
		/* Element[START_ELEMENT(SchemaID)] */
	case 16:
		/* Element[START_ELEMENT(Priority)] */
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
	case 43:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
	case 6:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
	case 48:
		/* Element[START_ELEMENT(ResponseCode)] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = START_ELEMENT;
			return errn;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			return errn;
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 3, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = ATTRIBUTE_GENERIC;
			return errn;
		case 1:
			*nextEvent = START_ELEMENT_GENERIC;
			return errn;
		case 2:
			*nextEvent = END_ELEMENT;
			return errn;
		case 3:
			*nextEvent = CHARACTERS_GENERIC;
			return errn;
		case 4:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			return errn;
		}
		break;
	case 2:
		/* DocEnd[END_DOCUMENT] */
		*nextEvent = END_DOCUMENT;
		return errn;
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = START_ELEMENT;
			return errn;
		case 1:
			*nextEvent = END_ELEMENT;
			return errn;
		case 2:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			return errn;
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = START_ELEMENT_GENERIC;
			return errn;
		case 1:
			*nextEvent = END_ELEMENT;
			return errn;
		case 2:
			*nextEvent = CHARACTERS_GENERIC;
			return errn;
		case 3:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			return errn;
		}
		break;
	case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
		errn = decodeNBitUnsignedInteger(stream, 2, &state->eventCode);
		switch (state->eventCode) {
		case 0:
		case 1:
			*nextEvent = START_ELEMENT;
			return errn;
		case 2:
			*nextEvent = START_ELEMENT_GENERIC;
			return errn;
		}
		break;
	case 8:
		/* Element[END_ELEMENT] */
	case 47:
		/* Element[END_ELEMENT] */
	case 19:
		/* Element[END_ELEMENT] */
	case 41:
		/* Element[END_ELEMENT] */
		errn = decodeNBitUnsignedInteger(stream, 1, &state->eventCode);
		switch (state->eventCode) {
		case 0:
			*nextEvent = END_ELEMENT;
			return errn;
		case 1:
			/* 2nd level events */
			errn = exiDecodeNext2Event(stream, state, nextEvent);
			return errn;
		}
		break;

	default:
		*nextEvent = ERROR;
		return EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
	}

	return EXI_ERROR_UNEXPECTED_EVENT_LEVEL1;
}

int exiappHandDecodeStartDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 0 ) {
		/* move on */
		state->grammarStack[state->stackIndex] = 1;
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_START_DOCUMENT;
}

int exiappHandDecodeEndDocument(bitstream_t* stream, exi_state_t* state) {
	if ( state->grammarStack[state->stackIndex] == 2) {
		return 0;
	} 

	return EXI_ERROR_UNEXPECTED_END_DOCUMENT;
}

static int _exiDecodeStartElement(exi_state_t* state, eqname_t* se,
		uint16_t ns, uint16_t ln, uint16_t stackId, uint16_t newState) {
	se->namespaceURI = ns;
	se->localPart = ln;
	/* move on */
	state->grammarStack[state->stackIndex] = stackId;
	/* push element on stack */
	return exiPushStack(state, newState, se);
}


int exiappHandDecodeStartElement(bitstream_t* stream, exi_state_t* state,
		eqname_t* se) {
	switch (state->grammarStack[state->stackIndex]) {
	case 1:
		/* DocContent[START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolReq), START_ELEMENT({urn:iso:15118:2:2010:AppProtocol}supportedAppProtocolRes), START_ELEMENT_GENERIC] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 4, 6, 2, 3);
		case 1:
			return _exiDecodeStartElement(state, se, 4, 7, 2, 43);
		case 2:
			return _exiDecodeStartElement(state, se, -1, -1, 2, 49);
		}
		break;
	case 3:
		/* FirstStartTag[START_ELEMENT(AppProtocol)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 4, 5);
		}
		break;
	case 4:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 23, 5);
		}
		break;
	case 5:
		/* FirstStartTag[START_ELEMENT(ProtocolNamespace)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 2, 6, 7);
		}
		break;
	case 6:
		/* Element[START_ELEMENT(VersionNumberMajor)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 5, 11, 12);
		}
		break;
	case 11:
		/* Element[START_ELEMENT(VersionNumberMinor)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 6, 14, 15);
		}
		break;
	case 14:
		/* Element[START_ELEMENT(SchemaID)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 4, 16, 17);
		}
		break;
	case 16:
		/* Element[START_ELEMENT(Priority)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 1, 19, 20);
		}
		break;
	case 22:
		/* Element[START_ELEMENT(ProtocolNamespace)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 2, 6, 7);
		}
		break;
	case 23:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 24, 5);
		}
		break;
	case 24:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 25, 5);
		}
		break;
	case 25:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 26, 5);
		}
		break;
	case 26:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 27, 5);
		}
		break;
	case 27:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 28, 5);
		}
		break;
	case 28:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 29, 5);
		}
		break;
	case 29:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 30, 5);
		}
		break;
	case 30:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 31, 5);
		}
		break;
	case 31:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 32, 5);
		}
		break;
	case 32:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 33, 5);
		}
		break;
	case 33:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 34, 5);
		}
		break;
	case 34:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 35, 5);
		}
		break;
	case 35:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 36, 5);
		}
		break;
	case 36:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 37, 5);
		}
		break;
	case 37:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 38, 5);
		}
		break;
	case 38:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 39, 5);
		}
		break;
	case 39:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 40, 5);
		}
		break;
	case 40:
		/* Element[START_ELEMENT(AppProtocol), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 41, 5);
		}
		break;
	case 42:
		/* Element[START_ELEMENT(AppProtocol)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 0, 4, 5);
		}
		break;
	case 43:
		/* FirstStartTag[START_ELEMENT(ResponseCode)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 3, 44, 45);
		}
		break;
	case 44:
		/* Element[START_ELEMENT(SchemaID), END_ELEMENT] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 4, 47, 17);
		}
		break;
	case 48:
		/* Element[START_ELEMENT(ResponseCode)] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, 0, 3, 44, 45);
		}
		break;
	case 49:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		switch(state->eventCode) {
		case 1:
			return _exiDecodeStartElement(state, se, -1, -1, 50, 49);
		}
		break;
	case 50:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, -1, -1, 50, 49);
		}
		break;
	case 75:
		/* FirstStartTag[ATTRIBUTE_GENERIC, START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		switch(state->eventCode) {
		case 1:
			return _exiDecodeStartElement(state, se, -1, -1, 76, 49);
		}
		break;
	case 76:
		/* Element[START_ELEMENT_GENERIC, END_ELEMENT, CHARACTERS_GENERIC[STRING]] */
		switch(state->eventCode) {
		case 0:
			return _exiDecodeStartElement(state, se, -1, -1, 76, 49);
		}
		break;

	default:
		return EXI_ERROR_UNEXPECTED_START_ELEMENT;
	}

	return EXI_ERROR_UNEXPECTED_START_ELEMENT;
}


static int _exiDecodeNamespaceUri(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		string_ascii_t* namespaceURI, uint32_t* uriID) {
	uint16_t uriSize, uriCodingLength;
	int errn;

	errn = exiGetUriSize(nameTable, runtimeTable, &uriSize);
	if (errn) {
		return errn;
	}
	/* URI Entries + 1 */
	errn = exiGetCodingLength(uriSize + 1, &uriCodingLength);
	if (errn) {
		return errn;
	}

	errn = decodeNBitUnsignedInteger(stream, uriCodingLength, uriID);
	if (errn) {
		return errn;
	}

	if (*uriID == 0) {
		/* uri string value was not found */
		/* ==> zero (0) as an n-nit unsigned integer */
		/* followed by uri encoded as string */
		decodeStringASCII(stream, namespaceURI);
		/* after encoding string value is added to table */
		errn = exiAddUri(nameTable, runtimeTable, namespaceURI->chars);
		if (errn) {
			return errn;
		}
		*uriID = uriSize;
	} else {
		/* uri string value found */
		/* ==> value(i+1) is encoded as n-bit unsigned integer */
		*uriID = *uriID - 1;
	}

	return 0;
}

static int _exiDecodeLocalName(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		string_ascii_t* localName,
		uint32_t* localNameID, uint32_t uriID) {
	uint16_t slen;
	uint16_t localNameSize;
	uint16_t localNameCodingLength;


	int errn = decodeUnsignedInteger16(stream, &slen);
	if (errn) {
		return errn;
	}

	if (slen > 0) {
		/* string value was not found in local partition */
		/* ==> string literal is encoded as a String */
		/* with the length of the string incremented by one */
		if (slen-- >= localName->size) {
			return EXI_ERROR_OUT_OF_BOUNDS;
		}
		errn = decodeCharactersASCII(stream, slen, localName->chars);
		if (errn) {
			return errn;
		}
		/* After encoding the string value, it is added to the string table */
		/* partition and assigned the next available compact identifier */
		errn = exiAddLocalName(nameTable, runtimeTable, uriID, localName->chars);
		if (errn) {
			return errn;
		}
		/* TODO UCD Profile */
		/* qname = addLocalName(localName, uriID); */
	} else {
		/* string value found in local partition */
		/* ==> string value is represented as zero (0) encoded as an */
		/* Unsigned Integer */
		/* followed by an the compact identifier of the string value as an */
		/* n-bit unsigned integer */
		/* n is log2 m and m is the number of entries in the string table */
		/* partition */
		errn = exiGetLocalNameSize(nameTable, runtimeTable, uriID, &localNameSize);
		if (errn) {
			return errn;
		}
		errn = exiGetCodingLength(localNameSize, &localNameCodingLength);
		if (errn) {
			return errn;
		}
		errn = decodeNBitUnsignedInteger(stream, localNameCodingLength, localNameID);
		if (errn) {
			return errn;
		}
	}

	return 0;
}

static int _exiDecodeQName(bitstream_t* stream, exi_name_table_prepopulated_t* nameTable, exi_name_table_runtime_t* runtimeTable,
		qname_t* qname) {
	uint32_t uriID;
	uint32_t localNameID;
	/* const char * clocalName; */

	/* uri */
	int errn =_exiDecodeNamespaceUri(stream, nameTable, runtimeTable, &qname->namespaceURI, &uriID);
	if (errn) {
		return errn;
	}
	/* localName */
	errn = _exiDecodeLocalName(stream, nameTable, runtimeTable, &qname->localName, &localNameID, uriID);
	if (errn) {
		return errn;
	}

	/*
	errn = exiGetLocalName(nameTable, runtimeTable, uriID, localNameID, &clocalName);
	if (errn) {
		return errn;
	}
	strcpy ( qname->localName.chars, clocalName );
	*/

	return 0 ;
}

int exiappHandDecodeStartElementGeneric(bitstream_t* stream, exi_state_t* state,
		qname_t* qname) {
	/* decode qname */
	int errn = _exiDecodeQName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), qname);
	if (errn) {
		return errn;
	}

	switch (state->grammarStack[state->stackIndex]) {
	/* $EXI_DECODE_START_ELEMENT_GENERIC$ */
	case DOC_CONTENT:
		/* move on to DocEnd */
		state->grammarStack[state->stackIndex] = DOC_END;
		/* push new ur-type grammar on stack */
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	case UR_TYPE_GRAMMAR_0:
		/* move on to UR_TYPE_GRAMMAR_1 */
		state->grammarStack[state->stackIndex] = UR_TYPE_GRAMMAR_1;
		/* push new ur-type grammar on stack */
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	case UR_TYPE_GRAMMAR_1:
		/* remain in UR_TYPE_GRAMMAR_1 */
		/* push new ur-type grammar on stack */
		return exiPushStack(state, UR_TYPE_GRAMMAR_0, NULL);
		break;
	default:
		return EXI_ERROR_UNEXPECTED_START_ELEMENT_GENERIC;
	}

	return EXI_ERROR_UNEXPECTED_START_ELEMENT_GENERIC;
}

int exiappHandDecodeEndElement(bitstream_t* stream, exi_state_t* state, eqname_t* ee) {
	/* copy IDs */
	ee->localPart  = state->elementStack[state->stackIndex].localPart;
	ee->namespaceURI = state->elementStack[state->stackIndex].namespaceURI;

	return exiPopStack(state);
}

int exiappHandDecodeEndElementUndeclared(bitstream_t* stream, exi_state_t* state, eqname_t* ee) {
	int16_t currentID = state->grammarStack[state->stackIndex];
	if (currentID < 0) {
		/* runtime grammars do have IDs smaller than 0 */
		/* TODO learn EE event */
		return -1;
	}

	return exiappHandDecodeEndElement(stream, state, ee);
}

int exiappHandDecodeCharacters(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	switch (state->grammarStack[state->stackIndex]) {
	case 101:
		/* DATETIME */
	case 102:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiGMonthDay, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 99:
		/* DATETIME */
	case 100:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiGMonth, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 17:
		/* NBIT_UNSIGNED_INTEGER */
	case 18:
		/* NBIT_UNSIGNED_INTEGER */
	case 135:
		/* NBIT_UNSIGNED_INTEGER */
	case 136:
		/* NBIT_UNSIGNED_INTEGER */
		val->type = NBIT_UNSIGNED_INTEGER;
		errn = decodeNBitUnsignedInteger(stream, 8, &bits);
		val->integer.val.uint8 = bits + 0;
		val->integer.type = UNSIGNED_INTEGER_8;
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 45:
		/* ENUMERATION */
	case 46:
		/* ENUMERATION */
		val->type = ENUMERATION;
		errn = decodeNBitUnsignedInteger(stream, 2, &val->enumeration);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 81:
		/* BOOLEAN */
	case 82:
		/* BOOLEAN */
		val->type = BOOLEAN;
		errn = decodeBoolean(stream, &val->boolean);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 89:
		/* DECIMAL */
	case 90:
		/* DECIMAL */
		val->type = DECIMAL;
		errn = decodeDecimal(stream, &val->decimal);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 131:
		/* DATETIME */
	case 132:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiTime, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 105:
		/* DATETIME */
	case 106:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiGYearMonth, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 7:
		/* STRING */
	case 10:
		/* STRING */
	case 53:
		/* STRING */
	case 54:
		/* STRING */
	case 55:
		/* STRING */
	case 56:
		/* STRING */
	case 57:
		/* STRING */
	case 58:
		/* STRING */
	case 61:
		/* STRING */
	case 62:
		/* STRING */
	case 63:
		/* STRING */
	case 64:
		/* STRING */
	case 67:
		/* STRING */
	case 68:
		/* STRING */
	case 69:
		/* STRING */
	case 70:
		/* STRING */
	case 71:
		/* STRING */
	case 72:
		/* STRING */
	case 73:
		/* STRING */
	case 74:
		/* STRING */
	case 77:
		/* STRING */
	case 78:
		/* STRING */
	case 93:
		/* STRING */
	case 94:
		/* STRING */
	case 113:
		/* STRING */
	case 114:
		/* STRING */
	case 123:
		/* STRING */
	case 124:
		/* STRING */
	case 129:
		/* STRING */
	case 130:
		/* STRING */
	case 133:
		/* STRING */
	case 134:
		/* STRING */
	case 142:
		/* STRING */
	case 143:
		/* STRING */
		val->type = STRING;
		errn = decodeStringValue(stream, &val->string);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 50:
		/* STRING */
	case 49:
		/* STRING */
		val->type = STRING;
		errn = decodeStringValue(stream, &val->string);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 50;
		return 0;
	case 103:
		/* DATETIME */
	case 104:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiGYear, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 51:
		/* LIST */
	case 52:
		/* LIST */
	case 59:
		/* LIST */
	case 60:
		/* LIST */
	case 65:
		/* LIST */
	case 66:
		/* LIST */
		val->type = LIST;
		/* List not supported properly yet */
		val->list.type = STRING;
		errn = decodeUnsignedInteger16(stream, &val->list.len);
		if (errn) {
			return errn;
		}
		errn = _decodeListValues(stream, val->list.type, val->list.len);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 76:
		/* STRING */
	case 75:
		/* STRING */
		val->type = STRING;
		errn = decodeStringValue(stream, &val->string);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 76;
		return 0;
	case 97:
		/* DATETIME */
	case 98:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiGDay, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 87:
		/* DATETIME */
	case 88:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiDateTime, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 20:
		/* NBIT_UNSIGNED_INTEGER */
	case 21:
		/* NBIT_UNSIGNED_INTEGER */
		val->type = NBIT_UNSIGNED_INTEGER;
		errn = decodeNBitUnsignedInteger(stream, 5, &bits);
		val->integer.val.uint8 = bits + 1;
		val->integer.type = UNSIGNED_INTEGER_8;
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 109:
		/* INTEGER */
	case 110:
		/* INTEGER */
	case 111:
		/* INTEGER */
	case 112:
		/* INTEGER */
	case 115:
		/* INTEGER */
	case 116:
		/* INTEGER */
	case 117:
		/* INTEGER */
	case 118:
		/* INTEGER */
	case 121:
		/* INTEGER */
	case 122:
		/* INTEGER */
	case 127:
		/* INTEGER */
	case 128:
		/* INTEGER */
		val->type = INTEGER;
		errn = decodeInteger(stream, &val->integer);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 79:
		/* BINARY_BASE64 */
	case 80:
		/* BINARY_BASE64 */
		val->type = BINARY_BASE64;
		errn = decodeBinary(stream, &val->binary);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 83:
		/* NBIT_UNSIGNED_INTEGER */
	case 84:
		/* NBIT_UNSIGNED_INTEGER */
		val->type = NBIT_UNSIGNED_INTEGER;
		errn = decodeNBitUnsignedInteger(stream, 8, &bits);
		val->integer.val.int8 = bits + -128;
		val->integer.type = INTEGER_8;
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 85:
		/* DATETIME */
	case 86:
		/* DATETIME */
		val->type = DATETIME;
		errn = decodeDateTime(stream, exiDate, &val->datetime);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 12:
		/* UNSIGNED_INTEGER */
	case 13:
		/* UNSIGNED_INTEGER */
	case 15:
		/* UNSIGNED_INTEGER */
	case 119:
		/* UNSIGNED_INTEGER */
	case 120:
		/* UNSIGNED_INTEGER */
	case 125:
		/* UNSIGNED_INTEGER */
	case 126:
		/* UNSIGNED_INTEGER */
	case 137:
		/* UNSIGNED_INTEGER */
	case 138:
		/* UNSIGNED_INTEGER */
	case 139:
		/* UNSIGNED_INTEGER */
	case 140:
		/* UNSIGNED_INTEGER */
	case 141:
		/* UNSIGNED_INTEGER */
		val->type = UNSIGNED_INTEGER;
		errn = decodeUnsignedInteger(stream, &val->integer);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 91:
		/* FLOAT */
	case 92:
		/* FLOAT */
	case 95:
		/* FLOAT */
	case 96:
		/* FLOAT */
		val->type = FLOAT;
		errn = decodeFloat(stream, &val->float_me);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;
	case 107:
		/* BINARY_HEX */
	case 108:
		/* BINARY_HEX */
		val->type = BINARY_HEX;
		errn = decodeBinary(stream, &val->binary);
		if (errn) {
			return errn;
		}
		/* move on */
		state->grammarStack[state->stackIndex] = 8;
		return 0;

	default:
		return EXI_ERROR_UNEXPECTED_CHARACTERS;
	}

	return 0;
}

int exiappHandDecodeCharactersGeneric(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	return exiappHandDecodeCharacters(stream, state, val);
}

int exiappHandDecodeCharactersGenericUndeclared(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	int errn = 0;
	if (state->grammarStack[state->stackIndex] < 0) {
		/* runtime grammars do have IDs smaller than 0 */
		/* TODO learn CH event */
		return -1;
	}

	/* update current rule --> element content rule (if not already) */
	errn = exiMoveToElementContentRule(state);
	if (errn) {
		return errn;
	}

	/* read content value */
	/* STRING */
	val->type = STRING;
	errn = decodeStringValue(stream, &val->string);
	return errn;
}


int exiappHandDecodeAttribute(bitstream_t* stream, exi_state_t* state,
		eqname_t* at, exi_value_t* val) {
	switch (state->grammarStack[state->stackIndex]) {

	default:
		return EXI_ERROR_UNEXPECTED_ATTRIBUTE;
	}
	return EXI_ERROR_UNEXPECTED_ATTRIBUTE;
}



int exiappHandDecodeAttributeXsiNil(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	errn = decodeBoolean(stream, &val->boolean);
	if (errn >= 0 && val->boolean) {
		/* handle xsi:nil == true */
		 errn = exiHandleXsiNilTrue(state);
	}
	return errn;
}


int exiappHandDecodeAttributeXsiType(bitstream_t* stream, exi_state_t* state,
		exi_value_t* val) {
	uint32_t uriID;
	uint32_t localNameID;
	/* uri */
	errn =_exiDecodeNamespaceUri(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), NULL, &uriID);
	if (errn) {
		return errn;
	}
	/* localName */
	errn = _exiDecodeLocalName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), NULL, &localNameID, uriID);
	if (errn) {
		return errn;
	}

	val->eqname.namespaceURI = uriID;
	val->eqname.localPart = localNameID;

	/* handle xsi type cast */
	errn = exiHandleXsiType(state, &val->eqname);

	return errn;
}

int exiappHandDecodeAttributeGenericUndeclared(bitstream_t* stream, exi_state_t* state,
		qname_t* at, exi_value_t* val) {
	int errn;
	int16_t currentID = state->grammarStack[state->stackIndex];

	if (currentID < 0) {
		/* TODO runtime elements */
		return -1;
	} else {
		/* decode qname */
		errn = _exiDecodeQName(stream, &(state->nameTablePrepopulated), &(state->nameTableRuntime), at);
		if (errn) {
			return errn;
		}
	}


	if (currentID < 0) {
		/* TODO learn AT event */
		return -1;
	}

	/* decode attribute value */
	val->type = STRING;
	errn = decodeStringValue(stream, &val->string);

	/* we do not move forward in grammars */

	return errn;
}



#endif

