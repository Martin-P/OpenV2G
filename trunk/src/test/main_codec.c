/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 0.6 
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 ********************************************************************/



/*******************************************************************
 *
 * <p>Sample program to illustrate how to read an EXI stream and
 *  directly write it again to an output</p>
 *
 *  <p>e.g., data/test/sessionSetupReq.xml.exi out/test/sessionSetupReq.xml.exi</p>
 ********************************************************************/

#include <stdio.h>
#include <stdlib.h>

#include "EXIDecoder.h"
#include "StringTable.h"
#include "EXIEncoder.h"
#include "EXITypes.h"
#include "ByteStream.h"

#if EXI_STREAM == BYTE_ARRAY
/* 64 kilobytes = 65 536 bytes */
/* 1 megabyte = 1 048 576 bytes*/
#define BUFFER_SIZE 512
uint8_t bufferIn[BUFFER_SIZE];
uint8_t bufferOut[BUFFER_SIZE];
#endif /* EXI_STREAM == BYTE_ARRAY */

/* avoids warning: initializer element is not computable at load time */
#define ARRAY_SIZE_BYTES 100
uint8_t bytesData[ARRAY_SIZE_BYTES];
#define ARRAY_SIZE_STRINGS 100
uint32_t codepoints[ARRAY_SIZE_STRINGS];
#define ARRAY_SIZE_STRINGS_ASCII 100
char charsNamespaceURI[ARRAY_SIZE_STRINGS_ASCII];
char charsLocalName[ARRAY_SIZE_STRINGS_ASCII];

#if EXI_DEBUG == EXI_DEBUG_ON
static void debugValue(exi_value_t* val);
#endif /*EXI_DEBUG*/


int xmain(int argc, char *argv[]) {

	int errn = 0;

	unsigned int k;

	bitstream_t iStream, oStream;
	uint32_t posDecode;
	uint32_t posEncode;

	/* EXI set-up */
	exi_state_t stateDecode;
	exi_state_t stateEncode;
	exi_event_t event;
	eqname_t eqn; /* efficient qname */
	qname_t qn; /* ascii qname */
	exi_value_t val;

	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

	/* BINARY memory setup */
	bytes_t bytes = { ARRAY_SIZE_BYTES, bytesData, 0 };

#if EXI_DEBUG == EXI_DEBUG_ON
	const char * localName;
	const char * namespaceURI;
#endif /*EXI_DEBUG*/
	int noEndOfDocument = 1; /* true */

	/* STRING memory setup */
	string_ucs_t string = { ARRAY_SIZE_STRINGS, codepoints, 0 };
	string_ascii_t stringNamespaceURI = { ARRAY_SIZE_STRINGS_ASCII,
			charsNamespaceURI };
	string_ascii_t stringLocalName =
			{ ARRAY_SIZE_STRINGS_ASCII, charsLocalName };
	qn.namespaceURI = stringNamespaceURI;
	qn.localName = stringLocalName;

	if (argc != 3) {
		printf("Usage: %s exiInput exiOutput\n", argv[0]);
		return -1;
	}

	/* input pos */
	posDecode = 0;

#if EXI_STREAM == BYTE_ARRAY
	/* parse EXI stream to internal byte structures  */
	errn = readBytesFromFile(argv[1], bufferIn, BUFFER_SIZE, posDecode);
	if (errn < 0) {
		printf("Problems while reading file into buffer\n");
		return errn;
	}
#endif /* EXI_STREAM == BYTE_ARRAY */

	/* setup input stream */
#if EXI_STREAM == BYTE_ARRAY
	iStream.size = BUFFER_SIZE;
	iStream.data = bufferIn;
	iStream.pos = &posDecode;
#endif /* EXI_STREAM == BYTE_ARRAY */
#if EXI_STREAM == FILE_STREAM
	iStream.file = fopen(argv[1], "rb");
#endif /* EXI_STREAM == FILE_STREAM */

	iStream.buffer = 0;
	iStream.capacity = 0;

	/* setup output stream */
	posEncode = 0;
#if EXI_STREAM == BYTE_ARRAY
	oStream.size = BUFFER_SIZE;
	oStream.data = bufferOut;
	oStream.pos = &posEncode;
#endif
#if EXI_STREAM == FILE_STREAM
	oStream.file = fopen(argv[2], "wb");
#endif /* EXI_STREAM == FILE_STREAM */
	oStream.buffer = 0;
	oStream.capacity = 8;

	val.binary = bytes;
	val.string = string;

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	errn = exiInitNameTableRuntime(&runtimeTableDecode);
	exiInitDecoder(&iStream, &stateDecode, runtimeTableDecode);

	/* init encoder (write header, set initial state) */
	errn = exiInitNameTableRuntime(&runtimeTableEncode);
	exiInitEncoder(&oStream, &stateEncode, runtimeTableEncode);

#if EXI_DEBUG == EXI_DEBUG_ON
	printf("[DECODE] >>> EXI  >>> [ENCODE] \n");
#endif /*EXI_DEBUG*/

	do {
		if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
			printf("[Encode-ERROR] %d \n", errn);
#endif /*EXI_DEBUG*/
			return errn;
		}

		errn = exiDecodeNextEvent(&iStream, &stateDecode,
				&event);
		if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
			printf("[Decode-ERROR] %d \n", errn);
#endif /*EXI_DEBUG*/
			return errn;
		}

		switch (event) {
		case EXI_EVENT_START_DOCUMENT:
			/* decode */
			errn = exiDecodeStartDocument(&iStream,
					&stateDecode);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-SD] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			printf(">> START_DOCUMENT \n");
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeStartDocument(&oStream,
					&stateEncode);
			break;
		case EXI_EVENT_END_DOCUMENT:
			/* decode */
			errn = exiDecodeEndDocument(&iStream,
					&stateDecode);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-ED] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			printf(">> END_DOCUMENT \n");
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeEndDocument(&oStream,
					&stateEncode);
			/* signalize end of document */
			noEndOfDocument = 0; /* false */
			break;
		case EXI_EVENT_START_ELEMENT:
			/* decode */
			errn = exiDecodeStartElement(&iStream,
					&stateDecode, &eqn);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-SE] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			exiGetLocalName(&(stateDecode.nameTablePrepopulated),
					&(stateDecode.nameTableRuntime), eqn.namespaceURI,
					eqn.localPart, &localName);
			exiGetUri(&(stateDecode.nameTablePrepopulated),
					&(stateDecode.nameTableRuntime), eqn.namespaceURI,
					&namespaceURI);
			printf(">> SE_{%s}%s \n", namespaceURI,
					localName);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeStartElement(&oStream,
					&stateEncode, &eqn);
			break;
		case EXI_EVENT_START_ELEMENT_GENERIC:
			/* decode */
			errn = exiDecodeStartElementGeneric(&iStream,
					&stateDecode, &qn);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-SEgen] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			printf(">> SE_Gen {%s}%s \n", stringNamespaceURI.chars,
					stringLocalName.chars);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeStartElementGeneric(&oStream,
					&stateEncode, &stringNamespaceURI, &stringLocalName);
			break;
		case EXI_EVENT_END_ELEMENT:
			/* decode */
			errn = exiDecodeEndElement(&iStream,
					&stateDecode, &eqn);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-EE] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			printf("<< EE \n");
#endif /*EXI_DEBUG*/
			/* encode */
			errn
					= exiEncodeEndElement(&oStream,
							&stateEncode);
			break;
		case EXI_EVENT_END_ELEMENT_UNDECLARED:
			/* decode */
			errn = exiDecodeEndElementUndeclared(&iStream,
					&stateDecode, &eqn);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-EE-Undecl] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			printf("<< EEundecl \n");
#endif /*EXI_DEBUG*/
			/* encode */
			errn
					= exiEncodeEndElement(&oStream,
							&stateEncode);
			break;
		case EXI_EVENT_CHARACTERS:
			/* decode */
			errn = exiDecodeCharacters(&iStream,
					&stateDecode, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-CH] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			debugValue(&val);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeCharacters(&oStream,
						&stateEncode, &val);

			/* list value: special behavior */
			if (val.type == EXI_DATATYPE_LIST) {
				for(k=0; k<val.list.len; k++) {
					errn = exiDecodeListValue(&iStream, &val, val.list);
					if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
						printf("[Decode-ERROR-CH_LIST] %d \n", errn);
#endif /*EXI_DEBUG*/
						return errn;
					}
#if EXI_DEBUG == EXI_DEBUG_ON
					debugValue(&val);
#endif /*EXI_DEBUG*/
					/* encode list value */
					errn = exiEncodeListValue(&oStream,
									&val, val.list);
				}
			}
			break;
		case EXI_EVENT_CHARACTERS_GENERIC:
			/* decode */
			errn = exiDecodeCharactersGeneric(&iStream,
					&stateDecode, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-CHgen] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			debugValue(&val);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeCharacters(&oStream,
					&stateEncode, &val);
			break;
		case EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED:
			/* decode */
			errn = exiDecodeCharactersGenericUndeclared(
					&iStream, &stateDecode, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-CHgenUndecl] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			debugValue(&val);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeCharacters(&oStream,
					&stateEncode, &val);
			break;
		case EXI_EVENT_ATTRIBUTE:
			/* decode */
			errn = exiDecodeAttribute(&iStream, &stateDecode,
					&eqn, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-AT] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			exiGetLocalName(&(stateDecode.nameTablePrepopulated),
					&(stateDecode.nameTableRuntime), eqn.namespaceURI,
					eqn.localPart, &localName);
			exiGetUri(&(stateDecode.nameTablePrepopulated),
					&(stateDecode.nameTableRuntime), eqn.namespaceURI,
					&namespaceURI);
			printf(" AT {%s}%s \n", namespaceURI, localName);
			debugValue(&val);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeAttribute(&oStream, &stateEncode,
					&eqn, &val);
			break;
		case EXI_EVENT_ATTRIBUTE_XSI_NIL:
			/* decode */
			errn = exiDecodeAttributeXsiNil(&iStream,
					&stateDecode, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-AT-NIL] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			printf(" AT {xsi}nil == %i \n", val.boolean);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeAttributeXsiNil(&oStream,
					&stateEncode, &val);
			break;
		case EXI_EVENT_ATTRIBUTE_XSI_TYPE:
			/* decode */
			errn = exiDecodeAttributeXsiType(&iStream,
					&stateDecode, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-AT-TYPE] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			exiGetLocalName(&(stateDecode.nameTablePrepopulated),
					&(stateDecode.nameTableRuntime), val.eqname.namespaceURI,
					val.eqname.localPart, &localName);
			exiGetUri(&(stateDecode.nameTablePrepopulated),
					&(stateDecode.nameTableRuntime), val.eqname.namespaceURI,
					&namespaceURI);
			printf(" AT {type}type == {%s}%s \n", namespaceURI, localName);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeAttributeXsiType(&oStream,
					&stateEncode, &val);
			break;
		case EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED:
			/* decode */
			errn = exiDecodeAttributeGenericUndeclared(
					&iStream, &stateDecode, &qn, &val);
			if (errn < 0) {
#if EXI_DEBUG == EXI_DEBUG_ON
				printf("[Decode-ERROR-ATgenUnd] %d \n", errn);
#endif /*EXI_DEBUG*/
				return errn;
			}
#if EXI_DEBUG == EXI_DEBUG_ON
			/* exiGetLocalName(&(stateDecode.nameTablePrepopulated), &(stateDecode.nameTableRuntime), eqn.namespaceURI, eqn.localPart, &localName);
			 exiGetUri(&(stateDecode.nameTablePrepopulated), &(stateDecode.nameTableRuntime), eqn.namespaceURI, &namespaceURI); */
			printf(" AT {%s}%s \n", qn.namespaceURI.chars, qn.localName.chars);
			debugValue(&val);
#endif /*EXI_DEBUG*/
			/* encode */
			errn = exiEncodeAttribute(&oStream, &stateEncode,
					&eqn, &val);
			break;
		default:
			/* ERROR */
#if EXI_DEBUG == EXI_DEBUG_ON
			printf("[Unknown-Event] %d \n", event);
#endif /*EXI_DEBUG*/
			return EXI_ERROR_UNKOWN_EVENT;
		}

	} while (noEndOfDocument);

#if EXI_STREAM == BYTE_ARRAY
	/* write to file */
	writeBytesToFile(oStream.data, posEncode, argv[2]);
#endif
#if EXI_STREAM == FILE_STREAM
	fclose(iStream.file);
	fclose(oStream.file);
#endif

	return 0;
}



#if EXI_DEBUG == EXI_DEBUG_ON
static void debugValue(exi_value_t* val) {
	int i;
	switch (val->type) {
	case EXI_DATATYPE_INTEGER:
		switch (val->integer.type) {
		/* Unsigned Integer */
		case EXI_UNSIGNED_INTEGER_8:
			printf(" Value uint8 : %d \n", val->integer.val.uint8);
			break;
		case EXI_UNSIGNED_INTEGER_16:
			printf(" Value uint16 : %d \n", val->integer.val.uint16);
			break;
		case EXI_UNSIGNED_INTEGER_32:
			printf(" Value uint32 : %d \n", val->integer.val.uint32);
			break;
		case EXI_UNSIGNED_INTEGER_64:
			printf(" Value uint64 : %ld \n",
					(long unsigned int) val->integer.val.uint64);
			break;
			/* (Signed) Integer */
		case EXI_INTEGER_8:
			printf(" Value int8 : %d \n", val->integer.val.int8);
			break;
		case EXI_INTEGER_16:
			printf(" Value int16 : %d \n", val->integer.val.int16);
			break;
		case EXI_INTEGER_32:
			printf(" Value int32 : %d \n", val->integer.val.int32);
			break;
		case EXI_INTEGER_64:
			printf(" Value int64 : %ld \n", (long int) val->integer.val.int64);
			break;
		}
		break;
	case EXI_DATATYPE_BINARY_BASE64:
	case EXI_DATATYPE_BINARY_HEX:
		printf(" Value Binary (len == %d) : ", val->binary.len);
		for (i = 0; i < val->binary.len; i++) {
			printf(" [%d]", val->binary.data[i]);
		}
		printf("\n");
		break;
	case EXI_DATATYPE_BOOLEAN:
		printf(" Value Boolean : %d \n", val->boolean);
		break;
	case EXI_DATATYPE_STRING:
		printf(" Value String (len==%d) : '", val->string.len);
		for (i = 0; i < val->string.len; i++) {
			printf("%c", (char) val->string.codepoints[i]);
		}
		printf("'\n");
		break;
	case EXI_DATATYPE_LIST:
		printf(" Value List (len==%d) \n", val->list.len);
		break;
	default:
		printf(" Value ?? \n");
	}
}
#endif /*EXI_DEBUG*/

