
/*
 * Copyright (C) 2007-2012 Siemens AG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************
 *
 * @author Sebastian.Kaebisch.EXT@siemens.com
 * @version 0.7
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXISeGen</p>
 *
 ********************************************************************/


#include "appHand_service.h"
#include "appHand_dataTypes.h"
#include "EXITypes.h"
#include "StringTable.h"
#include "appHandEXIEncoder.h"
#include "appHandQNameDefines.h"
#include <string.h>
 
 uint16_t numberOfLocalStringsEncode[EXI_appHandMAX_NUMBER_OF_QNAMES];
 
 


static int serialize_AppProtocolType(struct AppProtocolType* type, struct EXIDatabinder* service)
{
		


			/* encode start element ProtocolNamespace */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 2)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_STRING;
			service->val.str.type = EXI_STRING_VALUE_MISS;
			service->val.str.miss.len = type->ProtocolNamespace.arraylen.data;
			memcpy(service->val.str.miss.codepoints, type->ProtocolNamespace.data,type->ProtocolNamespace.arraylen.data*sizeof(uint32_t));
		   
				
		
			/* encode character  ProtocolNamespace */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
					return -1;
			}
			
			 
			/* encode end element of ProtocolNamespace */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element VersionNumberMajor */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 5)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_UNSIGNED_INTEGER;
		    service->val.integer.val.uint32=type->VersionNumberMajor;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_32;
			
			/* encode character  VersionNumberMajor */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of VersionNumberMajor */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element VersionNumberMinor */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 6)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_UNSIGNED_INTEGER;
		    service->val.integer.val.uint32=type->VersionNumberMinor;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_32;
			
			/* encode character  VersionNumberMinor */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of VersionNumberMinor */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element SchemaID */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 4)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
		    service->val.integer.val.uint8=type->SchemaID;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  SchemaID */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of SchemaID */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

				


			/* encode start element Priority */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 1)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
		    service->val.integer.val.uint8=type->Priority;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  Priority */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of Priority */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		

	return 0;			
}


static int serialize_AnonType_supportedAppProtocolReq(struct AnonType_supportedAppProtocolReq* type, struct EXIDatabinder* service)
{

			size_t i_loop;
	
	for(i_loop=0;i_loop < type->arraylen.AppProtocol;i_loop++)
		{
				


			/* encode start element AppProtocol */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 0)) 
			{
					return -1;
			}
			
			/* encode children of AppProtocol */
			if(serialize_AppProtocolType(&(type->AppProtocol[i_loop]),service))
			{
				return -1;
			}
			
			 
			/* encode end element of AppProtocol */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}


static int serialize_AnonType_supportedAppProtocolRes(struct AnonType_supportedAppProtocolRes* type, struct EXIDatabinder* service)
{
		


			/* encode start element ResponseCode */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 3)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_ENUMERATION;
		    service->val.enumeration=type->ResponseCode;
		   
			
			/* encode character  ResponseCode */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of ResponseCode */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		
	if(type->isused.SchemaID)
		{		
						


			/* encode start element SchemaID */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 4)) 
			{
					return -1;
			}
			
			service->val.type = EXI_DATATYPE_NBIT_UNSIGNED_INTEGER;
		    service->val.integer.val.uint8=type->SchemaID;
		   
			service->val.integer.type = EXI_UNSIGNED_INTEGER_8;
			
			/* encode character  SchemaID */	
			if (exiappHandEncodeCharacters(&(service->outStream), &(service->stateEncode), &(service->val))) 
			{
				 
				return -1;
			}
				
			 
			/* encode end element of SchemaID */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}


static int serialize_EXIDocumentType_appHand(struct EXIDocumentType_appHand* type, struct EXIDatabinder* service)
{

	if(type->isused.supportedAppProtocolReq)
		{		
						


			/* encode start element supportedAppProtocolReq */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 65)) 
			{
					return -1;
			}
						
			/* encode children of supportedAppProtocolReq */
			if(serialize_AnonType_supportedAppProtocolReq( (type->supportedAppProtocolReq),service))
			{
				return -1;
			}

			
			 
			/* encode end element of supportedAppProtocolReq */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				
	if(type->isused.supportedAppProtocolRes)
		{		
						


			/* encode start element supportedAppProtocolRes */	
			if (exiappHandEncodeStartElement(&(service->outStream), &(service->stateEncode), 66)) 
			{
					return -1;
			}
						
			/* encode children of supportedAppProtocolRes */
			if(serialize_AnonType_supportedAppProtocolRes( (type->supportedAppProtocolRes),service))
			{
				return -1;
			}

			
			 
			/* encode end element of supportedAppProtocolRes */
			exiappHandEncodeEndElement(&(service->outStream), &(service->stateEncode));

		}
				

	return 0;			
}

 
 
 
 
 /* serialize data to EXI stream */
static int serialize_message(struct EXIDatabinder* service)
 { 

	/* encode start document */ 	
	if (exiappHandEncodeStartDocument(&(service->outStream), &(service->stateEncode)) ) 
	{
	 
		return -1;
	}

 	
	if (serialize_EXIDocumentType_appHand(&(service->exiMsg), service))	 
	 
	 
	{
			 
		return -1;
	}


	/* encode end document */
	if (exiappHandEncodeEndDocument(&(service->outStream), &(service->stateEncode))) {
	 
	return -1;
	}	
 	
 	return 0;
 	
 }

 
 
int serialize_appHand(struct EXIDatabinder* service, uint8_t* outStream, size_t* payloadLength, struct EXIDocumentType_appHand* exiDoc)
{
 	exi_name_table_runtime_t runtimeTableEncode;
	exi_string_table_t stringTableEncode = { 0, EXI_appHandMAX_NUMBER_OF_QNAMES, numberOfLocalStringsEncode};

 	uint32_t outPos =service->transportHeaderOffset;
 
 	/* assign outStream data to service EXI structure */
	service->outStream.data = outStream;
	service->outStream.pos = &outPos;
	service->outStream.buffer=0;
	service->outStream.capacity=8;
 
  	service->exiMsg = *exiDoc;
 
	/* init encoder (write header, set initial state) */
	exiInitNameTableRuntime(&runtimeTableEncode);
	exiappHandInitEncoder(&(service->outStream), &(service->stateEncode), runtimeTableEncode,stringTableEncode);
 

	if(serialize_message(service))
	{
		return -1;
	}

	outPos -= service->transportHeaderOffset;
	*payloadLength = outPos;


 	return 0;
 }
 
/* Initialize serializer */
int init_appHandSerializer(struct EXIDatabinder* service, exi_bytes_t service_bytes, exi_string_ucs_t service_string, size_t max_outStream_size, uint16_t transportHeaderOffset)
{

	/* init byte array */
	 service->val.binary = service_bytes;

	/* init string array */
	 service->val.str.miss = service_string;

	 /* init output stream */

	 service->outStream.size=max_outStream_size;

	 service->transportHeaderOffset=transportHeaderOffset;


	return 0;
}
 
